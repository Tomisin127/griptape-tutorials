{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto_1 = require(\"@iov/crypto\");\n\nvar encoding_1 = require(\"@iov/encoding\");\n\nvar types_1 = require(\"./types\");\n\nvar fromBase64 = encoding_1.Encoding.fromBase64;\n\nfunction rawSecp256k1PubkeyToAddress(pubkeyRaw, prefix) {\n  if (pubkeyRaw.length !== 33) {\n    throw new Error(\"Invalid Secp256k1 pubkey length (compressed): \".concat(pubkeyRaw.length));\n  }\n\n  var hash1 = new crypto_1.Sha256(pubkeyRaw).digest();\n  var hash2 = new crypto_1.Ripemd160(hash1).digest();\n  return encoding_1.Bech32.encode(prefix, hash2);\n}\n\nexports.rawSecp256k1PubkeyToAddress = rawSecp256k1PubkeyToAddress; // See https://github.com/tendermint/tendermint/blob/f2ada0a604b4c0763bda2f64fac53d506d3beca7/docs/spec/blockchain/encoding.md#public-key-cryptography\n// This assumes we already have a cosmos-compressed pubkey\n\nfunction pubkeyToAddress(pubkey, prefix) {\n  var pubkeyBytes = fromBase64(pubkey.value);\n\n  switch (pubkey.type) {\n    case types_1.pubkeyType.secp256k1:\n      {\n        return rawSecp256k1PubkeyToAddress(pubkeyBytes, prefix);\n      }\n\n    case types_1.pubkeyType.ed25519:\n      {\n        if (pubkeyBytes.length !== 32) {\n          throw new Error(\"Invalid Ed25519 pubkey length: \".concat(pubkeyBytes.length));\n        }\n\n        var hash = new crypto_1.Sha256(pubkeyBytes).digest();\n        return encoding_1.Bech32.encode(prefix, hash.slice(0, 20));\n      }\n\n    case types_1.pubkeyType.sr25519:\n      {\n        if (pubkeyBytes.length !== 32) {\n          throw new Error(\"Invalid Sr25519 pubkey length: \".concat(pubkeyBytes.length));\n        }\n\n        var _hash = new crypto_1.Sha256(pubkeyBytes).digest();\n\n        return encoding_1.Bech32.encode(prefix, _hash.slice(0, 20));\n      }\n\n    default:\n      throw new Error(\"Unrecognized public key algorithm\");\n  }\n}\n\nexports.pubkeyToAddress = pubkeyToAddress;","map":null,"metadata":{},"sourceType":"script"}