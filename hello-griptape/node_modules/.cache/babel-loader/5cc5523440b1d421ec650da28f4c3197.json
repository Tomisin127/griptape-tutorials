{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* tslint:disable:no-bitwise */\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar uint64MaxValue = new bn_js_1.default(\"18446744073709551615\", 10, \"be\");\n\nvar Uint32 = /*#__PURE__*/function () {\n  function Uint32(input) {\n    _classCallCheck(this, Uint32);\n\n    if (Number.isNaN(input)) {\n      throw new Error(\"Input is not a number\");\n    }\n\n    if (!Number.isInteger(input)) {\n      throw new Error(\"Input is not an integer\");\n    }\n\n    if (input < 0 || input > 4294967295) {\n      throw new Error(\"Input not in uint32 range: \" + input.toString());\n    }\n\n    this.data = input;\n  }\n\n  _createClass(Uint32, [{\n    key: \"toBytesBigEndian\",\n    value: function toBytesBigEndian() {\n      // Use division instead of shifting since bitwise operators are defined\n      // on SIGNED int32 in JavaScript and we don't want to risk surprises\n      return new Uint8Array([Math.floor(this.data / Math.pow(2, 24)) & 0xff, Math.floor(this.data / Math.pow(2, 16)) & 0xff, Math.floor(this.data / Math.pow(2, 8)) & 0xff, Math.floor(this.data / Math.pow(2, 0)) & 0xff]);\n    }\n  }, {\n    key: \"toBytesLittleEndian\",\n    value: function toBytesLittleEndian() {\n      // Use division instead of shifting since bitwise operators are defined\n      // on SIGNED int32 in JavaScript and we don't want to risk surprises\n      return new Uint8Array([Math.floor(this.data / Math.pow(2, 0)) & 0xff, Math.floor(this.data / Math.pow(2, 8)) & 0xff, Math.floor(this.data / Math.pow(2, 16)) & 0xff, Math.floor(this.data / Math.pow(2, 24)) & 0xff]);\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString();\n    }\n  }], [{\n    key: \"fromBigEndianBytes\",\n    value: function fromBigEndianBytes(bytes) {\n      if (bytes.length !== 4) {\n        throw new Error(\"Invalid input length. Expected 4 bytes.\");\n      } // tslint:disable-next-line:prefer-for-of\n\n\n      for (var i = 0; i < bytes.length; ++i) {\n        if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n          throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n        }\n      } // Use mulitiplication instead of shifting since bitwise operators are defined\n      // on SIGNED int32 in JavaScript and we don't want to risk surprises\n\n\n      return new Uint32(bytes[0] * Math.pow(2, 24) + bytes[1] * Math.pow(2, 16) + bytes[2] * Math.pow(2, 8) + bytes[3]);\n    }\n  }]);\n\n  return Uint32;\n}();\n\nexports.Uint32 = Uint32;\n\nvar Int53 = /*#__PURE__*/function () {\n  function Int53(input) {\n    _classCallCheck(this, Int53);\n\n    if (Number.isNaN(input)) {\n      throw new Error(\"Input is not a number\");\n    }\n\n    if (!Number.isInteger(input)) {\n      throw new Error(\"Input is not an integer\");\n    }\n\n    if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {\n      throw new Error(\"Input not in int53 range: \" + input.toString());\n    }\n\n    this.data = input;\n  }\n\n  _createClass(Int53, [{\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString();\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(str) {\n      if (!str.match(/^-?[0-9]+$/)) {\n        throw new Error(\"Invalid string format\");\n      }\n\n      return new Int53(Number.parseInt(str, 10));\n    }\n  }]);\n\n  return Int53;\n}();\n\nexports.Int53 = Int53;\n\nvar Uint53 = /*#__PURE__*/function () {\n  function Uint53(input) {\n    _classCallCheck(this, Uint53);\n\n    var signed = new Int53(input);\n\n    if (signed.toNumber() < 0) {\n      throw new Error(\"Input is negative\");\n    }\n\n    this.data = signed;\n  }\n\n  _createClass(Uint53, [{\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data.toNumber();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString();\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(str) {\n      var signed = Int53.fromString(str);\n      return new Uint53(signed.toNumber());\n    }\n  }]);\n\n  return Uint53;\n}();\n\nexports.Uint53 = Uint53;\n\nvar Uint64 = /*#__PURE__*/function () {\n  function Uint64(data) {\n    _classCallCheck(this, Uint64);\n\n    if (data.isNeg()) {\n      throw new Error(\"Input is negative\");\n    }\n\n    if (data.gt(uint64MaxValue)) {\n      throw new Error(\"Input exceeds uint64 range\");\n    }\n\n    this.data = data;\n  }\n\n  _createClass(Uint64, [{\n    key: \"toBytesBigEndian\",\n    value: function toBytesBigEndian() {\n      return Uint8Array.from(this.data.toArray(\"be\", 8));\n    }\n  }, {\n    key: \"toBytesLittleEndian\",\n    value: function toBytesLittleEndian() {\n      return Uint8Array.from(this.data.toArray(\"le\", 8));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString(10);\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data.toNumber();\n    }\n  }], [{\n    key: \"fromBytesBigEndian\",\n    value: function fromBytesBigEndian(bytes) {\n      if (bytes.length !== 8) {\n        throw new Error(\"Invalid input length. Expected 8 bytes.\");\n      } // tslint:disable-next-line:prefer-for-of\n\n\n      for (var i = 0; i < bytes.length; ++i) {\n        if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n          throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n        }\n      } // tslint:disable-next-line:readonly-array\n\n\n      var asArray = []; // tslint:disable-next-line:prefer-for-of\n\n      for (var _i = 0; _i < bytes.length; ++_i) {\n        asArray.push(bytes[_i]);\n      }\n\n      return new Uint64(new bn_js_1.default([].concat(asArray)));\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(str) {\n      if (!str.match(/^[0-9]+$/)) {\n        throw new Error(\"Invalid string format\");\n      }\n\n      return new Uint64(new bn_js_1.default(str, 10, \"be\"));\n    }\n  }, {\n    key: \"fromNumber\",\n    value: function fromNumber(input) {\n      if (Number.isNaN(input)) {\n        throw new Error(\"Input is not a number\");\n      }\n\n      var bigint;\n\n      try {\n        bigint = new bn_js_1.default(input);\n      } catch (_a) {\n        throw new Error(\"Input is not a safe integer\");\n      }\n\n      return new Uint64(bigint);\n    }\n  }]);\n\n  return Uint64;\n}();\n\nexports.Uint64 = Uint64;","map":null,"metadata":{},"sourceType":"script"}