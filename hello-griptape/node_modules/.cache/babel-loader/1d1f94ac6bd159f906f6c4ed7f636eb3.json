{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\Propietario\\\\hello-griptape-react\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar encoding_1 = require(\"@iov/encoding\");\n\nvar fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\n\nvar types_1 = require(\"./types\");\n\nfunction encodeSecp256k1Pubkey(pubkey) {\n  if (pubkey.length !== 33 || pubkey[0] !== 0x02 && pubkey[0] !== 0x03) {\n    throw new Error(\"Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03\");\n  }\n\n  return {\n    type: types_1.pubkeyType.secp256k1,\n    value: encoding_1.Encoding.toBase64(pubkey)\n  };\n}\n\nexports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey; // As discussed in https://github.com/binance-chain/javascript-sdk/issues/163\n// Prefixes listed here: https://github.com/tendermint/tendermint/blob/d419fffe18531317c28c29a292ad7d253f6cafdf/docs/spec/blockchain/encoding.md#public-key-cryptography\n// Last bytes is varint-encoded length prefix\n\nvar pubkeyAminoPrefixSecp256k1 = encoding_1.Encoding.fromHex(\"eb5ae98721\");\nvar pubkeyAminoPrefixEd25519 = encoding_1.Encoding.fromHex(\"1624de6420\");\nvar pubkeyAminoPrefixSr25519 = encoding_1.Encoding.fromHex(\"0dfb1005\");\nvar pubkeyAminoPrefixLength = pubkeyAminoPrefixSecp256k1.length;\n\nfunction decodeBech32Pubkey(bechEncoded) {\n  var _encoding_1$Bech32$de = encoding_1.Bech32.decode(bechEncoded),\n      data = _encoding_1$Bech32$de.data;\n\n  var aminoPrefix = data.slice(0, pubkeyAminoPrefixLength);\n  var rest = data.slice(pubkeyAminoPrefixLength);\n\n  if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixSecp256k1)) {\n    if (rest.length !== 33) {\n      throw new Error(\"Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).\");\n    }\n\n    return {\n      type: types_1.pubkeyType.secp256k1,\n      value: encoding_1.Encoding.toBase64(rest)\n    };\n  } else if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixEd25519)) {\n    if (rest.length !== 32) {\n      throw new Error(\"Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).\");\n    }\n\n    return {\n      type: types_1.pubkeyType.ed25519,\n      value: encoding_1.Encoding.toBase64(rest)\n    };\n  } else if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixSr25519)) {\n    if (rest.length !== 32) {\n      throw new Error(\"Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).\");\n    }\n\n    return {\n      type: types_1.pubkeyType.sr25519,\n      value: encoding_1.Encoding.toBase64(rest)\n    };\n  } else {\n    throw new Error(\"Unsupported Pubkey type. Amino prefix: \" + encoding_1.Encoding.toHex(aminoPrefix));\n  }\n}\n\nexports.decodeBech32Pubkey = decodeBech32Pubkey;\n\nfunction encodeBech32Pubkey(pubkey, prefix) {\n  var aminoPrefix;\n\n  switch (pubkey.type) {\n    // Note: please don't add cases here without writing additional unit tests\n    case types_1.pubkeyType.secp256k1:\n      aminoPrefix = pubkeyAminoPrefixSecp256k1;\n      break;\n\n    default:\n      throw new Error(\"Unsupported pubkey type\");\n  }\n\n  var data = new Uint8Array([].concat(_toConsumableArray(aminoPrefix), _toConsumableArray(encoding_1.Encoding.fromBase64(pubkey.value))));\n  return encoding_1.Bech32.encode(prefix, data);\n}\n\nexports.encodeBech32Pubkey = encodeBech32Pubkey;","map":null,"metadata":{},"sourceType":"script"}