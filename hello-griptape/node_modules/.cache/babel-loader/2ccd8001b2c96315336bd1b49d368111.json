{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar block_1 = require(\"../../internals/block\");\n/**\n * Polyfill for the AES-CTR (counter) mode of operation.\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n *\n * Note that CTR mode is malleable and generally should not be used without\n * authentication. Instead, use an authenticated encryption mode, like AES-SIV!\n */\n\n\nvar PolyfillAesCtr = /*#__PURE__*/function () {\n  function PolyfillAesCtr(cipher) {\n    _classCallCheck(this, PolyfillAesCtr);\n\n    // Set cipher.\n    this._cipher = cipher; // Allocate space for counter.\n\n    this._counter = new block_1.default(); // Allocate buffer for encrypted block.\n\n    this._buffer = new block_1.default();\n  }\n\n  _createClass(PolyfillAesCtr, [{\n    key: \"clear\",\n    value: function clear() {\n      this._buffer.clear();\n\n      this._counter.clear();\n\n      this._cipher.clear();\n\n      return this;\n    }\n  }, {\n    key: \"encryptCtr\",\n    value: function encryptCtr(iv, plaintext) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var bufferPos, result, i;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(iv.length !== block_1.default.SIZE)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(\"CTR: iv length must be equal to cipher block size\");\n\n              case 2:\n                // Copy IV to counter, overwriting it.\n                this._counter.data.set(iv); // Set buffer position to length of buffer\n                // so that the first cipher block is generated.\n\n\n                bufferPos = block_1.default.SIZE;\n                result = new Uint8Array(plaintext.length);\n\n                for (i = 0; i < plaintext.length; i++) {\n                  if (bufferPos === block_1.default.SIZE) {\n                    this._buffer.copy(this._counter);\n\n                    this._cipher.encryptBlock(this._buffer);\n\n                    bufferPos = 0;\n                    incrementCounter(this._counter);\n                  }\n\n                  result[i] = plaintext[i] ^ this._buffer.data[bufferPos++];\n                }\n\n                return _context.abrupt(\"return\", result);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }]);\n\n  return PolyfillAesCtr;\n}();\n\nexports.default = PolyfillAesCtr; // Increment an AES-CTR mode counter, intentionally wrapping/overflowing\n\nfunction incrementCounter(counter) {\n  var carry = 1;\n\n  for (var i = block_1.default.SIZE - 1; i >= 0; i--) {\n    carry += counter.data[i] & 0xff | 0;\n    counter.data[i] = carry & 0xff;\n    carry >>>= 8;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}