{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto_1 = require(\"@iov/crypto\");\n\nvar encoding_1 = require(\"@iov/encoding\");\n\nvar pako_1 = __importDefault(require(\"pako\"));\n\nvar builder_1 = require(\"./builder\");\n\nvar cosmwasmclient_1 = require(\"./cosmwasmclient\");\n\nvar encoding_2 = require(\"./encoding\");\n\nvar logs_1 = require(\"./logs\");\n\nvar restclient_1 = require(\"./restclient\");\n\nvar ProtoEncoding_1 = require(\"./ProtoEncoding\");\n\nfunction singleAmount(amount, denom) {\n  return [{\n    amount: amount.toString(),\n    denom: denom\n  }];\n}\n\nfunction prepareBuilder(buider) {\n  if (buider === undefined) {\n    return undefined; // normalization needed by backend\n  } else {\n    if (!builder_1.isValidBuilder(buider)) throw new Error(\"The builder (Docker Hub image with tag) is not valid\");\n    return buider;\n  }\n}\n\nvar defaultFees = {\n  upload: {\n    amount: singleAmount(250000, \"uscrt\"),\n    gas: String(1000000)\n  },\n  init: {\n    amount: singleAmount(125000, \"uscrt\"),\n    gas: String(500000)\n  },\n  exec: {\n    amount: singleAmount(50000, \"uscrt\"),\n    gas: String(200000)\n  },\n  send: {\n    amount: singleAmount(20000, \"uscrt\"),\n    gas: String(80000)\n  }\n};\n\nvar SigningCosmWasmClient = /*#__PURE__*/function (_cosmwasmclient_1$Cos) {\n  _inherits(SigningCosmWasmClient, _cosmwasmclient_1$Cos);\n\n  /**\n   * Creates a new client with signing capability to interact with a CosmWasm blockchain. This is the bigger brother of CosmWasmClient.\n   *\n   * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n   * for the lifetime of your application. When switching backends, a new instance must be created.\n   *\n   * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n   * @param senderAddress The address that will sign and send transactions using this instance\n   * @param signer An asynchronous callback to create a signature for a given transaction. This can be implemented using secure key stores that require user interaction. Or a newer OfflineSigner type that handles that stuff\n   * @param seedOrEnigmaUtils\n   * @param customFees The fees that are paid for transactions\n   * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n   */\n  function SigningCosmWasmClient(apiUrl, senderAddress, signer, seedOrEnigmaUtils, customFees) {\n    var _this;\n\n    var broadcastMode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : restclient_1.BroadcastMode.Block;\n\n    _classCallCheck(this, SigningCosmWasmClient);\n\n    if (seedOrEnigmaUtils instanceof Uint8Array) {\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(SigningCosmWasmClient).call(this, apiUrl, seedOrEnigmaUtils, broadcastMode));\n    } else {\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(SigningCosmWasmClient).call(this, apiUrl, undefined, broadcastMode));\n    }\n\n    _this.anyValidAddress = senderAddress;\n    _this.senderAddress = senderAddress; //this.signCallback = signCallback ? signCallback : undefined;\n\n    _this.signer = signer;\n\n    if (seedOrEnigmaUtils && !(seedOrEnigmaUtils instanceof Uint8Array)) {\n      _this.restClient.enigmautils = seedOrEnigmaUtils;\n    }\n\n    _this.fees = Object.assign(Object.assign({}, defaultFees), customFees || {}); // // Setup contract->hash cache\n    // // This is only needed here and not in CosmWasmClient because we\n    // // need code hashes before sending txs\n    // this.restClient.listCodeInfo().then(async (codes) => {\n    //   for (const code of codes) {\n    //     this.restClient.codeHashCache.set(code.id, code.data_hash);\n    //     const contracts = await this.restClient.listContractsByCodeId(code.id);\n    //     for (const contract of contracts) {\n    //       this.restClient.codeHashCache.set(contract.address, code.data_hash);\n    //     }\n    //   }\n    // });\n\n    return _possibleConstructorReturn(_this);\n  }\n\n  _createClass(SigningCosmWasmClient, [{\n    key: \"getNonce\",\n    value: function () {\n      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", _get(_getPrototypeOf(SigningCosmWasmClient.prototype), \"getNonce\", this).call(this, address || this.senderAddress));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getNonce(_x) {\n        return _getNonce.apply(this, arguments);\n      }\n\n      return getNonce;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function () {\n      var _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", _get(_getPrototypeOf(SigningCosmWasmClient.prototype), \"getAccount\", this).call(this, address || this.senderAddress));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getAccount(_x2) {\n        return _getAccount.apply(this, arguments);\n      }\n\n      return getAccount;\n    }()\n  }, {\n    key: \"signAdapter\",\n    value: function () {\n      var _signAdapter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(msgs, fee, chainId, memo, accountNumber, sequence) {\n        var signResponse, signBytes, signature;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(\"sign\" in this.signer)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                _context3.next = 3;\n                return this.signer.sign(this.senderAddress, {\n                  chain_id: chainId,\n                  account_number: String(accountNumber),\n                  sequence: String(sequence),\n                  fee: fee,\n                  msgs: msgs,\n                  memo: memo\n                });\n\n              case 3:\n                signResponse = _context3.sent;\n                return _context3.abrupt(\"return\", {\n                  msg: msgs,\n                  fee: signResponse.signed.fee,\n                  memo: signResponse.signed.memo,\n                  signatures: [signResponse.signature]\n                });\n\n              case 7:\n                // legacy interface\n                signBytes = encoding_2.makeSignBytes(msgs, fee, chainId, memo, accountNumber, sequence);\n                _context3.next = 10;\n                return this.signer(signBytes);\n\n              case 10:\n                signature = _context3.sent;\n                return _context3.abrupt(\"return\", {\n                  msg: msgs,\n                  fee: fee,\n                  memo: memo,\n                  signatures: [signature]\n                });\n\n              case 12:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function signAdapter(_x3, _x4, _x5, _x6, _x7, _x8) {\n        return _signAdapter.apply(this, arguments);\n      }\n\n      return signAdapter;\n    }()\n    /** Uploads code and returns a receipt, including the code ID */\n\n  }, {\n    key: \"upload\",\n    value: function () {\n      var _upload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(wasmCode) {\n        var meta,\n            memo,\n            fee,\n            source,\n            builder,\n            compressed,\n            storeCodeMsg,\n            _yield$this$getNonce,\n            accountNumber,\n            sequence,\n            chainId,\n            signedTx,\n            result,\n            codeIdAttr,\n            _args4 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                meta = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n                memo = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : \"\";\n                fee = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : this.fees.upload;\n\n                if (!memo) {\n                  memo = \"\";\n                }\n\n                if (!meta) {\n                  meta = {};\n                }\n\n                source = meta.source || undefined;\n                builder = prepareBuilder(meta.builder);\n                compressed = pako_1.default.gzip(wasmCode, {\n                  level: 9\n                });\n                storeCodeMsg = {\n                  type: \"wasm/MsgStoreCode\",\n                  value: {\n                    sender: this.senderAddress,\n                    // eslint-disable-next-line @typescript-eslint/camelcase\n                    wasm_byte_code: encoding_1.Encoding.toBase64(compressed)\n                  }\n                };\n\n                if (source && source.length > 0) {\n                  storeCodeMsg.value.source = source;\n                }\n\n                if (builder && builder.length > 0) {\n                  storeCodeMsg.value.builder = builder;\n                }\n\n                _context4.next = 13;\n                return this.getNonce();\n\n              case 13:\n                _yield$this$getNonce = _context4.sent;\n                accountNumber = _yield$this$getNonce.accountNumber;\n                sequence = _yield$this$getNonce.sequence;\n                _context4.next = 18;\n                return this.getChainId();\n\n              case 18:\n                chainId = _context4.sent;\n                _context4.next = 21;\n                return this.signAdapter([storeCodeMsg], fee, chainId, memo, accountNumber, sequence);\n\n              case 21:\n                signedTx = _context4.sent;\n                _context4.next = 24;\n                return this.postTx(signedTx);\n\n              case 24:\n                result = _context4.sent;\n\n                if (this.restClient.broadcastMode == restclient_1.BroadcastMode.Block) {\n                  codeIdAttr = logs_1.findAttribute(result.logs, \"message\", \"code_id\");\n                }\n\n                return _context4.abrupt(\"return\", {\n                  originalSize: wasmCode.length,\n                  originalChecksum: encoding_1.Encoding.toHex(new crypto_1.Sha256(wasmCode).digest()),\n                  compressedSize: compressed.length,\n                  compressedChecksum: encoding_1.Encoding.toHex(new crypto_1.Sha256(compressed).digest()),\n                  codeId: this.restClient.broadcastMode == restclient_1.BroadcastMode.Block ? Number.parseInt(codeIdAttr.value, 10) : -1,\n                  logs: result.logs,\n                  transactionHash: result.transactionHash\n                });\n\n              case 27:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function upload(_x9) {\n        return _upload.apply(this, arguments);\n      }\n\n      return upload;\n    }()\n  }, {\n    key: \"instantiate\",\n    value: function () {\n      var _instantiate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(codeId, initMsg, label) {\n        var memo,\n            transferAmount,\n            fee,\n            contractCodeHash,\n            _a,\n            instantiateMsg,\n            _yield$this$getNonce2,\n            accountNumber,\n            sequence,\n            chainId,\n            signedTx,\n            nonce,\n            result,\n            errorMessageRgx,\n            rgxMatches,\n            errorCipherB64,\n            errorCipherBz,\n            errorPlainBz,\n            contractAddress,\n            logs,\n            _args5 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                memo = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : \"\";\n                transferAmount = _args5.length > 4 ? _args5[4] : undefined;\n                fee = _args5.length > 5 && _args5[5] !== undefined ? _args5[5] : this.fees.init;\n                contractCodeHash = _args5.length > 6 ? _args5[6] : undefined;\n\n                if (contractCodeHash) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                _context5.next = 7;\n                return this.restClient.getCodeHashByCodeId(codeId);\n\n              case 7:\n                contractCodeHash = _context5.sent;\n                _context5.next = 11;\n                break;\n\n              case 10:\n                this.restClient.codeHashCache.set(codeId, contractCodeHash);\n\n              case 11:\n                if (!memo) {\n                  memo = \"\";\n                }\n\n                _context5.t0 = this.senderAddress;\n                _context5.t1 = String(codeId);\n                _context5.t2 = label;\n                _context5.t3 = encoding_1.Encoding;\n                _context5.next = 18;\n                return this.restClient.enigmautils.encrypt(contractCodeHash, initMsg);\n\n              case 18:\n                _context5.t4 = _context5.sent;\n                _context5.t5 = _context5.t3.toBase64.call(_context5.t3, _context5.t4);\n                _context5.t6 = transferAmount !== null && transferAmount !== void 0 ? transferAmount : [];\n                _context5.t7 = {\n                  sender: _context5.t0,\n                  code_id: _context5.t1,\n                  label: _context5.t2,\n                  init_msg: _context5.t5,\n                  init_funds: _context5.t6\n                };\n                instantiateMsg = {\n                  type: \"wasm/MsgInstantiateContract\",\n                  value: _context5.t7\n                };\n                _context5.next = 25;\n                return this.getNonce();\n\n              case 25:\n                _yield$this$getNonce2 = _context5.sent;\n                accountNumber = _yield$this$getNonce2.accountNumber;\n                sequence = _yield$this$getNonce2.sequence;\n                _context5.next = 30;\n                return this.getChainId();\n\n              case 30:\n                chainId = _context5.sent;\n                _context5.next = 33;\n                return this.signAdapter([instantiateMsg], fee, chainId, memo, accountNumber, sequence);\n\n              case 33:\n                signedTx = _context5.sent;\n                nonce = encoding_1.Encoding.fromBase64(instantiateMsg.value.init_msg).slice(0, 32);\n                _context5.prev = 35;\n                _context5.next = 38;\n                return this.postTx(signedTx);\n\n              case 38:\n                result = _context5.sent;\n                _context5.next = 60;\n                break;\n\n              case 41:\n                _context5.prev = 41;\n                _context5.t8 = _context5[\"catch\"](35);\n                _context5.prev = 43;\n                errorMessageRgx = /failed to execute message; message index: 0: encrypted: (.+?): (?:instantiate|execute|query) contract failed/g;\n                rgxMatches = errorMessageRgx.exec(_context5.t8.message);\n\n                if (!(rgxMatches == null || rgxMatches.length != 2)) {\n                  _context5.next = 48;\n                  break;\n                }\n\n                throw _context5.t8;\n\n              case 48:\n                errorCipherB64 = rgxMatches[1];\n                errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n                _context5.next = 52;\n                return this.restClient.enigmautils.decrypt(errorCipherBz, nonce);\n\n              case 52:\n                errorPlainBz = _context5.sent;\n                _context5.t8.message = _context5.t8.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n                _context5.next = 59;\n                break;\n\n              case 56:\n                _context5.prev = 56;\n                _context5.t9 = _context5[\"catch\"](43);\n                throw new Error(\"Failed to decrypt the following error message: \".concat(_context5.t8.message, \". Decryption error of the error message: \").concat(_context5.t9.message));\n\n              case 59:\n                throw _context5.t8;\n\n              case 60:\n                contractAddress = \"\";\n\n                if (this.restClient.broadcastMode == restclient_1.BroadcastMode.Block) {\n                  contractAddress = (_a = logs_1.findAttribute(result.logs, \"message\", \"contract_address\")) === null || _a === void 0 ? void 0 : _a.value;\n                }\n\n                if (!(this.restClient.broadcastMode == restclient_1.BroadcastMode.Block)) {\n                  _context5.next = 68;\n                  break;\n                }\n\n                _context5.next = 65;\n                return this.restClient.decryptLogs(result.logs, [nonce]);\n\n              case 65:\n                _context5.t10 = _context5.sent;\n                _context5.next = 69;\n                break;\n\n              case 68:\n                _context5.t10 = [];\n\n              case 69:\n                logs = _context5.t10;\n                return _context5.abrupt(\"return\", {\n                  contractAddress: contractAddress,\n                  logs: logs,\n                  transactionHash: result.transactionHash,\n                  data: result.data\n                });\n\n              case 71:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[35, 41], [43, 56]]);\n      }));\n\n      function instantiate(_x10, _x11, _x12) {\n        return _instantiate.apply(this, arguments);\n      }\n\n      return instantiate;\n    }()\n  }, {\n    key: \"multiExecute\",\n    value: function () {\n      var _multiExecute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(inputMsgs) {\n        var memo,\n            totalFee,\n            _a,\n            msgs,\n            _iterator,\n            _step,\n            inputMsg,\n            contractCodeHash,\n            msg,\n            _yield$this$getNonce3,\n            accountNumber,\n            sequence,\n            fee,\n            chainId,\n            signedTx,\n            result,\n            errorMessageRgx,\n            rgxMatches,\n            errorCipherB64,\n            errorCipherBz,\n            msgIndex,\n            nonce,\n            errorPlainBz,\n            nonces,\n            data,\n            dataFields,\n            logs,\n            _args6 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                memo = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : \"\";\n                totalFee = _args6.length > 2 ? _args6[2] : undefined;\n\n                if (!memo) {\n                  memo = \"\";\n                }\n\n                msgs = [];\n                _iterator = _createForOfIteratorHelper(inputMsgs);\n                _context6.prev = 5;\n\n                _iterator.s();\n\n              case 7:\n                if ((_step = _iterator.n()).done) {\n                  _context6.next = 30;\n                  break;\n                }\n\n                inputMsg = _step.value;\n                contractCodeHash = inputMsg.contractCodeHash;\n\n                if (contractCodeHash) {\n                  _context6.next = 16;\n                  break;\n                }\n\n                _context6.next = 13;\n                return this.restClient.getCodeHashByContractAddr(inputMsg.contractAddress);\n\n              case 13:\n                contractCodeHash = _context6.sent;\n                _context6.next = 17;\n                break;\n\n              case 16:\n                this.restClient.codeHashCache.set(inputMsg.contractAddress, contractCodeHash);\n\n              case 17:\n                _context6.t0 = this.senderAddress;\n                _context6.t1 = inputMsg.contractAddress;\n                _context6.t2 = encoding_1.Encoding;\n                _context6.next = 22;\n                return this.restClient.enigmautils.encrypt(contractCodeHash, inputMsg.handleMsg);\n\n              case 22:\n                _context6.t3 = _context6.sent;\n                _context6.t4 = _context6.t2.toBase64.call(_context6.t2, _context6.t3);\n                _context6.t5 = (_a = inputMsg.transferAmount, _a !== null && _a !== void 0 ? _a : []);\n                _context6.t6 = {\n                  sender: _context6.t0,\n                  contract: _context6.t1,\n                  msg: _context6.t4,\n                  sent_funds: _context6.t5\n                };\n                msg = {\n                  type: \"wasm/MsgExecuteContract\",\n                  value: _context6.t6\n                };\n                msgs.push(msg);\n\n              case 28:\n                _context6.next = 7;\n                break;\n\n              case 30:\n                _context6.next = 35;\n                break;\n\n              case 32:\n                _context6.prev = 32;\n                _context6.t7 = _context6[\"catch\"](5);\n\n                _iterator.e(_context6.t7);\n\n              case 35:\n                _context6.prev = 35;\n\n                _iterator.f();\n\n                return _context6.finish(35);\n\n              case 38:\n                _context6.next = 40;\n                return this.getNonce();\n\n              case 40:\n                _yield$this$getNonce3 = _context6.sent;\n                accountNumber = _yield$this$getNonce3.accountNumber;\n                sequence = _yield$this$getNonce3.sequence;\n                fee = totalFee !== null && totalFee !== void 0 ? totalFee : {\n                  gas: String(Number(this.fees.exec.gas) * inputMsgs.length),\n                  amount: this.fees.exec.amount\n                };\n                _context6.next = 46;\n                return this.getChainId();\n\n              case 46:\n                chainId = _context6.sent;\n                _context6.next = 49;\n                return this.signAdapter(msgs, fee, chainId, memo, accountNumber, sequence);\n\n              case 49:\n                signedTx = _context6.sent;\n                _context6.prev = 50;\n                _context6.next = 53;\n                return this.postTx(signedTx);\n\n              case 53:\n                result = _context6.sent;\n                _context6.next = 77;\n                break;\n\n              case 56:\n                _context6.prev = 56;\n                _context6.t8 = _context6[\"catch\"](50);\n                _context6.prev = 58;\n                errorMessageRgx = /failed to execute message; message index: (\\d+): encrypted: (.+?): (?:instantiate|execute|query) contract failed/g;\n                rgxMatches = errorMessageRgx.exec(_context6.t8.message);\n\n                if (!(rgxMatches == null || rgxMatches.length != 3)) {\n                  _context6.next = 63;\n                  break;\n                }\n\n                throw _context6.t8;\n\n              case 63:\n                errorCipherB64 = rgxMatches[1];\n                errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n                msgIndex = Number(rgxMatches[2]);\n                nonce = encoding_1.Encoding.fromBase64(msgs[msgIndex].value.msg).slice(0, 32);\n                _context6.next = 69;\n                return this.restClient.enigmautils.decrypt(errorCipherBz, nonce);\n\n              case 69:\n                errorPlainBz = _context6.sent;\n                _context6.t8.message = _context6.t8.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n                _context6.next = 76;\n                break;\n\n              case 73:\n                _context6.prev = 73;\n                _context6.t9 = _context6[\"catch\"](58);\n                throw new Error(\"Failed to decrypt the following error message: \".concat(_context6.t8.message, \". Decryption error of the error message: \").concat(_context6.t9.message));\n\n              case 76:\n                throw _context6.t8;\n\n              case 77:\n                nonces = msgs.map(function (msg) {\n                  return encoding_1.Encoding.fromBase64(msg.value.msg).slice(0, 32);\n                }); // //const data = await this.restClient.decryptDataField(result.data, nonces);\n                // const dataFields: MsgData[] = decodeTxData(Encoding.fromHex(result.data));\n                //\n                // let data = Uint8Array.from([]);\n                // if (dataFields[0].data) {\n                //   // dataFields[0].data = JSON.parse(decryptedData.toString());\n                //   // @ts-ignore\n                //   data = await this.restClient.decryptDataField(Encoding.toHex(Encoding.fromBase64(dataFields[0].data)), nonces);\n                // }\n                //\n                // const logs = await this.restClient.decryptLogs(result.logs, nonces);\n\n                data = Uint8Array.from([]);\n\n                if (!(this.restClient.broadcastMode == restclient_1.BroadcastMode.Block)) {\n                  _context6.next = 85;\n                  break;\n                }\n\n                dataFields = ProtoEncoding_1.decodeTxData(encoding_1.Encoding.fromHex(result.data));\n\n                if (!dataFields[0].data) {\n                  _context6.next = 85;\n                  break;\n                }\n\n                _context6.next = 84;\n                return this.restClient.decryptDataField(encoding_1.Encoding.toHex(encoding_1.Encoding.fromBase64(dataFields[0].data)), nonces);\n\n              case 84:\n                data = _context6.sent;\n\n              case 85:\n                if (!(this.restClient.broadcastMode == restclient_1.BroadcastMode.Block)) {\n                  _context6.next = 91;\n                  break;\n                }\n\n                _context6.next = 88;\n                return this.restClient.decryptLogs(result.logs, nonces);\n\n              case 88:\n                _context6.t10 = _context6.sent;\n                _context6.next = 92;\n                break;\n\n              case 91:\n                _context6.t10 = [];\n\n              case 92:\n                logs = _context6.t10;\n                return _context6.abrupt(\"return\", {\n                  logs: logs,\n                  transactionHash: result.transactionHash,\n                  // @ts-ignore\n                  data: data\n                });\n\n              case 94:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[5, 32, 35, 38], [50, 56], [58, 73]]);\n      }));\n\n      function multiExecute(_x13) {\n        return _multiExecute.apply(this, arguments);\n      }\n\n      return multiExecute;\n    }()\n  }, {\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(contractAddress, handleMsg) {\n        var memo,\n            transferAmount,\n            fee,\n            contractCodeHash,\n            executeMsg,\n            _yield$this$getNonce4,\n            accountNumber,\n            sequence,\n            chainId,\n            signedTx,\n            encryptionNonce,\n            result,\n            errorMessageRgx,\n            rgxMatches,\n            errorCipherB64,\n            errorCipherBz,\n            errorPlainBz,\n            data,\n            dataFields,\n            logs,\n            _args7 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                memo = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : \"\";\n                transferAmount = _args7.length > 3 ? _args7[3] : undefined;\n                fee = _args7.length > 4 && _args7[4] !== undefined ? _args7[4] : this.fees.exec;\n                contractCodeHash = _args7.length > 5 ? _args7[5] : undefined;\n\n                if (contractCodeHash) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                _context7.next = 7;\n                return this.restClient.getCodeHashByContractAddr(contractAddress);\n\n              case 7:\n                contractCodeHash = _context7.sent;\n                _context7.next = 11;\n                break;\n\n              case 10:\n                this.restClient.codeHashCache.set(contractAddress, contractCodeHash);\n\n              case 11:\n                if (!memo) {\n                  memo = \"\";\n                }\n\n                _context7.t0 = this.senderAddress;\n                _context7.t1 = contractAddress;\n                _context7.t2 = encoding_1.Encoding;\n                _context7.next = 17;\n                return this.restClient.enigmautils.encrypt(contractCodeHash, handleMsg);\n\n              case 17:\n                _context7.t3 = _context7.sent;\n                _context7.t4 = _context7.t2.toBase64.call(_context7.t2, _context7.t3);\n                _context7.t5 = transferAmount !== null && transferAmount !== void 0 ? transferAmount : [];\n                _context7.t6 = {\n                  sender: _context7.t0,\n                  contract: _context7.t1,\n                  msg: _context7.t4,\n                  sent_funds: _context7.t5\n                };\n                executeMsg = {\n                  type: \"wasm/MsgExecuteContract\",\n                  value: _context7.t6\n                };\n                _context7.next = 24;\n                return this.getNonce();\n\n              case 24:\n                _yield$this$getNonce4 = _context7.sent;\n                accountNumber = _yield$this$getNonce4.accountNumber;\n                sequence = _yield$this$getNonce4.sequence;\n                _context7.next = 29;\n                return this.getChainId();\n\n              case 29:\n                chainId = _context7.sent;\n                _context7.next = 32;\n                return this.signAdapter([executeMsg], fee, chainId, memo, accountNumber, sequence);\n\n              case 32:\n                signedTx = _context7.sent;\n                encryptionNonce = encoding_1.Encoding.fromBase64(executeMsg.value.msg).slice(0, 32);\n                _context7.prev = 34;\n                _context7.next = 37;\n                return this.postTx(signedTx);\n\n              case 37:\n                result = _context7.sent;\n                _context7.next = 59;\n                break;\n\n              case 40:\n                _context7.prev = 40;\n                _context7.t7 = _context7[\"catch\"](34);\n                _context7.prev = 42;\n                errorMessageRgx = /failed to execute message; message index: 0: encrypted: (.+?): (?:instantiate|execute|query) contract failed/g; // console.log(`Got error message: ${err.message}`);\n\n                rgxMatches = errorMessageRgx.exec(_context7.t7.message);\n\n                if (!(rgxMatches == null || rgxMatches.length != 2)) {\n                  _context7.next = 47;\n                  break;\n                }\n\n                throw _context7.t7;\n\n              case 47:\n                errorCipherB64 = rgxMatches[1]; // console.log(`Got error message: ${errorCipherB64}`);\n\n                errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n                _context7.next = 51;\n                return this.restClient.enigmautils.decrypt(errorCipherBz, encryptionNonce);\n\n              case 51:\n                errorPlainBz = _context7.sent;\n                _context7.t7.message = _context7.t7.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n                _context7.next = 58;\n                break;\n\n              case 55:\n                _context7.prev = 55;\n                _context7.t8 = _context7[\"catch\"](42);\n                throw new Error(\"Failed to decrypt the following error message: \".concat(_context7.t7.message, \". Decryption error of the error message: \").concat(_context7.t8.message));\n\n              case 58:\n                throw _context7.t7;\n\n              case 59:\n                data = Uint8Array.from([]);\n\n                if (!(this.restClient.broadcastMode == restclient_1.BroadcastMode.Block)) {\n                  _context7.next = 66;\n                  break;\n                }\n\n                dataFields = ProtoEncoding_1.decodeTxData(encoding_1.Encoding.fromHex(result.data));\n\n                if (!dataFields[0].data) {\n                  _context7.next = 66;\n                  break;\n                }\n\n                _context7.next = 65;\n                return this.restClient.decryptDataField(encoding_1.Encoding.toHex(encoding_1.Encoding.fromBase64(dataFields[0].data)), [encryptionNonce]);\n\n              case 65:\n                data = _context7.sent;\n\n              case 66:\n                if (!(this.restClient.broadcastMode == restclient_1.BroadcastMode.Block)) {\n                  _context7.next = 72;\n                  break;\n                }\n\n                _context7.next = 69;\n                return this.restClient.decryptLogs(result.logs, [encryptionNonce]);\n\n              case 69:\n                _context7.t9 = _context7.sent;\n                _context7.next = 73;\n                break;\n\n              case 72:\n                _context7.t9 = [];\n\n              case 73:\n                logs = _context7.t9;\n                return _context7.abrupt(\"return\", {\n                  logs: logs,\n                  transactionHash: result.transactionHash,\n                  // @ts-ignore\n                  data: data\n                });\n\n              case 75:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[34, 40], [42, 55]]);\n      }));\n\n      function execute(_x14, _x15) {\n        return _execute.apply(this, arguments);\n      }\n\n      return execute;\n    }()\n  }, {\n    key: \"sendTokens\",\n    value: function () {\n      var _sendTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(recipientAddress, transferAmount) {\n        var memo,\n            fee,\n            sendMsg,\n            _yield$this$getNonce5,\n            accountNumber,\n            sequence,\n            chainId,\n            signedTx,\n            _args8 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                memo = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : \"\";\n                fee = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : this.fees.send;\n                sendMsg = {\n                  type: \"cosmos-sdk/MsgSend\",\n                  value: {\n                    // eslint-disable-next-line @typescript-eslint/camelcase\n                    from_address: this.senderAddress,\n                    // eslint-disable-next-line @typescript-eslint/camelcase\n                    to_address: recipientAddress,\n                    amount: transferAmount\n                  }\n                };\n\n                if (!memo) {\n                  memo = \"\";\n                }\n\n                _context8.next = 6;\n                return this.getNonce();\n\n              case 6:\n                _yield$this$getNonce5 = _context8.sent;\n                accountNumber = _yield$this$getNonce5.accountNumber;\n                sequence = _yield$this$getNonce5.sequence;\n                _context8.next = 11;\n                return this.getChainId();\n\n              case 11:\n                chainId = _context8.sent;\n                _context8.next = 14;\n                return this.signAdapter([sendMsg], fee, chainId, memo, accountNumber, sequence);\n\n              case 14:\n                signedTx = _context8.sent;\n                return _context8.abrupt(\"return\", this.postTx(signedTx));\n\n              case 16:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function sendTokens(_x16, _x17) {\n        return _sendTokens.apply(this, arguments);\n      }\n\n      return sendTokens;\n    }()\n  }]);\n\n  return SigningCosmWasmClient;\n}(cosmwasmclient_1.CosmWasmClient);\n\nexports.SigningCosmWasmClient = SigningCosmWasmClient;","map":null,"metadata":{},"sourceType":"script"}