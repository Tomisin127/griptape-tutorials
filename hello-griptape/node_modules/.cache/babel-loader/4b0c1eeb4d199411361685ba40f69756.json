{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _buffer = require(\"buffer\");\n\nvar _permute = _interopRequireDefault(require(\"./permute\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar xorWords = function xorWords(I, O) {\n  for (var i = 0; i < I.length; i += 8) {\n    var o = i / 4;\n    O[o] ^= I[i + 7] << 24 | I[i + 6] << 16 | I[i + 5] << 8 | I[i + 4];\n    O[o + 1] ^= I[i + 3] << 24 | I[i + 2] << 16 | I[i + 1] << 8 | I[i];\n  }\n\n  return O;\n};\n\nvar readWords = function readWords(I, O) {\n  for (var o = 0; o < O.length; o += 8) {\n    var i = o / 4;\n    O[o] = I[i + 1];\n    O[o + 1] = I[i + 1] >>> 8;\n    O[o + 2] = I[i + 1] >>> 16;\n    O[o + 3] = I[i + 1] >>> 24;\n    O[o + 4] = I[i];\n    O[o + 5] = I[i] >>> 8;\n    O[o + 6] = I[i] >>> 16;\n    O[o + 7] = I[i] >>> 24;\n  }\n\n  return O;\n};\n\nvar Sponge = function Sponge(_ref) {\n  var _this = this;\n\n  var capacity = _ref.capacity,\n      padding = _ref.padding;\n  var keccak = (0, _permute[\"default\"])();\n  var stateSize = 200;\n  var blockSize = capacity / 8;\n  var queueSize = stateSize - capacity / 4;\n  var queueOffset = 0;\n  var state = new Uint32Array(stateSize / 4);\n\n  var queue = _buffer.Buffer.allocUnsafe(queueSize);\n\n  this.absorb = function (buffer) {\n    for (var i = 0; i < buffer.length; i++) {\n      queue[queueOffset] = buffer[i];\n      queueOffset += 1;\n\n      if (queueOffset >= queueSize) {\n        xorWords(queue, state);\n        keccak(state);\n        queueOffset = 0;\n      }\n    }\n\n    return _this;\n  };\n\n  this.squeeze = function () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var output = {\n      buffer: options.buffer || _buffer.Buffer.allocUnsafe(blockSize),\n      padding: options.padding || padding,\n      queue: _buffer.Buffer.allocUnsafe(queue.length),\n      state: new Uint32Array(state.length)\n    };\n    queue.copy(output.queue);\n\n    for (var i = 0; i < state.length; i++) {\n      output.state[i] = state[i];\n    }\n\n    output.queue.fill(0, queueOffset);\n    output.queue[queueOffset] |= output.padding;\n    output.queue[queueSize - 1] |= 128;\n    xorWords(output.queue, output.state);\n\n    for (var offset = 0; offset < output.buffer.length; offset += queueSize) {\n      keccak(output.state);\n      readWords(output.state, output.buffer.slice(offset, offset + queueSize));\n    }\n\n    return output.buffer;\n  };\n\n  this.reset = function () {\n    queue.fill(0);\n    state.fill(0);\n    queueOffset = 0;\n    return _this;\n  };\n\n  return this;\n};\n\nvar _default = Sponge;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}