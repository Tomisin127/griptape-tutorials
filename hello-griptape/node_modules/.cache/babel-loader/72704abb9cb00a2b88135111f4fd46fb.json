{"ast":null,"code":"\"use strict\";\n/** Type which represents AES blocks */\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constant_time_1 = require(\"./constant-time\");\n\nvar wipe_1 = require(\"./wipe\");\n/** An AES block (128-bits) */\n\n\nvar Block = /*#__PURE__*/function () {\n  function Block() {\n    _classCallCheck(this, Block);\n\n    this.data = new Uint8Array(Block.SIZE);\n  }\n  /**\n   * Clear the given array by setting its values to zero.\n   *\n   * WARNING: The fact that it sets bytes to zero can be relied on.\n   *\n   * There is no guarantee that this function makes data disappear from memory,\n   * as runtime implementation can, for example, have copying garbage collector\n   * that will make copies of sensitive data before we wipe it. Or that an\n   * operating system will write our data to swap or sleep image. Another thing\n   * is that an optimizing compiler can remove calls to this function or make it\n   * no-op. There's nothing we can do with it, so we just do our best and hope\n   * that everything will be okay and good will triumph over evil.\n   */\n\n\n  _createClass(Block, [{\n    key: \"clear\",\n    value: function clear() {\n      wipe_1.wipe(this.data);\n    }\n    /**\n     * Make a copy of this block, returning a new block\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var ret = new Block();\n      ret.copy(this);\n      return ret;\n    }\n    /** Copy the contents of another block into this one */\n\n  }, {\n    key: \"copy\",\n    value: function copy(other) {\n      this.data.set(other.data);\n    }\n    /**\n     * Double a value over GF(2^128):\n     *\n     *     a<<1 if firstbit(a)=0\n     *     (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n     */\n\n  }, {\n    key: \"dbl\",\n    value: function dbl() {\n      var carry = 0;\n\n      for (var i = Block.SIZE - 1; i >= 0; i--) {\n        var b = this.data[i] >>> 7 & 0xff;\n        this.data[i] = this.data[i] << 1 | carry;\n        carry = b;\n      }\n\n      this.data[Block.SIZE - 1] ^= constant_time_1.select(carry, Block.R, 0);\n      carry = 0;\n    }\n  }]);\n\n  return Block;\n}();\n/** Size of a block as used by the AES cipher */\n\n\nBlock.SIZE = 16;\n/** Minimal irreducible polynomial for a 128-bit block size */\n\nBlock.R = 0x87;\nexports.default = Block;","map":null,"metadata":{},"sourceType":"script"}