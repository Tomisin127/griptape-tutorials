{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Propietario\\\\hello-griptape-react\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Propietario\\\\hello-griptape-react\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar base64js = __importStar(require(\"base64-js\"));\n\nvar readonly_date_1 = require(\"readonly-date\");\n\nvar Encoding = /*#__PURE__*/function () {\n  function Encoding() {\n    _classCallCheck(this, Encoding);\n  }\n\n  _createClass(Encoding, null, [{\n    key: \"toHex\",\n    value: function toHex(data) {\n      var out = \"\";\n\n      var _iterator = _createForOfIteratorHelper(data),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var byte = _step.value;\n          out += (\"0\" + byte.toString(16)).slice(-2);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return out;\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hexstring) {\n      if (hexstring.length % 2 !== 0) {\n        throw new Error(\"hex string length must be a multiple of 2\");\n      } // tslint:disable-next-line:readonly-array\n\n\n      var listOfInts = [];\n\n      for (var i = 0; i < hexstring.length; i += 2) {\n        var hexByteAsString = hexstring.substr(i, 2);\n\n        if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {\n          throw new Error(\"hex string contains invalid characters\");\n        }\n\n        listOfInts.push(parseInt(hexByteAsString, 16));\n      }\n\n      return new Uint8Array(listOfInts);\n    }\n  }, {\n    key: \"toBase64\",\n    value: function toBase64(data) {\n      return base64js.fromByteArray(data);\n    }\n  }, {\n    key: \"fromBase64\",\n    value: function fromBase64(base64String) {\n      if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {\n        throw new Error(\"Invalid base64 string format\");\n      }\n\n      return base64js.toByteArray(base64String);\n    }\n  }, {\n    key: \"toAscii\",\n    value: function toAscii(input) {\n      var toNums = function toNums(str) {\n        return str.split(\"\").map(function (x) {\n          var charCode = x.charCodeAt(0); // 0x00–0x1F control characters\n          // 0x20–0x7E printable characters\n          // 0x7F delete character\n          // 0x80–0xFF out of 7 bit ascii range\n\n          if (charCode < 0x20 || charCode > 0x7e) {\n            throw new Error(\"Cannot encode character that is out of printable ASCII range: \" + charCode);\n          }\n\n          return charCode;\n        });\n      };\n\n      return Uint8Array.from(toNums(input));\n    }\n  }, {\n    key: \"fromAscii\",\n    value: function fromAscii(data) {\n      var fromNums = function fromNums(listOfNumbers) {\n        return listOfNumbers.map(function (x) {\n          // 0x00–0x1F control characters\n          // 0x20–0x7E printable characters\n          // 0x7F delete character\n          // 0x80–0xFF out of 7 bit ascii range\n          if (x < 0x20 || x > 0x7e) {\n            throw new Error(\"Cannot decode character that is out of printable ASCII range: \" + x);\n          }\n\n          return String.fromCharCode(x);\n        });\n      };\n\n      return fromNums(Array.from(data)).join(\"\");\n    }\n  }, {\n    key: \"toUtf8\",\n    value: function toUtf8(str) {\n      // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n      if (typeof TextEncoder !== \"undefined\") {\n        return new TextEncoder().encode(str);\n      } // Use Buffer hack instead of nodejs util.TextEncoder to ensure\n      // webpack does not bundle the util module for browsers.\n\n\n      return new Uint8Array(Buffer.from(str, \"utf8\"));\n    }\n  }, {\n    key: \"fromUtf8\",\n    value: function fromUtf8(data) {\n      // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n      if (typeof TextDecoder !== \"undefined\") {\n        return new TextDecoder(\"utf-8\", {\n          fatal: true\n        }).decode(data);\n      } // Use Buffer hack instead of nodejs util.TextDecoder to ensure\n      // webpack does not bundle the util module for browsers.\n      // Buffer.toString has no fatal option\n\n\n      if (!Encoding.isValidUtf8(data)) {\n        throw new Error(\"Invalid UTF8 data\");\n      }\n\n      return Buffer.from(data).toString(\"utf8\");\n    }\n  }, {\n    key: \"fromRfc3339\",\n    value: function fromRfc3339(str) {\n      var rfc3339Matcher = /^(\\d{4})-(\\d{2})-(\\d{2})[T ](\\d{2}):(\\d{2}):(\\d{2})(\\.\\d{1,9})?((?:[+-]\\d{2}:\\d{2})|Z)$/;\n      var matches = rfc3339Matcher.exec(str);\n\n      if (!matches) {\n        throw new Error(\"Date string is not in RFC3339 format\");\n      }\n\n      var year = +matches[1];\n      var month = +matches[2];\n      var day = +matches[3];\n      var hour = +matches[4];\n      var minute = +matches[5];\n      var second = +matches[6]; // fractional seconds match either undefined or a string like \".1\", \".123456789\"\n\n      var milliSeconds = matches[7] ? Math.floor(+matches[7] * 1000) : 0;\n      var tzOffsetSign;\n      var tzOffsetHours;\n      var tzOffsetMinutes; // if timezone is undefined, it must be Z or nothing (otherwise the group would have captured).\n\n      if (matches[8] === \"Z\") {\n        tzOffsetSign = 1;\n        tzOffsetHours = 0;\n        tzOffsetMinutes = 0;\n      } else {\n        tzOffsetSign = matches[8].substring(0, 1) === \"-\" ? -1 : 1;\n        tzOffsetHours = +matches[8].substring(1, 3);\n        tzOffsetMinutes = +matches[8].substring(4, 6);\n      }\n\n      var tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60; // seconds\n\n      return new readonly_date_1.ReadonlyDate(readonly_date_1.ReadonlyDate.UTC(year, month - 1, day, hour, minute, second, milliSeconds) - tzOffset * 1000);\n    }\n  }, {\n    key: \"toRfc3339\",\n    value: function toRfc3339(date) {\n      function padded(integer) {\n        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n        var filled = \"00000\" + integer.toString();\n        return filled.substring(filled.length - length);\n      }\n\n      var year = date.getUTCFullYear();\n      var month = padded(date.getUTCMonth() + 1);\n      var day = padded(date.getUTCDate());\n      var hour = padded(date.getUTCHours());\n      var minute = padded(date.getUTCMinutes());\n      var second = padded(date.getUTCSeconds());\n      var ms = padded(date.getUTCMilliseconds(), 3);\n      return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second, \".\").concat(ms, \"Z\");\n    }\n  }, {\n    key: \"isValidUtf8\",\n    value: function isValidUtf8(data) {\n      var toStringAndBack = Buffer.from(Buffer.from(data).toString(\"utf8\"), \"utf8\");\n      return Buffer.compare(Buffer.from(data), toStringAndBack) === 0;\n    }\n  }]);\n\n  return Encoding;\n}();\n\nexports.Encoding = Encoding;","map":null,"metadata":{},"sourceType":"script"}