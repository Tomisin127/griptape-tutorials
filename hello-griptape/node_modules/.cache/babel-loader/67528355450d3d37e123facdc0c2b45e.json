{"ast":null,"code":"/* \nGenerated by:\nnpx pbjs -t static-module  ../../../third_party/proto/tendermint/abci/types.proto ../../../third_party/proto/cosmos/base/abci/v1beta1/abci.proto ../../../third_party/proto/gogoproto/gogo.proto /home/assafmo/workspace/SecretNetwork/third_party/proto/google/protobuf/any.proto /home/assafmo/workspace/SecretNetwork/third_party/proto/google/protobuf/timestamp.proto ../../../third_party/proto/tendermint/types/* ../../../third_party/proto/tendermint/crypto/* ../../../third_party/proto/tendermint/version/* > src/ProtoDefs.js\n*/\n\n/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n(function (global, factory) {\n  /* global define, require, module */\n\n  /* AMD */\n  if (typeof define === \"function\" && define.amd) define([\"protobufjs/minimal\"], factory);\n  /* CommonJS */\n  else if (typeof require === \"function\" && typeof module === \"object\" && module && module.exports) module.exports = factory(require(\"protobufjs/minimal\"));\n})(this, function ($protobuf) {\n  \"use strict\"; // Common aliases\n\n  var $Reader = $protobuf.Reader,\n      $Writer = $protobuf.Writer,\n      $util = $protobuf.util; // Exported root namespace\n\n  var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n  $root.tendermint = function () {\n    /**\n     * Namespace tendermint.\n     * @exports tendermint\n     * @namespace\n     */\n    var tendermint = {};\n\n    tendermint.abci = function () {\n      /**\n       * Namespace abci.\n       * @memberof tendermint\n       * @namespace\n       */\n      var abci = {};\n\n      abci.Request = function () {\n        /**\n         * Properties of a Request.\n         * @memberof tendermint.abci\n         * @interface IRequest\n         * @property {tendermint.abci.IRequestEcho|null} [echo] Request echo\n         * @property {tendermint.abci.IRequestFlush|null} [flush] Request flush\n         * @property {tendermint.abci.IRequestInfo|null} [info] Request info\n         * @property {tendermint.abci.IRequestSetOption|null} [setOption] Request setOption\n         * @property {tendermint.abci.IRequestInitChain|null} [initChain] Request initChain\n         * @property {tendermint.abci.IRequestQuery|null} [query] Request query\n         * @property {tendermint.abci.IRequestBeginBlock|null} [beginBlock] Request beginBlock\n         * @property {tendermint.abci.IRequestCheckTx|null} [checkTx] Request checkTx\n         * @property {tendermint.abci.IRequestDeliverTx|null} [deliverTx] Request deliverTx\n         * @property {tendermint.abci.IRequestEndBlock|null} [endBlock] Request endBlock\n         * @property {tendermint.abci.IRequestCommit|null} [commit] Request commit\n         * @property {tendermint.abci.IRequestListSnapshots|null} [listSnapshots] Request listSnapshots\n         * @property {tendermint.abci.IRequestOfferSnapshot|null} [offerSnapshot] Request offerSnapshot\n         * @property {tendermint.abci.IRequestLoadSnapshotChunk|null} [loadSnapshotChunk] Request loadSnapshotChunk\n         * @property {tendermint.abci.IRequestApplySnapshotChunk|null} [applySnapshotChunk] Request applySnapshotChunk\n         */\n\n        /**\n         * Constructs a new Request.\n         * @memberof tendermint.abci\n         * @classdesc Represents a Request.\n         * @implements IRequest\n         * @constructor\n         * @param {tendermint.abci.IRequest=} [properties] Properties to set\n         */\n        function Request(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Request echo.\n         * @member {tendermint.abci.IRequestEcho|null|undefined} echo\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n\n        Request.prototype.echo = null;\n        /**\n         * Request flush.\n         * @member {tendermint.abci.IRequestFlush|null|undefined} flush\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.flush = null;\n        /**\n         * Request info.\n         * @member {tendermint.abci.IRequestInfo|null|undefined} info\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.info = null;\n        /**\n         * Request setOption.\n         * @member {tendermint.abci.IRequestSetOption|null|undefined} setOption\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.setOption = null;\n        /**\n         * Request initChain.\n         * @member {tendermint.abci.IRequestInitChain|null|undefined} initChain\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.initChain = null;\n        /**\n         * Request query.\n         * @member {tendermint.abci.IRequestQuery|null|undefined} query\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.query = null;\n        /**\n         * Request beginBlock.\n         * @member {tendermint.abci.IRequestBeginBlock|null|undefined} beginBlock\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.beginBlock = null;\n        /**\n         * Request checkTx.\n         * @member {tendermint.abci.IRequestCheckTx|null|undefined} checkTx\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.checkTx = null;\n        /**\n         * Request deliverTx.\n         * @member {tendermint.abci.IRequestDeliverTx|null|undefined} deliverTx\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.deliverTx = null;\n        /**\n         * Request endBlock.\n         * @member {tendermint.abci.IRequestEndBlock|null|undefined} endBlock\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.endBlock = null;\n        /**\n         * Request commit.\n         * @member {tendermint.abci.IRequestCommit|null|undefined} commit\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.commit = null;\n        /**\n         * Request listSnapshots.\n         * @member {tendermint.abci.IRequestListSnapshots|null|undefined} listSnapshots\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.listSnapshots = null;\n        /**\n         * Request offerSnapshot.\n         * @member {tendermint.abci.IRequestOfferSnapshot|null|undefined} offerSnapshot\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.offerSnapshot = null;\n        /**\n         * Request loadSnapshotChunk.\n         * @member {tendermint.abci.IRequestLoadSnapshotChunk|null|undefined} loadSnapshotChunk\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.loadSnapshotChunk = null;\n        /**\n         * Request applySnapshotChunk.\n         * @member {tendermint.abci.IRequestApplySnapshotChunk|null|undefined} applySnapshotChunk\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Request.prototype.applySnapshotChunk = null; // OneOf field names bound to virtual getters and setters\n\n        var $oneOfFields;\n        /**\n         * Request value.\n         * @member {\"echo\"|\"flush\"|\"info\"|\"setOption\"|\"initChain\"|\"query\"|\"beginBlock\"|\"checkTx\"|\"deliverTx\"|\"endBlock\"|\"commit\"|\"listSnapshots\"|\"offerSnapshot\"|\"loadSnapshotChunk\"|\"applySnapshotChunk\"|undefined} value\n         * @memberof tendermint.abci.Request\n         * @instance\n         */\n\n        Object.defineProperty(Request.prototype, \"value\", {\n          get: $util.oneOfGetter($oneOfFields = [\"echo\", \"flush\", \"info\", \"setOption\", \"initChain\", \"query\", \"beginBlock\", \"checkTx\", \"deliverTx\", \"endBlock\", \"commit\", \"listSnapshots\", \"offerSnapshot\", \"loadSnapshotChunk\", \"applySnapshotChunk\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        /**\n         * Creates a new Request instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.Request\n         * @static\n         * @param {tendermint.abci.IRequest=} [properties] Properties to set\n         * @returns {tendermint.abci.Request} Request instance\n         */\n\n        Request.create = function create(properties) {\n          return new Request(properties);\n        };\n        /**\n         * Encodes the specified Request message. Does not implicitly {@link tendermint.abci.Request.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.Request\n         * @static\n         * @param {tendermint.abci.IRequest} message Request message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Request.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.echo != null && Object.hasOwnProperty.call(message, \"echo\")) $root.tendermint.abci.RequestEcho.encode(message.echo, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.flush != null && Object.hasOwnProperty.call(message, \"flush\")) $root.tendermint.abci.RequestFlush.encode(message.flush, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          if (message.info != null && Object.hasOwnProperty.call(message, \"info\")) $root.tendermint.abci.RequestInfo.encode(message.info, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          if (message.setOption != null && Object.hasOwnProperty.call(message, \"setOption\")) $root.tendermint.abci.RequestSetOption.encode(message.setOption, writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).fork()).ldelim();\n          if (message.initChain != null && Object.hasOwnProperty.call(message, \"initChain\")) $root.tendermint.abci.RequestInitChain.encode(message.initChain, writer.uint32(\n          /* id 5, wireType 2 =*/\n          42).fork()).ldelim();\n          if (message.query != null && Object.hasOwnProperty.call(message, \"query\")) $root.tendermint.abci.RequestQuery.encode(message.query, writer.uint32(\n          /* id 6, wireType 2 =*/\n          50).fork()).ldelim();\n          if (message.beginBlock != null && Object.hasOwnProperty.call(message, \"beginBlock\")) $root.tendermint.abci.RequestBeginBlock.encode(message.beginBlock, writer.uint32(\n          /* id 7, wireType 2 =*/\n          58).fork()).ldelim();\n          if (message.checkTx != null && Object.hasOwnProperty.call(message, \"checkTx\")) $root.tendermint.abci.RequestCheckTx.encode(message.checkTx, writer.uint32(\n          /* id 8, wireType 2 =*/\n          66).fork()).ldelim();\n          if (message.deliverTx != null && Object.hasOwnProperty.call(message, \"deliverTx\")) $root.tendermint.abci.RequestDeliverTx.encode(message.deliverTx, writer.uint32(\n          /* id 9, wireType 2 =*/\n          74).fork()).ldelim();\n          if (message.endBlock != null && Object.hasOwnProperty.call(message, \"endBlock\")) $root.tendermint.abci.RequestEndBlock.encode(message.endBlock, writer.uint32(\n          /* id 10, wireType 2 =*/\n          82).fork()).ldelim();\n          if (message.commit != null && Object.hasOwnProperty.call(message, \"commit\")) $root.tendermint.abci.RequestCommit.encode(message.commit, writer.uint32(\n          /* id 11, wireType 2 =*/\n          90).fork()).ldelim();\n          if (message.listSnapshots != null && Object.hasOwnProperty.call(message, \"listSnapshots\")) $root.tendermint.abci.RequestListSnapshots.encode(message.listSnapshots, writer.uint32(\n          /* id 12, wireType 2 =*/\n          98).fork()).ldelim();\n          if (message.offerSnapshot != null && Object.hasOwnProperty.call(message, \"offerSnapshot\")) $root.tendermint.abci.RequestOfferSnapshot.encode(message.offerSnapshot, writer.uint32(\n          /* id 13, wireType 2 =*/\n          106).fork()).ldelim();\n          if (message.loadSnapshotChunk != null && Object.hasOwnProperty.call(message, \"loadSnapshotChunk\")) $root.tendermint.abci.RequestLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(\n          /* id 14, wireType 2 =*/\n          114).fork()).ldelim();\n          if (message.applySnapshotChunk != null && Object.hasOwnProperty.call(message, \"applySnapshotChunk\")) $root.tendermint.abci.RequestApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(\n          /* id 15, wireType 2 =*/\n          122).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified Request message, length delimited. Does not implicitly {@link tendermint.abci.Request.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.Request\n         * @static\n         * @param {tendermint.abci.IRequest} message Request message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Request.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Request message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.Request\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.Request} Request\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Request.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.Request();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.echo = $root.tendermint.abci.RequestEcho.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.flush = $root.tendermint.abci.RequestFlush.decode(reader, reader.uint32());\n                break;\n\n              case 3:\n                message.info = $root.tendermint.abci.RequestInfo.decode(reader, reader.uint32());\n                break;\n\n              case 4:\n                message.setOption = $root.tendermint.abci.RequestSetOption.decode(reader, reader.uint32());\n                break;\n\n              case 5:\n                message.initChain = $root.tendermint.abci.RequestInitChain.decode(reader, reader.uint32());\n                break;\n\n              case 6:\n                message.query = $root.tendermint.abci.RequestQuery.decode(reader, reader.uint32());\n                break;\n\n              case 7:\n                message.beginBlock = $root.tendermint.abci.RequestBeginBlock.decode(reader, reader.uint32());\n                break;\n\n              case 8:\n                message.checkTx = $root.tendermint.abci.RequestCheckTx.decode(reader, reader.uint32());\n                break;\n\n              case 9:\n                message.deliverTx = $root.tendermint.abci.RequestDeliverTx.decode(reader, reader.uint32());\n                break;\n\n              case 10:\n                message.endBlock = $root.tendermint.abci.RequestEndBlock.decode(reader, reader.uint32());\n                break;\n\n              case 11:\n                message.commit = $root.tendermint.abci.RequestCommit.decode(reader, reader.uint32());\n                break;\n\n              case 12:\n                message.listSnapshots = $root.tendermint.abci.RequestListSnapshots.decode(reader, reader.uint32());\n                break;\n\n              case 13:\n                message.offerSnapshot = $root.tendermint.abci.RequestOfferSnapshot.decode(reader, reader.uint32());\n                break;\n\n              case 14:\n                message.loadSnapshotChunk = $root.tendermint.abci.RequestLoadSnapshotChunk.decode(reader, reader.uint32());\n                break;\n\n              case 15:\n                message.applySnapshotChunk = $root.tendermint.abci.RequestApplySnapshotChunk.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Request message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.Request\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.Request} Request\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Request.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Request message.\n         * @function verify\n         * @memberof tendermint.abci.Request\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Request.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          var properties = {};\n\n          if (message.echo != null && message.hasOwnProperty(\"echo\")) {\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestEcho.verify(message.echo);\n              if (error) return \"echo.\" + error;\n            }\n          }\n\n          if (message.flush != null && message.hasOwnProperty(\"flush\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestFlush.verify(message.flush);\n              if (error) return \"flush.\" + error;\n            }\n          }\n\n          if (message.info != null && message.hasOwnProperty(\"info\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestInfo.verify(message.info);\n              if (error) return \"info.\" + error;\n            }\n          }\n\n          if (message.setOption != null && message.hasOwnProperty(\"setOption\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestSetOption.verify(message.setOption);\n              if (error) return \"setOption.\" + error;\n            }\n          }\n\n          if (message.initChain != null && message.hasOwnProperty(\"initChain\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestInitChain.verify(message.initChain);\n              if (error) return \"initChain.\" + error;\n            }\n          }\n\n          if (message.query != null && message.hasOwnProperty(\"query\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestQuery.verify(message.query);\n              if (error) return \"query.\" + error;\n            }\n          }\n\n          if (message.beginBlock != null && message.hasOwnProperty(\"beginBlock\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestBeginBlock.verify(message.beginBlock);\n              if (error) return \"beginBlock.\" + error;\n            }\n          }\n\n          if (message.checkTx != null && message.hasOwnProperty(\"checkTx\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestCheckTx.verify(message.checkTx);\n              if (error) return \"checkTx.\" + error;\n            }\n          }\n\n          if (message.deliverTx != null && message.hasOwnProperty(\"deliverTx\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestDeliverTx.verify(message.deliverTx);\n              if (error) return \"deliverTx.\" + error;\n            }\n          }\n\n          if (message.endBlock != null && message.hasOwnProperty(\"endBlock\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestEndBlock.verify(message.endBlock);\n              if (error) return \"endBlock.\" + error;\n            }\n          }\n\n          if (message.commit != null && message.hasOwnProperty(\"commit\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestCommit.verify(message.commit);\n              if (error) return \"commit.\" + error;\n            }\n          }\n\n          if (message.listSnapshots != null && message.hasOwnProperty(\"listSnapshots\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestListSnapshots.verify(message.listSnapshots);\n              if (error) return \"listSnapshots.\" + error;\n            }\n          }\n\n          if (message.offerSnapshot != null && message.hasOwnProperty(\"offerSnapshot\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestOfferSnapshot.verify(message.offerSnapshot);\n              if (error) return \"offerSnapshot.\" + error;\n            }\n          }\n\n          if (message.loadSnapshotChunk != null && message.hasOwnProperty(\"loadSnapshotChunk\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestLoadSnapshotChunk.verify(message.loadSnapshotChunk);\n              if (error) return \"loadSnapshotChunk.\" + error;\n            }\n          }\n\n          if (message.applySnapshotChunk != null && message.hasOwnProperty(\"applySnapshotChunk\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.RequestApplySnapshotChunk.verify(message.applySnapshotChunk);\n              if (error) return \"applySnapshotChunk.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a Request message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.Request\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.Request} Request\n         */\n\n\n        Request.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.Request) return object;\n          var message = new $root.tendermint.abci.Request();\n\n          if (object.echo != null) {\n            if (typeof object.echo !== \"object\") throw TypeError(\".tendermint.abci.Request.echo: object expected\");\n            message.echo = $root.tendermint.abci.RequestEcho.fromObject(object.echo);\n          }\n\n          if (object.flush != null) {\n            if (typeof object.flush !== \"object\") throw TypeError(\".tendermint.abci.Request.flush: object expected\");\n            message.flush = $root.tendermint.abci.RequestFlush.fromObject(object.flush);\n          }\n\n          if (object.info != null) {\n            if (typeof object.info !== \"object\") throw TypeError(\".tendermint.abci.Request.info: object expected\");\n            message.info = $root.tendermint.abci.RequestInfo.fromObject(object.info);\n          }\n\n          if (object.setOption != null) {\n            if (typeof object.setOption !== \"object\") throw TypeError(\".tendermint.abci.Request.setOption: object expected\");\n            message.setOption = $root.tendermint.abci.RequestSetOption.fromObject(object.setOption);\n          }\n\n          if (object.initChain != null) {\n            if (typeof object.initChain !== \"object\") throw TypeError(\".tendermint.abci.Request.initChain: object expected\");\n            message.initChain = $root.tendermint.abci.RequestInitChain.fromObject(object.initChain);\n          }\n\n          if (object.query != null) {\n            if (typeof object.query !== \"object\") throw TypeError(\".tendermint.abci.Request.query: object expected\");\n            message.query = $root.tendermint.abci.RequestQuery.fromObject(object.query);\n          }\n\n          if (object.beginBlock != null) {\n            if (typeof object.beginBlock !== \"object\") throw TypeError(\".tendermint.abci.Request.beginBlock: object expected\");\n            message.beginBlock = $root.tendermint.abci.RequestBeginBlock.fromObject(object.beginBlock);\n          }\n\n          if (object.checkTx != null) {\n            if (typeof object.checkTx !== \"object\") throw TypeError(\".tendermint.abci.Request.checkTx: object expected\");\n            message.checkTx = $root.tendermint.abci.RequestCheckTx.fromObject(object.checkTx);\n          }\n\n          if (object.deliverTx != null) {\n            if (typeof object.deliverTx !== \"object\") throw TypeError(\".tendermint.abci.Request.deliverTx: object expected\");\n            message.deliverTx = $root.tendermint.abci.RequestDeliverTx.fromObject(object.deliverTx);\n          }\n\n          if (object.endBlock != null) {\n            if (typeof object.endBlock !== \"object\") throw TypeError(\".tendermint.abci.Request.endBlock: object expected\");\n            message.endBlock = $root.tendermint.abci.RequestEndBlock.fromObject(object.endBlock);\n          }\n\n          if (object.commit != null) {\n            if (typeof object.commit !== \"object\") throw TypeError(\".tendermint.abci.Request.commit: object expected\");\n            message.commit = $root.tendermint.abci.RequestCommit.fromObject(object.commit);\n          }\n\n          if (object.listSnapshots != null) {\n            if (typeof object.listSnapshots !== \"object\") throw TypeError(\".tendermint.abci.Request.listSnapshots: object expected\");\n            message.listSnapshots = $root.tendermint.abci.RequestListSnapshots.fromObject(object.listSnapshots);\n          }\n\n          if (object.offerSnapshot != null) {\n            if (typeof object.offerSnapshot !== \"object\") throw TypeError(\".tendermint.abci.Request.offerSnapshot: object expected\");\n            message.offerSnapshot = $root.tendermint.abci.RequestOfferSnapshot.fromObject(object.offerSnapshot);\n          }\n\n          if (object.loadSnapshotChunk != null) {\n            if (typeof object.loadSnapshotChunk !== \"object\") throw TypeError(\".tendermint.abci.Request.loadSnapshotChunk: object expected\");\n            message.loadSnapshotChunk = $root.tendermint.abci.RequestLoadSnapshotChunk.fromObject(object.loadSnapshotChunk);\n          }\n\n          if (object.applySnapshotChunk != null) {\n            if (typeof object.applySnapshotChunk !== \"object\") throw TypeError(\".tendermint.abci.Request.applySnapshotChunk: object expected\");\n            message.applySnapshotChunk = $root.tendermint.abci.RequestApplySnapshotChunk.fromObject(object.applySnapshotChunk);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a Request message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.Request\n         * @static\n         * @param {tendermint.abci.Request} message Request\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Request.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (message.echo != null && message.hasOwnProperty(\"echo\")) {\n            object.echo = $root.tendermint.abci.RequestEcho.toObject(message.echo, options);\n            if (options.oneofs) object.value = \"echo\";\n          }\n\n          if (message.flush != null && message.hasOwnProperty(\"flush\")) {\n            object.flush = $root.tendermint.abci.RequestFlush.toObject(message.flush, options);\n            if (options.oneofs) object.value = \"flush\";\n          }\n\n          if (message.info != null && message.hasOwnProperty(\"info\")) {\n            object.info = $root.tendermint.abci.RequestInfo.toObject(message.info, options);\n            if (options.oneofs) object.value = \"info\";\n          }\n\n          if (message.setOption != null && message.hasOwnProperty(\"setOption\")) {\n            object.setOption = $root.tendermint.abci.RequestSetOption.toObject(message.setOption, options);\n            if (options.oneofs) object.value = \"setOption\";\n          }\n\n          if (message.initChain != null && message.hasOwnProperty(\"initChain\")) {\n            object.initChain = $root.tendermint.abci.RequestInitChain.toObject(message.initChain, options);\n            if (options.oneofs) object.value = \"initChain\";\n          }\n\n          if (message.query != null && message.hasOwnProperty(\"query\")) {\n            object.query = $root.tendermint.abci.RequestQuery.toObject(message.query, options);\n            if (options.oneofs) object.value = \"query\";\n          }\n\n          if (message.beginBlock != null && message.hasOwnProperty(\"beginBlock\")) {\n            object.beginBlock = $root.tendermint.abci.RequestBeginBlock.toObject(message.beginBlock, options);\n            if (options.oneofs) object.value = \"beginBlock\";\n          }\n\n          if (message.checkTx != null && message.hasOwnProperty(\"checkTx\")) {\n            object.checkTx = $root.tendermint.abci.RequestCheckTx.toObject(message.checkTx, options);\n            if (options.oneofs) object.value = \"checkTx\";\n          }\n\n          if (message.deliverTx != null && message.hasOwnProperty(\"deliverTx\")) {\n            object.deliverTx = $root.tendermint.abci.RequestDeliverTx.toObject(message.deliverTx, options);\n            if (options.oneofs) object.value = \"deliverTx\";\n          }\n\n          if (message.endBlock != null && message.hasOwnProperty(\"endBlock\")) {\n            object.endBlock = $root.tendermint.abci.RequestEndBlock.toObject(message.endBlock, options);\n            if (options.oneofs) object.value = \"endBlock\";\n          }\n\n          if (message.commit != null && message.hasOwnProperty(\"commit\")) {\n            object.commit = $root.tendermint.abci.RequestCommit.toObject(message.commit, options);\n            if (options.oneofs) object.value = \"commit\";\n          }\n\n          if (message.listSnapshots != null && message.hasOwnProperty(\"listSnapshots\")) {\n            object.listSnapshots = $root.tendermint.abci.RequestListSnapshots.toObject(message.listSnapshots, options);\n            if (options.oneofs) object.value = \"listSnapshots\";\n          }\n\n          if (message.offerSnapshot != null && message.hasOwnProperty(\"offerSnapshot\")) {\n            object.offerSnapshot = $root.tendermint.abci.RequestOfferSnapshot.toObject(message.offerSnapshot, options);\n            if (options.oneofs) object.value = \"offerSnapshot\";\n          }\n\n          if (message.loadSnapshotChunk != null && message.hasOwnProperty(\"loadSnapshotChunk\")) {\n            object.loadSnapshotChunk = $root.tendermint.abci.RequestLoadSnapshotChunk.toObject(message.loadSnapshotChunk, options);\n            if (options.oneofs) object.value = \"loadSnapshotChunk\";\n          }\n\n          if (message.applySnapshotChunk != null && message.hasOwnProperty(\"applySnapshotChunk\")) {\n            object.applySnapshotChunk = $root.tendermint.abci.RequestApplySnapshotChunk.toObject(message.applySnapshotChunk, options);\n            if (options.oneofs) object.value = \"applySnapshotChunk\";\n          }\n\n          return object;\n        };\n        /**\n         * Converts this Request to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.Request\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Request.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Request;\n      }();\n\n      abci.RequestEcho = function () {\n        /**\n         * Properties of a RequestEcho.\n         * @memberof tendermint.abci\n         * @interface IRequestEcho\n         * @property {string|null} [message] RequestEcho message\n         */\n\n        /**\n         * Constructs a new RequestEcho.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestEcho.\n         * @implements IRequestEcho\n         * @constructor\n         * @param {tendermint.abci.IRequestEcho=} [properties] Properties to set\n         */\n        function RequestEcho(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * RequestEcho message.\n         * @member {string} message\n         * @memberof tendermint.abci.RequestEcho\n         * @instance\n         */\n\n\n        RequestEcho.prototype.message = \"\";\n        /**\n         * Creates a new RequestEcho instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestEcho\n         * @static\n         * @param {tendermint.abci.IRequestEcho=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestEcho} RequestEcho instance\n         */\n\n        RequestEcho.create = function create(properties) {\n          return new RequestEcho(properties);\n        };\n        /**\n         * Encodes the specified RequestEcho message. Does not implicitly {@link tendermint.abci.RequestEcho.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestEcho\n         * @static\n         * @param {tendermint.abci.IRequestEcho} message RequestEcho message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestEcho.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.message != null && Object.hasOwnProperty.call(message, \"message\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.message);\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestEcho message, length delimited. Does not implicitly {@link tendermint.abci.RequestEcho.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestEcho\n         * @static\n         * @param {tendermint.abci.IRequestEcho} message RequestEcho message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestEcho.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestEcho message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestEcho\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestEcho} RequestEcho\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestEcho.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestEcho();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.message = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestEcho message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestEcho\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestEcho} RequestEcho\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestEcho.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestEcho message.\n         * @function verify\n         * @memberof tendermint.abci.RequestEcho\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestEcho.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.message != null && message.hasOwnProperty(\"message\")) if (!$util.isString(message.message)) return \"message: string expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestEcho message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestEcho\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestEcho} RequestEcho\n         */\n\n\n        RequestEcho.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestEcho) return object;\n          var message = new $root.tendermint.abci.RequestEcho();\n          if (object.message != null) message.message = String(object.message);\n          return message;\n        };\n        /**\n         * Creates a plain object from a RequestEcho message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestEcho\n         * @static\n         * @param {tendermint.abci.RequestEcho} message RequestEcho\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestEcho.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.defaults) object.message = \"\";\n          if (message.message != null && message.hasOwnProperty(\"message\")) object.message = message.message;\n          return object;\n        };\n        /**\n         * Converts this RequestEcho to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestEcho\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestEcho.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestEcho;\n      }();\n\n      abci.RequestFlush = function () {\n        /**\n         * Properties of a RequestFlush.\n         * @memberof tendermint.abci\n         * @interface IRequestFlush\n         */\n\n        /**\n         * Constructs a new RequestFlush.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestFlush.\n         * @implements IRequestFlush\n         * @constructor\n         * @param {tendermint.abci.IRequestFlush=} [properties] Properties to set\n         */\n        function RequestFlush(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Creates a new RequestFlush instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestFlush\n         * @static\n         * @param {tendermint.abci.IRequestFlush=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestFlush} RequestFlush instance\n         */\n\n\n        RequestFlush.create = function create(properties) {\n          return new RequestFlush(properties);\n        };\n        /**\n         * Encodes the specified RequestFlush message. Does not implicitly {@link tendermint.abci.RequestFlush.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestFlush\n         * @static\n         * @param {tendermint.abci.IRequestFlush} message RequestFlush message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestFlush.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestFlush message, length delimited. Does not implicitly {@link tendermint.abci.RequestFlush.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestFlush\n         * @static\n         * @param {tendermint.abci.IRequestFlush} message RequestFlush message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestFlush.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestFlush message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestFlush\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestFlush} RequestFlush\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestFlush.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestFlush();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestFlush message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestFlush\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestFlush} RequestFlush\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestFlush.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestFlush message.\n         * @function verify\n         * @memberof tendermint.abci.RequestFlush\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestFlush.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestFlush message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestFlush\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestFlush} RequestFlush\n         */\n\n\n        RequestFlush.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestFlush) return object;\n          return new $root.tendermint.abci.RequestFlush();\n        };\n        /**\n         * Creates a plain object from a RequestFlush message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestFlush\n         * @static\n         * @param {tendermint.abci.RequestFlush} message RequestFlush\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestFlush.toObject = function toObject() {\n          return {};\n        };\n        /**\n         * Converts this RequestFlush to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestFlush\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestFlush.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestFlush;\n      }();\n\n      abci.RequestInfo = function () {\n        /**\n         * Properties of a RequestInfo.\n         * @memberof tendermint.abci\n         * @interface IRequestInfo\n         * @property {string|null} [version] RequestInfo version\n         * @property {number|Long|null} [blockVersion] RequestInfo blockVersion\n         * @property {number|Long|null} [p2pVersion] RequestInfo p2pVersion\n         */\n\n        /**\n         * Constructs a new RequestInfo.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestInfo.\n         * @implements IRequestInfo\n         * @constructor\n         * @param {tendermint.abci.IRequestInfo=} [properties] Properties to set\n         */\n        function RequestInfo(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * RequestInfo version.\n         * @member {string} version\n         * @memberof tendermint.abci.RequestInfo\n         * @instance\n         */\n\n\n        RequestInfo.prototype.version = \"\";\n        /**\n         * RequestInfo blockVersion.\n         * @member {number|Long} blockVersion\n         * @memberof tendermint.abci.RequestInfo\n         * @instance\n         */\n\n        RequestInfo.prototype.blockVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        /**\n         * RequestInfo p2pVersion.\n         * @member {number|Long} p2pVersion\n         * @memberof tendermint.abci.RequestInfo\n         * @instance\n         */\n\n        RequestInfo.prototype.p2pVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        /**\n         * Creates a new RequestInfo instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestInfo\n         * @static\n         * @param {tendermint.abci.IRequestInfo=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestInfo} RequestInfo instance\n         */\n\n        RequestInfo.create = function create(properties) {\n          return new RequestInfo(properties);\n        };\n        /**\n         * Encodes the specified RequestInfo message. Does not implicitly {@link tendermint.abci.RequestInfo.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestInfo\n         * @static\n         * @param {tendermint.abci.IRequestInfo} message RequestInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestInfo.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.version != null && Object.hasOwnProperty.call(message, \"version\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.version);\n          if (message.blockVersion != null && Object.hasOwnProperty.call(message, \"blockVersion\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).uint64(message.blockVersion);\n          if (message.p2pVersion != null && Object.hasOwnProperty.call(message, \"p2pVersion\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).uint64(message.p2pVersion);\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestInfo message, length delimited. Does not implicitly {@link tendermint.abci.RequestInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestInfo\n         * @static\n         * @param {tendermint.abci.IRequestInfo} message RequestInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestInfo.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestInfo} RequestInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestInfo.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestInfo();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.version = reader.string();\n                break;\n\n              case 2:\n                message.blockVersion = reader.uint64();\n                break;\n\n              case 3:\n                message.p2pVersion = reader.uint64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestInfo} RequestInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestInfo.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestInfo message.\n         * @function verify\n         * @memberof tendermint.abci.RequestInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestInfo.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.version != null && message.hasOwnProperty(\"version\")) if (!$util.isString(message.version)) return \"version: string expected\";\n          if (message.blockVersion != null && message.hasOwnProperty(\"blockVersion\")) if (!$util.isInteger(message.blockVersion) && !(message.blockVersion && $util.isInteger(message.blockVersion.low) && $util.isInteger(message.blockVersion.high))) return \"blockVersion: integer|Long expected\";\n          if (message.p2pVersion != null && message.hasOwnProperty(\"p2pVersion\")) if (!$util.isInteger(message.p2pVersion) && !(message.p2pVersion && $util.isInteger(message.p2pVersion.low) && $util.isInteger(message.p2pVersion.high))) return \"p2pVersion: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestInfo} RequestInfo\n         */\n\n\n        RequestInfo.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestInfo) return object;\n          var message = new $root.tendermint.abci.RequestInfo();\n          if (object.version != null) message.version = String(object.version);\n          if (object.blockVersion != null) if ($util.Long) (message.blockVersion = $util.Long.fromValue(object.blockVersion)).unsigned = true;else if (typeof object.blockVersion === \"string\") message.blockVersion = parseInt(object.blockVersion, 10);else if (typeof object.blockVersion === \"number\") message.blockVersion = object.blockVersion;else if (typeof object.blockVersion === \"object\") message.blockVersion = new $util.LongBits(object.blockVersion.low >>> 0, object.blockVersion.high >>> 0).toNumber(true);\n          if (object.p2pVersion != null) if ($util.Long) (message.p2pVersion = $util.Long.fromValue(object.p2pVersion)).unsigned = true;else if (typeof object.p2pVersion === \"string\") message.p2pVersion = parseInt(object.p2pVersion, 10);else if (typeof object.p2pVersion === \"number\") message.p2pVersion = object.p2pVersion;else if (typeof object.p2pVersion === \"object\") message.p2pVersion = new $util.LongBits(object.p2pVersion.low >>> 0, object.p2pVersion.high >>> 0).toNumber(true);\n          return message;\n        };\n        /**\n         * Creates a plain object from a RequestInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestInfo\n         * @static\n         * @param {tendermint.abci.RequestInfo} message RequestInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestInfo.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.version = \"\";\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.blockVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.blockVersion = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.p2pVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.p2pVersion = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.version != null && message.hasOwnProperty(\"version\")) object.version = message.version;\n          if (message.blockVersion != null && message.hasOwnProperty(\"blockVersion\")) if (typeof message.blockVersion === \"number\") object.blockVersion = options.longs === String ? String(message.blockVersion) : message.blockVersion;else object.blockVersion = options.longs === String ? $util.Long.prototype.toString.call(message.blockVersion) : options.longs === Number ? new $util.LongBits(message.blockVersion.low >>> 0, message.blockVersion.high >>> 0).toNumber(true) : message.blockVersion;\n          if (message.p2pVersion != null && message.hasOwnProperty(\"p2pVersion\")) if (typeof message.p2pVersion === \"number\") object.p2pVersion = options.longs === String ? String(message.p2pVersion) : message.p2pVersion;else object.p2pVersion = options.longs === String ? $util.Long.prototype.toString.call(message.p2pVersion) : options.longs === Number ? new $util.LongBits(message.p2pVersion.low >>> 0, message.p2pVersion.high >>> 0).toNumber(true) : message.p2pVersion;\n          return object;\n        };\n        /**\n         * Converts this RequestInfo to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestInfo.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestInfo;\n      }();\n\n      abci.RequestSetOption = function () {\n        /**\n         * Properties of a RequestSetOption.\n         * @memberof tendermint.abci\n         * @interface IRequestSetOption\n         * @property {string|null} [key] RequestSetOption key\n         * @property {string|null} [value] RequestSetOption value\n         */\n\n        /**\n         * Constructs a new RequestSetOption.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestSetOption.\n         * @implements IRequestSetOption\n         * @constructor\n         * @param {tendermint.abci.IRequestSetOption=} [properties] Properties to set\n         */\n        function RequestSetOption(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * RequestSetOption key.\n         * @member {string} key\n         * @memberof tendermint.abci.RequestSetOption\n         * @instance\n         */\n\n\n        RequestSetOption.prototype.key = \"\";\n        /**\n         * RequestSetOption value.\n         * @member {string} value\n         * @memberof tendermint.abci.RequestSetOption\n         * @instance\n         */\n\n        RequestSetOption.prototype.value = \"\";\n        /**\n         * Creates a new RequestSetOption instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestSetOption\n         * @static\n         * @param {tendermint.abci.IRequestSetOption=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestSetOption} RequestSetOption instance\n         */\n\n        RequestSetOption.create = function create(properties) {\n          return new RequestSetOption(properties);\n        };\n        /**\n         * Encodes the specified RequestSetOption message. Does not implicitly {@link tendermint.abci.RequestSetOption.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestSetOption\n         * @static\n         * @param {tendermint.abci.IRequestSetOption} message RequestSetOption message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestSetOption.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.key != null && Object.hasOwnProperty.call(message, \"key\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.key);\n          if (message.value != null && Object.hasOwnProperty.call(message, \"value\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).string(message.value);\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestSetOption message, length delimited. Does not implicitly {@link tendermint.abci.RequestSetOption.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestSetOption\n         * @static\n         * @param {tendermint.abci.IRequestSetOption} message RequestSetOption message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestSetOption.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestSetOption message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestSetOption\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestSetOption} RequestSetOption\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestSetOption.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestSetOption();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.key = reader.string();\n                break;\n\n              case 2:\n                message.value = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestSetOption message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestSetOption\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestSetOption} RequestSetOption\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestSetOption.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestSetOption message.\n         * @function verify\n         * @memberof tendermint.abci.RequestSetOption\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestSetOption.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.key != null && message.hasOwnProperty(\"key\")) if (!$util.isString(message.key)) return \"key: string expected\";\n          if (message.value != null && message.hasOwnProperty(\"value\")) if (!$util.isString(message.value)) return \"value: string expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestSetOption message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestSetOption\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestSetOption} RequestSetOption\n         */\n\n\n        RequestSetOption.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestSetOption) return object;\n          var message = new $root.tendermint.abci.RequestSetOption();\n          if (object.key != null) message.key = String(object.key);\n          if (object.value != null) message.value = String(object.value);\n          return message;\n        };\n        /**\n         * Creates a plain object from a RequestSetOption message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestSetOption\n         * @static\n         * @param {tendermint.abci.RequestSetOption} message RequestSetOption\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestSetOption.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.key = \"\";\n            object.value = \"\";\n          }\n\n          if (message.key != null && message.hasOwnProperty(\"key\")) object.key = message.key;\n          if (message.value != null && message.hasOwnProperty(\"value\")) object.value = message.value;\n          return object;\n        };\n        /**\n         * Converts this RequestSetOption to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestSetOption\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestSetOption.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestSetOption;\n      }();\n\n      abci.RequestInitChain = function () {\n        /**\n         * Properties of a RequestInitChain.\n         * @memberof tendermint.abci\n         * @interface IRequestInitChain\n         * @property {google.protobuf.ITimestamp|null} [time] RequestInitChain time\n         * @property {string|null} [chainId] RequestInitChain chainId\n         * @property {tendermint.abci.IConsensusParams|null} [consensusParams] RequestInitChain consensusParams\n         * @property {Array.<tendermint.abci.IValidatorUpdate>|null} [validators] RequestInitChain validators\n         * @property {Uint8Array|null} [appStateBytes] RequestInitChain appStateBytes\n         * @property {number|Long|null} [initialHeight] RequestInitChain initialHeight\n         */\n\n        /**\n         * Constructs a new RequestInitChain.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestInitChain.\n         * @implements IRequestInitChain\n         * @constructor\n         * @param {tendermint.abci.IRequestInitChain=} [properties] Properties to set\n         */\n        function RequestInitChain(properties) {\n          this.validators = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * RequestInitChain time.\n         * @member {google.protobuf.ITimestamp|null|undefined} time\n         * @memberof tendermint.abci.RequestInitChain\n         * @instance\n         */\n\n\n        RequestInitChain.prototype.time = null;\n        /**\n         * RequestInitChain chainId.\n         * @member {string} chainId\n         * @memberof tendermint.abci.RequestInitChain\n         * @instance\n         */\n\n        RequestInitChain.prototype.chainId = \"\";\n        /**\n         * RequestInitChain consensusParams.\n         * @member {tendermint.abci.IConsensusParams|null|undefined} consensusParams\n         * @memberof tendermint.abci.RequestInitChain\n         * @instance\n         */\n\n        RequestInitChain.prototype.consensusParams = null;\n        /**\n         * RequestInitChain validators.\n         * @member {Array.<tendermint.abci.IValidatorUpdate>} validators\n         * @memberof tendermint.abci.RequestInitChain\n         * @instance\n         */\n\n        RequestInitChain.prototype.validators = $util.emptyArray;\n        /**\n         * RequestInitChain appStateBytes.\n         * @member {Uint8Array} appStateBytes\n         * @memberof tendermint.abci.RequestInitChain\n         * @instance\n         */\n\n        RequestInitChain.prototype.appStateBytes = $util.newBuffer([]);\n        /**\n         * RequestInitChain initialHeight.\n         * @member {number|Long} initialHeight\n         * @memberof tendermint.abci.RequestInitChain\n         * @instance\n         */\n\n        RequestInitChain.prototype.initialHeight = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new RequestInitChain instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestInitChain\n         * @static\n         * @param {tendermint.abci.IRequestInitChain=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestInitChain} RequestInitChain instance\n         */\n\n        RequestInitChain.create = function create(properties) {\n          return new RequestInitChain(properties);\n        };\n        /**\n         * Encodes the specified RequestInitChain message. Does not implicitly {@link tendermint.abci.RequestInitChain.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestInitChain\n         * @static\n         * @param {tendermint.abci.IRequestInitChain} message RequestInitChain message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestInitChain.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.time != null && Object.hasOwnProperty.call(message, \"time\")) $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.chainId != null && Object.hasOwnProperty.call(message, \"chainId\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).string(message.chainId);\n          if (message.consensusParams != null && Object.hasOwnProperty.call(message, \"consensusParams\")) $root.tendermint.abci.ConsensusParams.encode(message.consensusParams, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          if (message.validators != null && message.validators.length) for (var i = 0; i < message.validators.length; ++i) {\n            $root.tendermint.abci.ValidatorUpdate.encode(message.validators[i], writer.uint32(\n            /* id 4, wireType 2 =*/\n            34).fork()).ldelim();\n          }\n          if (message.appStateBytes != null && Object.hasOwnProperty.call(message, \"appStateBytes\")) writer.uint32(\n          /* id 5, wireType 2 =*/\n          42).bytes(message.appStateBytes);\n          if (message.initialHeight != null && Object.hasOwnProperty.call(message, \"initialHeight\")) writer.uint32(\n          /* id 6, wireType 0 =*/\n          48).int64(message.initialHeight);\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestInitChain message, length delimited. Does not implicitly {@link tendermint.abci.RequestInitChain.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestInitChain\n         * @static\n         * @param {tendermint.abci.IRequestInitChain} message RequestInitChain message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestInitChain.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestInitChain message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestInitChain\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestInitChain} RequestInitChain\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestInitChain.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestInitChain();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.chainId = reader.string();\n                break;\n\n              case 3:\n                message.consensusParams = $root.tendermint.abci.ConsensusParams.decode(reader, reader.uint32());\n                break;\n\n              case 4:\n                if (!(message.validators && message.validators.length)) message.validators = [];\n                message.validators.push($root.tendermint.abci.ValidatorUpdate.decode(reader, reader.uint32()));\n                break;\n\n              case 5:\n                message.appStateBytes = reader.bytes();\n                break;\n\n              case 6:\n                message.initialHeight = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestInitChain message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestInitChain\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestInitChain} RequestInitChain\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestInitChain.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestInitChain message.\n         * @function verify\n         * @memberof tendermint.abci.RequestInitChain\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestInitChain.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.time != null && message.hasOwnProperty(\"time\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.time);\n            if (error) return \"time.\" + error;\n          }\n\n          if (message.chainId != null && message.hasOwnProperty(\"chainId\")) if (!$util.isString(message.chainId)) return \"chainId: string expected\";\n\n          if (message.consensusParams != null && message.hasOwnProperty(\"consensusParams\")) {\n            var error = $root.tendermint.abci.ConsensusParams.verify(message.consensusParams);\n            if (error) return \"consensusParams.\" + error;\n          }\n\n          if (message.validators != null && message.hasOwnProperty(\"validators\")) {\n            if (!Array.isArray(message.validators)) return \"validators: array expected\";\n\n            for (var i = 0; i < message.validators.length; ++i) {\n              var error = $root.tendermint.abci.ValidatorUpdate.verify(message.validators[i]);\n              if (error) return \"validators.\" + error;\n            }\n          }\n\n          if (message.appStateBytes != null && message.hasOwnProperty(\"appStateBytes\")) if (!(message.appStateBytes && typeof message.appStateBytes.length === \"number\" || $util.isString(message.appStateBytes))) return \"appStateBytes: buffer expected\";\n          if (message.initialHeight != null && message.hasOwnProperty(\"initialHeight\")) if (!$util.isInteger(message.initialHeight) && !(message.initialHeight && $util.isInteger(message.initialHeight.low) && $util.isInteger(message.initialHeight.high))) return \"initialHeight: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestInitChain message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestInitChain\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestInitChain} RequestInitChain\n         */\n\n\n        RequestInitChain.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestInitChain) return object;\n          var message = new $root.tendermint.abci.RequestInitChain();\n\n          if (object.time != null) {\n            if (typeof object.time !== \"object\") throw TypeError(\".tendermint.abci.RequestInitChain.time: object expected\");\n            message.time = $root.google.protobuf.Timestamp.fromObject(object.time);\n          }\n\n          if (object.chainId != null) message.chainId = String(object.chainId);\n\n          if (object.consensusParams != null) {\n            if (typeof object.consensusParams !== \"object\") throw TypeError(\".tendermint.abci.RequestInitChain.consensusParams: object expected\");\n            message.consensusParams = $root.tendermint.abci.ConsensusParams.fromObject(object.consensusParams);\n          }\n\n          if (object.validators) {\n            if (!Array.isArray(object.validators)) throw TypeError(\".tendermint.abci.RequestInitChain.validators: array expected\");\n            message.validators = [];\n\n            for (var i = 0; i < object.validators.length; ++i) {\n              if (typeof object.validators[i] !== \"object\") throw TypeError(\".tendermint.abci.RequestInitChain.validators: object expected\");\n              message.validators[i] = $root.tendermint.abci.ValidatorUpdate.fromObject(object.validators[i]);\n            }\n          }\n\n          if (object.appStateBytes != null) if (typeof object.appStateBytes === \"string\") $util.base64.decode(object.appStateBytes, message.appStateBytes = $util.newBuffer($util.base64.length(object.appStateBytes)), 0);else if (object.appStateBytes.length) message.appStateBytes = object.appStateBytes;\n          if (object.initialHeight != null) if ($util.Long) (message.initialHeight = $util.Long.fromValue(object.initialHeight)).unsigned = false;else if (typeof object.initialHeight === \"string\") message.initialHeight = parseInt(object.initialHeight, 10);else if (typeof object.initialHeight === \"number\") message.initialHeight = object.initialHeight;else if (typeof object.initialHeight === \"object\") message.initialHeight = new $util.LongBits(object.initialHeight.low >>> 0, object.initialHeight.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a RequestInitChain message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestInitChain\n         * @static\n         * @param {tendermint.abci.RequestInitChain} message RequestInitChain\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestInitChain.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.validators = [];\n\n          if (options.defaults) {\n            object.time = null;\n            object.chainId = \"\";\n            object.consensusParams = null;\n            if (options.bytes === String) object.appStateBytes = \"\";else {\n              object.appStateBytes = [];\n              if (options.bytes !== Array) object.appStateBytes = $util.newBuffer(object.appStateBytes);\n            }\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.initialHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.initialHeight = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.time != null && message.hasOwnProperty(\"time\")) object.time = $root.google.protobuf.Timestamp.toObject(message.time, options);\n          if (message.chainId != null && message.hasOwnProperty(\"chainId\")) object.chainId = message.chainId;\n          if (message.consensusParams != null && message.hasOwnProperty(\"consensusParams\")) object.consensusParams = $root.tendermint.abci.ConsensusParams.toObject(message.consensusParams, options);\n\n          if (message.validators && message.validators.length) {\n            object.validators = [];\n\n            for (var j = 0; j < message.validators.length; ++j) {\n              object.validators[j] = $root.tendermint.abci.ValidatorUpdate.toObject(message.validators[j], options);\n            }\n          }\n\n          if (message.appStateBytes != null && message.hasOwnProperty(\"appStateBytes\")) object.appStateBytes = options.bytes === String ? $util.base64.encode(message.appStateBytes, 0, message.appStateBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.appStateBytes) : message.appStateBytes;\n          if (message.initialHeight != null && message.hasOwnProperty(\"initialHeight\")) if (typeof message.initialHeight === \"number\") object.initialHeight = options.longs === String ? String(message.initialHeight) : message.initialHeight;else object.initialHeight = options.longs === String ? $util.Long.prototype.toString.call(message.initialHeight) : options.longs === Number ? new $util.LongBits(message.initialHeight.low >>> 0, message.initialHeight.high >>> 0).toNumber() : message.initialHeight;\n          return object;\n        };\n        /**\n         * Converts this RequestInitChain to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestInitChain\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestInitChain.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestInitChain;\n      }();\n\n      abci.RequestQuery = function () {\n        /**\n         * Properties of a RequestQuery.\n         * @memberof tendermint.abci\n         * @interface IRequestQuery\n         * @property {Uint8Array|null} [data] RequestQuery data\n         * @property {string|null} [path] RequestQuery path\n         * @property {number|Long|null} [height] RequestQuery height\n         * @property {boolean|null} [prove] RequestQuery prove\n         */\n\n        /**\n         * Constructs a new RequestQuery.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestQuery.\n         * @implements IRequestQuery\n         * @constructor\n         * @param {tendermint.abci.IRequestQuery=} [properties] Properties to set\n         */\n        function RequestQuery(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * RequestQuery data.\n         * @member {Uint8Array} data\n         * @memberof tendermint.abci.RequestQuery\n         * @instance\n         */\n\n\n        RequestQuery.prototype.data = $util.newBuffer([]);\n        /**\n         * RequestQuery path.\n         * @member {string} path\n         * @memberof tendermint.abci.RequestQuery\n         * @instance\n         */\n\n        RequestQuery.prototype.path = \"\";\n        /**\n         * RequestQuery height.\n         * @member {number|Long} height\n         * @memberof tendermint.abci.RequestQuery\n         * @instance\n         */\n\n        RequestQuery.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * RequestQuery prove.\n         * @member {boolean} prove\n         * @memberof tendermint.abci.RequestQuery\n         * @instance\n         */\n\n        RequestQuery.prototype.prove = false;\n        /**\n         * Creates a new RequestQuery instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestQuery\n         * @static\n         * @param {tendermint.abci.IRequestQuery=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestQuery} RequestQuery instance\n         */\n\n        RequestQuery.create = function create(properties) {\n          return new RequestQuery(properties);\n        };\n        /**\n         * Encodes the specified RequestQuery message. Does not implicitly {@link tendermint.abci.RequestQuery.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestQuery\n         * @static\n         * @param {tendermint.abci.IRequestQuery} message RequestQuery message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestQuery.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).bytes(message.data);\n          if (message.path != null && Object.hasOwnProperty.call(message, \"path\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).string(message.path);\n          if (message.height != null && Object.hasOwnProperty.call(message, \"height\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int64(message.height);\n          if (message.prove != null && Object.hasOwnProperty.call(message, \"prove\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).bool(message.prove);\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestQuery message, length delimited. Does not implicitly {@link tendermint.abci.RequestQuery.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestQuery\n         * @static\n         * @param {tendermint.abci.IRequestQuery} message RequestQuery message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestQuery.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestQuery message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestQuery\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestQuery} RequestQuery\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestQuery.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestQuery();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.data = reader.bytes();\n                break;\n\n              case 2:\n                message.path = reader.string();\n                break;\n\n              case 3:\n                message.height = reader.int64();\n                break;\n\n              case 4:\n                message.prove = reader.bool();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestQuery message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestQuery\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestQuery} RequestQuery\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestQuery.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestQuery message.\n         * @function verify\n         * @memberof tendermint.abci.RequestQuery\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestQuery.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.data != null && message.hasOwnProperty(\"data\")) if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data))) return \"data: buffer expected\";\n          if (message.path != null && message.hasOwnProperty(\"path\")) if (!$util.isString(message.path)) return \"path: string expected\";\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))) return \"height: integer|Long expected\";\n          if (message.prove != null && message.hasOwnProperty(\"prove\")) if (typeof message.prove !== \"boolean\") return \"prove: boolean expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestQuery message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestQuery\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestQuery} RequestQuery\n         */\n\n\n        RequestQuery.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestQuery) return object;\n          var message = new $root.tendermint.abci.RequestQuery();\n          if (object.data != null) if (typeof object.data === \"string\") $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;\n          if (object.path != null) message.path = String(object.path);\n          if (object.height != null) if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;else if (typeof object.height === \"string\") message.height = parseInt(object.height, 10);else if (typeof object.height === \"number\") message.height = object.height;else if (typeof object.height === \"object\") message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();\n          if (object.prove != null) message.prove = Boolean(object.prove);\n          return message;\n        };\n        /**\n         * Creates a plain object from a RequestQuery message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestQuery\n         * @static\n         * @param {tendermint.abci.RequestQuery} message RequestQuery\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestQuery.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if (options.bytes === String) object.data = \"\";else {\n              object.data = [];\n              if (options.bytes !== Array) object.data = $util.newBuffer(object.data);\n            }\n            object.path = \"\";\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.height = options.longs === String ? \"0\" : 0;\n\n            object.prove = false;\n          }\n\n          if (message.data != null && message.hasOwnProperty(\"data\")) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n          if (message.path != null && message.hasOwnProperty(\"path\")) object.path = message.path;\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (typeof message.height === \"number\") object.height = options.longs === String ? String(message.height) : message.height;else object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;\n          if (message.prove != null && message.hasOwnProperty(\"prove\")) object.prove = message.prove;\n          return object;\n        };\n        /**\n         * Converts this RequestQuery to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestQuery\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestQuery.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestQuery;\n      }();\n\n      abci.RequestBeginBlock = function () {\n        /**\n         * Properties of a RequestBeginBlock.\n         * @memberof tendermint.abci\n         * @interface IRequestBeginBlock\n         * @property {Uint8Array|null} [hash] RequestBeginBlock hash\n         * @property {tendermint.types.IHeader|null} [header] RequestBeginBlock header\n         * @property {tendermint.abci.ILastCommitInfo|null} [lastCommitInfo] RequestBeginBlock lastCommitInfo\n         * @property {Array.<tendermint.abci.IEvidence>|null} [byzantineValidators] RequestBeginBlock byzantineValidators\n         */\n\n        /**\n         * Constructs a new RequestBeginBlock.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestBeginBlock.\n         * @implements IRequestBeginBlock\n         * @constructor\n         * @param {tendermint.abci.IRequestBeginBlock=} [properties] Properties to set\n         */\n        function RequestBeginBlock(properties) {\n          this.byzantineValidators = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * RequestBeginBlock hash.\n         * @member {Uint8Array} hash\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @instance\n         */\n\n\n        RequestBeginBlock.prototype.hash = $util.newBuffer([]);\n        /**\n         * RequestBeginBlock header.\n         * @member {tendermint.types.IHeader|null|undefined} header\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @instance\n         */\n\n        RequestBeginBlock.prototype.header = null;\n        /**\n         * RequestBeginBlock lastCommitInfo.\n         * @member {tendermint.abci.ILastCommitInfo|null|undefined} lastCommitInfo\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @instance\n         */\n\n        RequestBeginBlock.prototype.lastCommitInfo = null;\n        /**\n         * RequestBeginBlock byzantineValidators.\n         * @member {Array.<tendermint.abci.IEvidence>} byzantineValidators\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @instance\n         */\n\n        RequestBeginBlock.prototype.byzantineValidators = $util.emptyArray;\n        /**\n         * Creates a new RequestBeginBlock instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @static\n         * @param {tendermint.abci.IRequestBeginBlock=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestBeginBlock} RequestBeginBlock instance\n         */\n\n        RequestBeginBlock.create = function create(properties) {\n          return new RequestBeginBlock(properties);\n        };\n        /**\n         * Encodes the specified RequestBeginBlock message. Does not implicitly {@link tendermint.abci.RequestBeginBlock.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @static\n         * @param {tendermint.abci.IRequestBeginBlock} message RequestBeginBlock message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestBeginBlock.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.hash != null && Object.hasOwnProperty.call(message, \"hash\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).bytes(message.hash);\n          if (message.header != null && Object.hasOwnProperty.call(message, \"header\")) $root.tendermint.types.Header.encode(message.header, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          if (message.lastCommitInfo != null && Object.hasOwnProperty.call(message, \"lastCommitInfo\")) $root.tendermint.abci.LastCommitInfo.encode(message.lastCommitInfo, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          if (message.byzantineValidators != null && message.byzantineValidators.length) for (var i = 0; i < message.byzantineValidators.length; ++i) {\n            $root.tendermint.abci.Evidence.encode(message.byzantineValidators[i], writer.uint32(\n            /* id 4, wireType 2 =*/\n            34).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestBeginBlock message, length delimited. Does not implicitly {@link tendermint.abci.RequestBeginBlock.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @static\n         * @param {tendermint.abci.IRequestBeginBlock} message RequestBeginBlock message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestBeginBlock.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestBeginBlock message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestBeginBlock} RequestBeginBlock\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestBeginBlock.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestBeginBlock();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.hash = reader.bytes();\n                break;\n\n              case 2:\n                message.header = $root.tendermint.types.Header.decode(reader, reader.uint32());\n                break;\n\n              case 3:\n                message.lastCommitInfo = $root.tendermint.abci.LastCommitInfo.decode(reader, reader.uint32());\n                break;\n\n              case 4:\n                if (!(message.byzantineValidators && message.byzantineValidators.length)) message.byzantineValidators = [];\n                message.byzantineValidators.push($root.tendermint.abci.Evidence.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestBeginBlock message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestBeginBlock} RequestBeginBlock\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestBeginBlock.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestBeginBlock message.\n         * @function verify\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestBeginBlock.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.hash != null && message.hasOwnProperty(\"hash\")) if (!(message.hash && typeof message.hash.length === \"number\" || $util.isString(message.hash))) return \"hash: buffer expected\";\n\n          if (message.header != null && message.hasOwnProperty(\"header\")) {\n            var error = $root.tendermint.types.Header.verify(message.header);\n            if (error) return \"header.\" + error;\n          }\n\n          if (message.lastCommitInfo != null && message.hasOwnProperty(\"lastCommitInfo\")) {\n            var error = $root.tendermint.abci.LastCommitInfo.verify(message.lastCommitInfo);\n            if (error) return \"lastCommitInfo.\" + error;\n          }\n\n          if (message.byzantineValidators != null && message.hasOwnProperty(\"byzantineValidators\")) {\n            if (!Array.isArray(message.byzantineValidators)) return \"byzantineValidators: array expected\";\n\n            for (var i = 0; i < message.byzantineValidators.length; ++i) {\n              var error = $root.tendermint.abci.Evidence.verify(message.byzantineValidators[i]);\n              if (error) return \"byzantineValidators.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a RequestBeginBlock message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestBeginBlock} RequestBeginBlock\n         */\n\n\n        RequestBeginBlock.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestBeginBlock) return object;\n          var message = new $root.tendermint.abci.RequestBeginBlock();\n          if (object.hash != null) if (typeof object.hash === \"string\") $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);else if (object.hash.length) message.hash = object.hash;\n\n          if (object.header != null) {\n            if (typeof object.header !== \"object\") throw TypeError(\".tendermint.abci.RequestBeginBlock.header: object expected\");\n            message.header = $root.tendermint.types.Header.fromObject(object.header);\n          }\n\n          if (object.lastCommitInfo != null) {\n            if (typeof object.lastCommitInfo !== \"object\") throw TypeError(\".tendermint.abci.RequestBeginBlock.lastCommitInfo: object expected\");\n            message.lastCommitInfo = $root.tendermint.abci.LastCommitInfo.fromObject(object.lastCommitInfo);\n          }\n\n          if (object.byzantineValidators) {\n            if (!Array.isArray(object.byzantineValidators)) throw TypeError(\".tendermint.abci.RequestBeginBlock.byzantineValidators: array expected\");\n            message.byzantineValidators = [];\n\n            for (var i = 0; i < object.byzantineValidators.length; ++i) {\n              if (typeof object.byzantineValidators[i] !== \"object\") throw TypeError(\".tendermint.abci.RequestBeginBlock.byzantineValidators: object expected\");\n              message.byzantineValidators[i] = $root.tendermint.abci.Evidence.fromObject(object.byzantineValidators[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a RequestBeginBlock message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @static\n         * @param {tendermint.abci.RequestBeginBlock} message RequestBeginBlock\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestBeginBlock.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.byzantineValidators = [];\n\n          if (options.defaults) {\n            if (options.bytes === String) object.hash = \"\";else {\n              object.hash = [];\n              if (options.bytes !== Array) object.hash = $util.newBuffer(object.hash);\n            }\n            object.header = null;\n            object.lastCommitInfo = null;\n          }\n\n          if (message.hash != null && message.hasOwnProperty(\"hash\")) object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;\n          if (message.header != null && message.hasOwnProperty(\"header\")) object.header = $root.tendermint.types.Header.toObject(message.header, options);\n          if (message.lastCommitInfo != null && message.hasOwnProperty(\"lastCommitInfo\")) object.lastCommitInfo = $root.tendermint.abci.LastCommitInfo.toObject(message.lastCommitInfo, options);\n\n          if (message.byzantineValidators && message.byzantineValidators.length) {\n            object.byzantineValidators = [];\n\n            for (var j = 0; j < message.byzantineValidators.length; ++j) {\n              object.byzantineValidators[j] = $root.tendermint.abci.Evidence.toObject(message.byzantineValidators[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this RequestBeginBlock to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestBeginBlock\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestBeginBlock.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestBeginBlock;\n      }();\n      /**\n       * CheckTxType enum.\n       * @name tendermint.abci.CheckTxType\n       * @enum {number}\n       * @property {number} NEW=0 NEW value\n       * @property {number} RECHECK=1 RECHECK value\n       */\n\n\n      abci.CheckTxType = function () {\n        var valuesById = {},\n            values = Object.create(valuesById);\n        values[valuesById[0] = \"NEW\"] = 0;\n        values[valuesById[1] = \"RECHECK\"] = 1;\n        return values;\n      }();\n\n      abci.RequestCheckTx = function () {\n        /**\n         * Properties of a RequestCheckTx.\n         * @memberof tendermint.abci\n         * @interface IRequestCheckTx\n         * @property {Uint8Array|null} [tx] RequestCheckTx tx\n         * @property {tendermint.abci.CheckTxType|null} [type] RequestCheckTx type\n         */\n\n        /**\n         * Constructs a new RequestCheckTx.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestCheckTx.\n         * @implements IRequestCheckTx\n         * @constructor\n         * @param {tendermint.abci.IRequestCheckTx=} [properties] Properties to set\n         */\n        function RequestCheckTx(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * RequestCheckTx tx.\n         * @member {Uint8Array} tx\n         * @memberof tendermint.abci.RequestCheckTx\n         * @instance\n         */\n\n\n        RequestCheckTx.prototype.tx = $util.newBuffer([]);\n        /**\n         * RequestCheckTx type.\n         * @member {tendermint.abci.CheckTxType} type\n         * @memberof tendermint.abci.RequestCheckTx\n         * @instance\n         */\n\n        RequestCheckTx.prototype.type = 0;\n        /**\n         * Creates a new RequestCheckTx instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestCheckTx\n         * @static\n         * @param {tendermint.abci.IRequestCheckTx=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestCheckTx} RequestCheckTx instance\n         */\n\n        RequestCheckTx.create = function create(properties) {\n          return new RequestCheckTx(properties);\n        };\n        /**\n         * Encodes the specified RequestCheckTx message. Does not implicitly {@link tendermint.abci.RequestCheckTx.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestCheckTx\n         * @static\n         * @param {tendermint.abci.IRequestCheckTx} message RequestCheckTx message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestCheckTx.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.tx != null && Object.hasOwnProperty.call(message, \"tx\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).bytes(message.tx);\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.type);\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestCheckTx message, length delimited. Does not implicitly {@link tendermint.abci.RequestCheckTx.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestCheckTx\n         * @static\n         * @param {tendermint.abci.IRequestCheckTx} message RequestCheckTx message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestCheckTx.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestCheckTx message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestCheckTx\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestCheckTx} RequestCheckTx\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestCheckTx.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestCheckTx();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.tx = reader.bytes();\n                break;\n\n              case 2:\n                message.type = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestCheckTx message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestCheckTx\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestCheckTx} RequestCheckTx\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestCheckTx.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestCheckTx message.\n         * @function verify\n         * @memberof tendermint.abci.RequestCheckTx\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestCheckTx.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.tx != null && message.hasOwnProperty(\"tx\")) if (!(message.tx && typeof message.tx.length === \"number\" || $util.isString(message.tx))) return \"tx: buffer expected\";\n          if (message.type != null && message.hasOwnProperty(\"type\")) switch (message.type) {\n            default:\n              return \"type: enum value expected\";\n\n            case 0:\n            case 1:\n              break;\n          }\n          return null;\n        };\n        /**\n         * Creates a RequestCheckTx message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestCheckTx\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestCheckTx} RequestCheckTx\n         */\n\n\n        RequestCheckTx.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestCheckTx) return object;\n          var message = new $root.tendermint.abci.RequestCheckTx();\n          if (object.tx != null) if (typeof object.tx === \"string\") $util.base64.decode(object.tx, message.tx = $util.newBuffer($util.base64.length(object.tx)), 0);else if (object.tx.length) message.tx = object.tx;\n\n          switch (object.type) {\n            case \"NEW\":\n            case 0:\n              message.type = 0;\n              break;\n\n            case \"RECHECK\":\n            case 1:\n              message.type = 1;\n              break;\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a RequestCheckTx message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestCheckTx\n         * @static\n         * @param {tendermint.abci.RequestCheckTx} message RequestCheckTx\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestCheckTx.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if (options.bytes === String) object.tx = \"\";else {\n              object.tx = [];\n              if (options.bytes !== Array) object.tx = $util.newBuffer(object.tx);\n            }\n            object.type = options.enums === String ? \"NEW\" : 0;\n          }\n\n          if (message.tx != null && message.hasOwnProperty(\"tx\")) object.tx = options.bytes === String ? $util.base64.encode(message.tx, 0, message.tx.length) : options.bytes === Array ? Array.prototype.slice.call(message.tx) : message.tx;\n          if (message.type != null && message.hasOwnProperty(\"type\")) object.type = options.enums === String ? $root.tendermint.abci.CheckTxType[message.type] : message.type;\n          return object;\n        };\n        /**\n         * Converts this RequestCheckTx to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestCheckTx\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestCheckTx.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestCheckTx;\n      }();\n\n      abci.RequestDeliverTx = function () {\n        /**\n         * Properties of a RequestDeliverTx.\n         * @memberof tendermint.abci\n         * @interface IRequestDeliverTx\n         * @property {Uint8Array|null} [tx] RequestDeliverTx tx\n         */\n\n        /**\n         * Constructs a new RequestDeliverTx.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestDeliverTx.\n         * @implements IRequestDeliverTx\n         * @constructor\n         * @param {tendermint.abci.IRequestDeliverTx=} [properties] Properties to set\n         */\n        function RequestDeliverTx(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * RequestDeliverTx tx.\n         * @member {Uint8Array} tx\n         * @memberof tendermint.abci.RequestDeliverTx\n         * @instance\n         */\n\n\n        RequestDeliverTx.prototype.tx = $util.newBuffer([]);\n        /**\n         * Creates a new RequestDeliverTx instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestDeliverTx\n         * @static\n         * @param {tendermint.abci.IRequestDeliverTx=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestDeliverTx} RequestDeliverTx instance\n         */\n\n        RequestDeliverTx.create = function create(properties) {\n          return new RequestDeliverTx(properties);\n        };\n        /**\n         * Encodes the specified RequestDeliverTx message. Does not implicitly {@link tendermint.abci.RequestDeliverTx.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestDeliverTx\n         * @static\n         * @param {tendermint.abci.IRequestDeliverTx} message RequestDeliverTx message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestDeliverTx.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.tx != null && Object.hasOwnProperty.call(message, \"tx\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).bytes(message.tx);\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestDeliverTx message, length delimited. Does not implicitly {@link tendermint.abci.RequestDeliverTx.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestDeliverTx\n         * @static\n         * @param {tendermint.abci.IRequestDeliverTx} message RequestDeliverTx message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestDeliverTx.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestDeliverTx message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestDeliverTx\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestDeliverTx} RequestDeliverTx\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestDeliverTx.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestDeliverTx();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.tx = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestDeliverTx message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestDeliverTx\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestDeliverTx} RequestDeliverTx\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestDeliverTx.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestDeliverTx message.\n         * @function verify\n         * @memberof tendermint.abci.RequestDeliverTx\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestDeliverTx.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.tx != null && message.hasOwnProperty(\"tx\")) if (!(message.tx && typeof message.tx.length === \"number\" || $util.isString(message.tx))) return \"tx: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestDeliverTx message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestDeliverTx\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestDeliverTx} RequestDeliverTx\n         */\n\n\n        RequestDeliverTx.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestDeliverTx) return object;\n          var message = new $root.tendermint.abci.RequestDeliverTx();\n          if (object.tx != null) if (typeof object.tx === \"string\") $util.base64.decode(object.tx, message.tx = $util.newBuffer($util.base64.length(object.tx)), 0);else if (object.tx.length) message.tx = object.tx;\n          return message;\n        };\n        /**\n         * Creates a plain object from a RequestDeliverTx message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestDeliverTx\n         * @static\n         * @param {tendermint.abci.RequestDeliverTx} message RequestDeliverTx\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestDeliverTx.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.defaults) if (options.bytes === String) object.tx = \"\";else {\n            object.tx = [];\n            if (options.bytes !== Array) object.tx = $util.newBuffer(object.tx);\n          }\n          if (message.tx != null && message.hasOwnProperty(\"tx\")) object.tx = options.bytes === String ? $util.base64.encode(message.tx, 0, message.tx.length) : options.bytes === Array ? Array.prototype.slice.call(message.tx) : message.tx;\n          return object;\n        };\n        /**\n         * Converts this RequestDeliverTx to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestDeliverTx\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestDeliverTx.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestDeliverTx;\n      }();\n\n      abci.RequestEndBlock = function () {\n        /**\n         * Properties of a RequestEndBlock.\n         * @memberof tendermint.abci\n         * @interface IRequestEndBlock\n         * @property {number|Long|null} [height] RequestEndBlock height\n         */\n\n        /**\n         * Constructs a new RequestEndBlock.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestEndBlock.\n         * @implements IRequestEndBlock\n         * @constructor\n         * @param {tendermint.abci.IRequestEndBlock=} [properties] Properties to set\n         */\n        function RequestEndBlock(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * RequestEndBlock height.\n         * @member {number|Long} height\n         * @memberof tendermint.abci.RequestEndBlock\n         * @instance\n         */\n\n\n        RequestEndBlock.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new RequestEndBlock instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestEndBlock\n         * @static\n         * @param {tendermint.abci.IRequestEndBlock=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestEndBlock} RequestEndBlock instance\n         */\n\n        RequestEndBlock.create = function create(properties) {\n          return new RequestEndBlock(properties);\n        };\n        /**\n         * Encodes the specified RequestEndBlock message. Does not implicitly {@link tendermint.abci.RequestEndBlock.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestEndBlock\n         * @static\n         * @param {tendermint.abci.IRequestEndBlock} message RequestEndBlock message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestEndBlock.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.height != null && Object.hasOwnProperty.call(message, \"height\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int64(message.height);\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestEndBlock message, length delimited. Does not implicitly {@link tendermint.abci.RequestEndBlock.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestEndBlock\n         * @static\n         * @param {tendermint.abci.IRequestEndBlock} message RequestEndBlock message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestEndBlock.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestEndBlock message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestEndBlock\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestEndBlock} RequestEndBlock\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestEndBlock.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestEndBlock();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.height = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestEndBlock message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestEndBlock\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestEndBlock} RequestEndBlock\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestEndBlock.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestEndBlock message.\n         * @function verify\n         * @memberof tendermint.abci.RequestEndBlock\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestEndBlock.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))) return \"height: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestEndBlock message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestEndBlock\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestEndBlock} RequestEndBlock\n         */\n\n\n        RequestEndBlock.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestEndBlock) return object;\n          var message = new $root.tendermint.abci.RequestEndBlock();\n          if (object.height != null) if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;else if (typeof object.height === \"string\") message.height = parseInt(object.height, 10);else if (typeof object.height === \"number\") message.height = object.height;else if (typeof object.height === \"object\") message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a RequestEndBlock message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestEndBlock\n         * @static\n         * @param {tendermint.abci.RequestEndBlock} message RequestEndBlock\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestEndBlock.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.defaults) if ($util.Long) {\n            var long = new $util.Long(0, 0, false);\n            object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n          } else object.height = options.longs === String ? \"0\" : 0;\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (typeof message.height === \"number\") object.height = options.longs === String ? String(message.height) : message.height;else object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;\n          return object;\n        };\n        /**\n         * Converts this RequestEndBlock to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestEndBlock\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestEndBlock.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestEndBlock;\n      }();\n\n      abci.RequestCommit = function () {\n        /**\n         * Properties of a RequestCommit.\n         * @memberof tendermint.abci\n         * @interface IRequestCommit\n         */\n\n        /**\n         * Constructs a new RequestCommit.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestCommit.\n         * @implements IRequestCommit\n         * @constructor\n         * @param {tendermint.abci.IRequestCommit=} [properties] Properties to set\n         */\n        function RequestCommit(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Creates a new RequestCommit instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestCommit\n         * @static\n         * @param {tendermint.abci.IRequestCommit=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestCommit} RequestCommit instance\n         */\n\n\n        RequestCommit.create = function create(properties) {\n          return new RequestCommit(properties);\n        };\n        /**\n         * Encodes the specified RequestCommit message. Does not implicitly {@link tendermint.abci.RequestCommit.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestCommit\n         * @static\n         * @param {tendermint.abci.IRequestCommit} message RequestCommit message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestCommit.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestCommit message, length delimited. Does not implicitly {@link tendermint.abci.RequestCommit.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestCommit\n         * @static\n         * @param {tendermint.abci.IRequestCommit} message RequestCommit message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestCommit.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestCommit message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestCommit\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestCommit} RequestCommit\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestCommit.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestCommit();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestCommit message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestCommit\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestCommit} RequestCommit\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestCommit.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestCommit message.\n         * @function verify\n         * @memberof tendermint.abci.RequestCommit\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestCommit.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestCommit message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestCommit\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestCommit} RequestCommit\n         */\n\n\n        RequestCommit.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestCommit) return object;\n          return new $root.tendermint.abci.RequestCommit();\n        };\n        /**\n         * Creates a plain object from a RequestCommit message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestCommit\n         * @static\n         * @param {tendermint.abci.RequestCommit} message RequestCommit\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestCommit.toObject = function toObject() {\n          return {};\n        };\n        /**\n         * Converts this RequestCommit to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestCommit\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestCommit.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestCommit;\n      }();\n\n      abci.RequestListSnapshots = function () {\n        /**\n         * Properties of a RequestListSnapshots.\n         * @memberof tendermint.abci\n         * @interface IRequestListSnapshots\n         */\n\n        /**\n         * Constructs a new RequestListSnapshots.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestListSnapshots.\n         * @implements IRequestListSnapshots\n         * @constructor\n         * @param {tendermint.abci.IRequestListSnapshots=} [properties] Properties to set\n         */\n        function RequestListSnapshots(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Creates a new RequestListSnapshots instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestListSnapshots\n         * @static\n         * @param {tendermint.abci.IRequestListSnapshots=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestListSnapshots} RequestListSnapshots instance\n         */\n\n\n        RequestListSnapshots.create = function create(properties) {\n          return new RequestListSnapshots(properties);\n        };\n        /**\n         * Encodes the specified RequestListSnapshots message. Does not implicitly {@link tendermint.abci.RequestListSnapshots.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestListSnapshots\n         * @static\n         * @param {tendermint.abci.IRequestListSnapshots} message RequestListSnapshots message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestListSnapshots.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestListSnapshots message, length delimited. Does not implicitly {@link tendermint.abci.RequestListSnapshots.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestListSnapshots\n         * @static\n         * @param {tendermint.abci.IRequestListSnapshots} message RequestListSnapshots message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestListSnapshots.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestListSnapshots message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestListSnapshots\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestListSnapshots} RequestListSnapshots\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestListSnapshots.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestListSnapshots();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestListSnapshots message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestListSnapshots\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestListSnapshots} RequestListSnapshots\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestListSnapshots.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestListSnapshots message.\n         * @function verify\n         * @memberof tendermint.abci.RequestListSnapshots\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestListSnapshots.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestListSnapshots message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestListSnapshots\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestListSnapshots} RequestListSnapshots\n         */\n\n\n        RequestListSnapshots.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestListSnapshots) return object;\n          return new $root.tendermint.abci.RequestListSnapshots();\n        };\n        /**\n         * Creates a plain object from a RequestListSnapshots message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestListSnapshots\n         * @static\n         * @param {tendermint.abci.RequestListSnapshots} message RequestListSnapshots\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestListSnapshots.toObject = function toObject() {\n          return {};\n        };\n        /**\n         * Converts this RequestListSnapshots to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestListSnapshots\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestListSnapshots.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestListSnapshots;\n      }();\n\n      abci.RequestOfferSnapshot = function () {\n        /**\n         * Properties of a RequestOfferSnapshot.\n         * @memberof tendermint.abci\n         * @interface IRequestOfferSnapshot\n         * @property {tendermint.abci.ISnapshot|null} [snapshot] RequestOfferSnapshot snapshot\n         * @property {Uint8Array|null} [appHash] RequestOfferSnapshot appHash\n         */\n\n        /**\n         * Constructs a new RequestOfferSnapshot.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestOfferSnapshot.\n         * @implements IRequestOfferSnapshot\n         * @constructor\n         * @param {tendermint.abci.IRequestOfferSnapshot=} [properties] Properties to set\n         */\n        function RequestOfferSnapshot(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * RequestOfferSnapshot snapshot.\n         * @member {tendermint.abci.ISnapshot|null|undefined} snapshot\n         * @memberof tendermint.abci.RequestOfferSnapshot\n         * @instance\n         */\n\n\n        RequestOfferSnapshot.prototype.snapshot = null;\n        /**\n         * RequestOfferSnapshot appHash.\n         * @member {Uint8Array} appHash\n         * @memberof tendermint.abci.RequestOfferSnapshot\n         * @instance\n         */\n\n        RequestOfferSnapshot.prototype.appHash = $util.newBuffer([]);\n        /**\n         * Creates a new RequestOfferSnapshot instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestOfferSnapshot\n         * @static\n         * @param {tendermint.abci.IRequestOfferSnapshot=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestOfferSnapshot} RequestOfferSnapshot instance\n         */\n\n        RequestOfferSnapshot.create = function create(properties) {\n          return new RequestOfferSnapshot(properties);\n        };\n        /**\n         * Encodes the specified RequestOfferSnapshot message. Does not implicitly {@link tendermint.abci.RequestOfferSnapshot.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestOfferSnapshot\n         * @static\n         * @param {tendermint.abci.IRequestOfferSnapshot} message RequestOfferSnapshot message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestOfferSnapshot.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.snapshot != null && Object.hasOwnProperty.call(message, \"snapshot\")) $root.tendermint.abci.Snapshot.encode(message.snapshot, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.appHash != null && Object.hasOwnProperty.call(message, \"appHash\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.appHash);\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestOfferSnapshot message, length delimited. Does not implicitly {@link tendermint.abci.RequestOfferSnapshot.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestOfferSnapshot\n         * @static\n         * @param {tendermint.abci.IRequestOfferSnapshot} message RequestOfferSnapshot message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestOfferSnapshot.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestOfferSnapshot message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestOfferSnapshot\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestOfferSnapshot} RequestOfferSnapshot\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestOfferSnapshot.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestOfferSnapshot();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.snapshot = $root.tendermint.abci.Snapshot.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.appHash = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestOfferSnapshot message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestOfferSnapshot\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestOfferSnapshot} RequestOfferSnapshot\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestOfferSnapshot.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestOfferSnapshot message.\n         * @function verify\n         * @memberof tendermint.abci.RequestOfferSnapshot\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestOfferSnapshot.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.snapshot != null && message.hasOwnProperty(\"snapshot\")) {\n            var error = $root.tendermint.abci.Snapshot.verify(message.snapshot);\n            if (error) return \"snapshot.\" + error;\n          }\n\n          if (message.appHash != null && message.hasOwnProperty(\"appHash\")) if (!(message.appHash && typeof message.appHash.length === \"number\" || $util.isString(message.appHash))) return \"appHash: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestOfferSnapshot message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestOfferSnapshot\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestOfferSnapshot} RequestOfferSnapshot\n         */\n\n\n        RequestOfferSnapshot.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestOfferSnapshot) return object;\n          var message = new $root.tendermint.abci.RequestOfferSnapshot();\n\n          if (object.snapshot != null) {\n            if (typeof object.snapshot !== \"object\") throw TypeError(\".tendermint.abci.RequestOfferSnapshot.snapshot: object expected\");\n            message.snapshot = $root.tendermint.abci.Snapshot.fromObject(object.snapshot);\n          }\n\n          if (object.appHash != null) if (typeof object.appHash === \"string\") $util.base64.decode(object.appHash, message.appHash = $util.newBuffer($util.base64.length(object.appHash)), 0);else if (object.appHash.length) message.appHash = object.appHash;\n          return message;\n        };\n        /**\n         * Creates a plain object from a RequestOfferSnapshot message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestOfferSnapshot\n         * @static\n         * @param {tendermint.abci.RequestOfferSnapshot} message RequestOfferSnapshot\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestOfferSnapshot.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.snapshot = null;\n            if (options.bytes === String) object.appHash = \"\";else {\n              object.appHash = [];\n              if (options.bytes !== Array) object.appHash = $util.newBuffer(object.appHash);\n            }\n          }\n\n          if (message.snapshot != null && message.hasOwnProperty(\"snapshot\")) object.snapshot = $root.tendermint.abci.Snapshot.toObject(message.snapshot, options);\n          if (message.appHash != null && message.hasOwnProperty(\"appHash\")) object.appHash = options.bytes === String ? $util.base64.encode(message.appHash, 0, message.appHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.appHash) : message.appHash;\n          return object;\n        };\n        /**\n         * Converts this RequestOfferSnapshot to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestOfferSnapshot\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestOfferSnapshot.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestOfferSnapshot;\n      }();\n\n      abci.RequestLoadSnapshotChunk = function () {\n        /**\n         * Properties of a RequestLoadSnapshotChunk.\n         * @memberof tendermint.abci\n         * @interface IRequestLoadSnapshotChunk\n         * @property {number|Long|null} [height] RequestLoadSnapshotChunk height\n         * @property {number|null} [format] RequestLoadSnapshotChunk format\n         * @property {number|null} [chunk] RequestLoadSnapshotChunk chunk\n         */\n\n        /**\n         * Constructs a new RequestLoadSnapshotChunk.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestLoadSnapshotChunk.\n         * @implements IRequestLoadSnapshotChunk\n         * @constructor\n         * @param {tendermint.abci.IRequestLoadSnapshotChunk=} [properties] Properties to set\n         */\n        function RequestLoadSnapshotChunk(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * RequestLoadSnapshotChunk height.\n         * @member {number|Long} height\n         * @memberof tendermint.abci.RequestLoadSnapshotChunk\n         * @instance\n         */\n\n\n        RequestLoadSnapshotChunk.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        /**\n         * RequestLoadSnapshotChunk format.\n         * @member {number} format\n         * @memberof tendermint.abci.RequestLoadSnapshotChunk\n         * @instance\n         */\n\n        RequestLoadSnapshotChunk.prototype.format = 0;\n        /**\n         * RequestLoadSnapshotChunk chunk.\n         * @member {number} chunk\n         * @memberof tendermint.abci.RequestLoadSnapshotChunk\n         * @instance\n         */\n\n        RequestLoadSnapshotChunk.prototype.chunk = 0;\n        /**\n         * Creates a new RequestLoadSnapshotChunk instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestLoadSnapshotChunk\n         * @static\n         * @param {tendermint.abci.IRequestLoadSnapshotChunk=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestLoadSnapshotChunk} RequestLoadSnapshotChunk instance\n         */\n\n        RequestLoadSnapshotChunk.create = function create(properties) {\n          return new RequestLoadSnapshotChunk(properties);\n        };\n        /**\n         * Encodes the specified RequestLoadSnapshotChunk message. Does not implicitly {@link tendermint.abci.RequestLoadSnapshotChunk.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestLoadSnapshotChunk\n         * @static\n         * @param {tendermint.abci.IRequestLoadSnapshotChunk} message RequestLoadSnapshotChunk message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestLoadSnapshotChunk.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.height != null && Object.hasOwnProperty.call(message, \"height\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).uint64(message.height);\n          if (message.format != null && Object.hasOwnProperty.call(message, \"format\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).uint32(message.format);\n          if (message.chunk != null && Object.hasOwnProperty.call(message, \"chunk\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).uint32(message.chunk);\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestLoadSnapshotChunk message, length delimited. Does not implicitly {@link tendermint.abci.RequestLoadSnapshotChunk.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestLoadSnapshotChunk\n         * @static\n         * @param {tendermint.abci.IRequestLoadSnapshotChunk} message RequestLoadSnapshotChunk message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestLoadSnapshotChunk.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestLoadSnapshotChunk message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestLoadSnapshotChunk\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestLoadSnapshotChunk} RequestLoadSnapshotChunk\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestLoadSnapshotChunk.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestLoadSnapshotChunk();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.height = reader.uint64();\n                break;\n\n              case 2:\n                message.format = reader.uint32();\n                break;\n\n              case 3:\n                message.chunk = reader.uint32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestLoadSnapshotChunk message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestLoadSnapshotChunk\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestLoadSnapshotChunk} RequestLoadSnapshotChunk\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestLoadSnapshotChunk.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestLoadSnapshotChunk message.\n         * @function verify\n         * @memberof tendermint.abci.RequestLoadSnapshotChunk\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestLoadSnapshotChunk.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))) return \"height: integer|Long expected\";\n          if (message.format != null && message.hasOwnProperty(\"format\")) if (!$util.isInteger(message.format)) return \"format: integer expected\";\n          if (message.chunk != null && message.hasOwnProperty(\"chunk\")) if (!$util.isInteger(message.chunk)) return \"chunk: integer expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestLoadSnapshotChunk message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestLoadSnapshotChunk\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestLoadSnapshotChunk} RequestLoadSnapshotChunk\n         */\n\n\n        RequestLoadSnapshotChunk.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestLoadSnapshotChunk) return object;\n          var message = new $root.tendermint.abci.RequestLoadSnapshotChunk();\n          if (object.height != null) if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = true;else if (typeof object.height === \"string\") message.height = parseInt(object.height, 10);else if (typeof object.height === \"number\") message.height = object.height;else if (typeof object.height === \"object\") message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);\n          if (object.format != null) message.format = object.format >>> 0;\n          if (object.chunk != null) message.chunk = object.chunk >>> 0;\n          return message;\n        };\n        /**\n         * Creates a plain object from a RequestLoadSnapshotChunk message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestLoadSnapshotChunk\n         * @static\n         * @param {tendermint.abci.RequestLoadSnapshotChunk} message RequestLoadSnapshotChunk\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestLoadSnapshotChunk.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.height = options.longs === String ? \"0\" : 0;\n\n            object.format = 0;\n            object.chunk = 0;\n          }\n\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (typeof message.height === \"number\") object.height = options.longs === String ? String(message.height) : message.height;else object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;\n          if (message.format != null && message.hasOwnProperty(\"format\")) object.format = message.format;\n          if (message.chunk != null && message.hasOwnProperty(\"chunk\")) object.chunk = message.chunk;\n          return object;\n        };\n        /**\n         * Converts this RequestLoadSnapshotChunk to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestLoadSnapshotChunk\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestLoadSnapshotChunk.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestLoadSnapshotChunk;\n      }();\n\n      abci.RequestApplySnapshotChunk = function () {\n        /**\n         * Properties of a RequestApplySnapshotChunk.\n         * @memberof tendermint.abci\n         * @interface IRequestApplySnapshotChunk\n         * @property {number|null} [index] RequestApplySnapshotChunk index\n         * @property {Uint8Array|null} [chunk] RequestApplySnapshotChunk chunk\n         * @property {string|null} [sender] RequestApplySnapshotChunk sender\n         */\n\n        /**\n         * Constructs a new RequestApplySnapshotChunk.\n         * @memberof tendermint.abci\n         * @classdesc Represents a RequestApplySnapshotChunk.\n         * @implements IRequestApplySnapshotChunk\n         * @constructor\n         * @param {tendermint.abci.IRequestApplySnapshotChunk=} [properties] Properties to set\n         */\n        function RequestApplySnapshotChunk(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * RequestApplySnapshotChunk index.\n         * @member {number} index\n         * @memberof tendermint.abci.RequestApplySnapshotChunk\n         * @instance\n         */\n\n\n        RequestApplySnapshotChunk.prototype.index = 0;\n        /**\n         * RequestApplySnapshotChunk chunk.\n         * @member {Uint8Array} chunk\n         * @memberof tendermint.abci.RequestApplySnapshotChunk\n         * @instance\n         */\n\n        RequestApplySnapshotChunk.prototype.chunk = $util.newBuffer([]);\n        /**\n         * RequestApplySnapshotChunk sender.\n         * @member {string} sender\n         * @memberof tendermint.abci.RequestApplySnapshotChunk\n         * @instance\n         */\n\n        RequestApplySnapshotChunk.prototype.sender = \"\";\n        /**\n         * Creates a new RequestApplySnapshotChunk instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.RequestApplySnapshotChunk\n         * @static\n         * @param {tendermint.abci.IRequestApplySnapshotChunk=} [properties] Properties to set\n         * @returns {tendermint.abci.RequestApplySnapshotChunk} RequestApplySnapshotChunk instance\n         */\n\n        RequestApplySnapshotChunk.create = function create(properties) {\n          return new RequestApplySnapshotChunk(properties);\n        };\n        /**\n         * Encodes the specified RequestApplySnapshotChunk message. Does not implicitly {@link tendermint.abci.RequestApplySnapshotChunk.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.RequestApplySnapshotChunk\n         * @static\n         * @param {tendermint.abci.IRequestApplySnapshotChunk} message RequestApplySnapshotChunk message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestApplySnapshotChunk.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.index != null && Object.hasOwnProperty.call(message, \"index\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).uint32(message.index);\n          if (message.chunk != null && Object.hasOwnProperty.call(message, \"chunk\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.chunk);\n          if (message.sender != null && Object.hasOwnProperty.call(message, \"sender\")) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).string(message.sender);\n          return writer;\n        };\n        /**\n         * Encodes the specified RequestApplySnapshotChunk message, length delimited. Does not implicitly {@link tendermint.abci.RequestApplySnapshotChunk.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.RequestApplySnapshotChunk\n         * @static\n         * @param {tendermint.abci.IRequestApplySnapshotChunk} message RequestApplySnapshotChunk message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        RequestApplySnapshotChunk.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a RequestApplySnapshotChunk message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.RequestApplySnapshotChunk\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.RequestApplySnapshotChunk} RequestApplySnapshotChunk\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestApplySnapshotChunk.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.RequestApplySnapshotChunk();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.index = reader.uint32();\n                break;\n\n              case 2:\n                message.chunk = reader.bytes();\n                break;\n\n              case 3:\n                message.sender = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a RequestApplySnapshotChunk message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.RequestApplySnapshotChunk\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.RequestApplySnapshotChunk} RequestApplySnapshotChunk\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        RequestApplySnapshotChunk.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a RequestApplySnapshotChunk message.\n         * @function verify\n         * @memberof tendermint.abci.RequestApplySnapshotChunk\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        RequestApplySnapshotChunk.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.index != null && message.hasOwnProperty(\"index\")) if (!$util.isInteger(message.index)) return \"index: integer expected\";\n          if (message.chunk != null && message.hasOwnProperty(\"chunk\")) if (!(message.chunk && typeof message.chunk.length === \"number\" || $util.isString(message.chunk))) return \"chunk: buffer expected\";\n          if (message.sender != null && message.hasOwnProperty(\"sender\")) if (!$util.isString(message.sender)) return \"sender: string expected\";\n          return null;\n        };\n        /**\n         * Creates a RequestApplySnapshotChunk message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.RequestApplySnapshotChunk\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.RequestApplySnapshotChunk} RequestApplySnapshotChunk\n         */\n\n\n        RequestApplySnapshotChunk.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.RequestApplySnapshotChunk) return object;\n          var message = new $root.tendermint.abci.RequestApplySnapshotChunk();\n          if (object.index != null) message.index = object.index >>> 0;\n          if (object.chunk != null) if (typeof object.chunk === \"string\") $util.base64.decode(object.chunk, message.chunk = $util.newBuffer($util.base64.length(object.chunk)), 0);else if (object.chunk.length) message.chunk = object.chunk;\n          if (object.sender != null) message.sender = String(object.sender);\n          return message;\n        };\n        /**\n         * Creates a plain object from a RequestApplySnapshotChunk message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.RequestApplySnapshotChunk\n         * @static\n         * @param {tendermint.abci.RequestApplySnapshotChunk} message RequestApplySnapshotChunk\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        RequestApplySnapshotChunk.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.index = 0;\n            if (options.bytes === String) object.chunk = \"\";else {\n              object.chunk = [];\n              if (options.bytes !== Array) object.chunk = $util.newBuffer(object.chunk);\n            }\n            object.sender = \"\";\n          }\n\n          if (message.index != null && message.hasOwnProperty(\"index\")) object.index = message.index;\n          if (message.chunk != null && message.hasOwnProperty(\"chunk\")) object.chunk = options.bytes === String ? $util.base64.encode(message.chunk, 0, message.chunk.length) : options.bytes === Array ? Array.prototype.slice.call(message.chunk) : message.chunk;\n          if (message.sender != null && message.hasOwnProperty(\"sender\")) object.sender = message.sender;\n          return object;\n        };\n        /**\n         * Converts this RequestApplySnapshotChunk to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.RequestApplySnapshotChunk\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        RequestApplySnapshotChunk.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return RequestApplySnapshotChunk;\n      }();\n\n      abci.Response = function () {\n        /**\n         * Properties of a Response.\n         * @memberof tendermint.abci\n         * @interface IResponse\n         * @property {tendermint.abci.IResponseException|null} [exception] Response exception\n         * @property {tendermint.abci.IResponseEcho|null} [echo] Response echo\n         * @property {tendermint.abci.IResponseFlush|null} [flush] Response flush\n         * @property {tendermint.abci.IResponseInfo|null} [info] Response info\n         * @property {tendermint.abci.IResponseSetOption|null} [setOption] Response setOption\n         * @property {tendermint.abci.IResponseInitChain|null} [initChain] Response initChain\n         * @property {tendermint.abci.IResponseQuery|null} [query] Response query\n         * @property {tendermint.abci.IResponseBeginBlock|null} [beginBlock] Response beginBlock\n         * @property {tendermint.abci.IResponseCheckTx|null} [checkTx] Response checkTx\n         * @property {tendermint.abci.IResponseDeliverTx|null} [deliverTx] Response deliverTx\n         * @property {tendermint.abci.IResponseEndBlock|null} [endBlock] Response endBlock\n         * @property {tendermint.abci.IResponseCommit|null} [commit] Response commit\n         * @property {tendermint.abci.IResponseListSnapshots|null} [listSnapshots] Response listSnapshots\n         * @property {tendermint.abci.IResponseOfferSnapshot|null} [offerSnapshot] Response offerSnapshot\n         * @property {tendermint.abci.IResponseLoadSnapshotChunk|null} [loadSnapshotChunk] Response loadSnapshotChunk\n         * @property {tendermint.abci.IResponseApplySnapshotChunk|null} [applySnapshotChunk] Response applySnapshotChunk\n         */\n\n        /**\n         * Constructs a new Response.\n         * @memberof tendermint.abci\n         * @classdesc Represents a Response.\n         * @implements IResponse\n         * @constructor\n         * @param {tendermint.abci.IResponse=} [properties] Properties to set\n         */\n        function Response(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Response exception.\n         * @member {tendermint.abci.IResponseException|null|undefined} exception\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n\n        Response.prototype.exception = null;\n        /**\n         * Response echo.\n         * @member {tendermint.abci.IResponseEcho|null|undefined} echo\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.echo = null;\n        /**\n         * Response flush.\n         * @member {tendermint.abci.IResponseFlush|null|undefined} flush\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.flush = null;\n        /**\n         * Response info.\n         * @member {tendermint.abci.IResponseInfo|null|undefined} info\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.info = null;\n        /**\n         * Response setOption.\n         * @member {tendermint.abci.IResponseSetOption|null|undefined} setOption\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.setOption = null;\n        /**\n         * Response initChain.\n         * @member {tendermint.abci.IResponseInitChain|null|undefined} initChain\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.initChain = null;\n        /**\n         * Response query.\n         * @member {tendermint.abci.IResponseQuery|null|undefined} query\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.query = null;\n        /**\n         * Response beginBlock.\n         * @member {tendermint.abci.IResponseBeginBlock|null|undefined} beginBlock\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.beginBlock = null;\n        /**\n         * Response checkTx.\n         * @member {tendermint.abci.IResponseCheckTx|null|undefined} checkTx\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.checkTx = null;\n        /**\n         * Response deliverTx.\n         * @member {tendermint.abci.IResponseDeliverTx|null|undefined} deliverTx\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.deliverTx = null;\n        /**\n         * Response endBlock.\n         * @member {tendermint.abci.IResponseEndBlock|null|undefined} endBlock\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.endBlock = null;\n        /**\n         * Response commit.\n         * @member {tendermint.abci.IResponseCommit|null|undefined} commit\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.commit = null;\n        /**\n         * Response listSnapshots.\n         * @member {tendermint.abci.IResponseListSnapshots|null|undefined} listSnapshots\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.listSnapshots = null;\n        /**\n         * Response offerSnapshot.\n         * @member {tendermint.abci.IResponseOfferSnapshot|null|undefined} offerSnapshot\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.offerSnapshot = null;\n        /**\n         * Response loadSnapshotChunk.\n         * @member {tendermint.abci.IResponseLoadSnapshotChunk|null|undefined} loadSnapshotChunk\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.loadSnapshotChunk = null;\n        /**\n         * Response applySnapshotChunk.\n         * @member {tendermint.abci.IResponseApplySnapshotChunk|null|undefined} applySnapshotChunk\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Response.prototype.applySnapshotChunk = null; // OneOf field names bound to virtual getters and setters\n\n        var $oneOfFields;\n        /**\n         * Response value.\n         * @member {\"exception\"|\"echo\"|\"flush\"|\"info\"|\"setOption\"|\"initChain\"|\"query\"|\"beginBlock\"|\"checkTx\"|\"deliverTx\"|\"endBlock\"|\"commit\"|\"listSnapshots\"|\"offerSnapshot\"|\"loadSnapshotChunk\"|\"applySnapshotChunk\"|undefined} value\n         * @memberof tendermint.abci.Response\n         * @instance\n         */\n\n        Object.defineProperty(Response.prototype, \"value\", {\n          get: $util.oneOfGetter($oneOfFields = [\"exception\", \"echo\", \"flush\", \"info\", \"setOption\", \"initChain\", \"query\", \"beginBlock\", \"checkTx\", \"deliverTx\", \"endBlock\", \"commit\", \"listSnapshots\", \"offerSnapshot\", \"loadSnapshotChunk\", \"applySnapshotChunk\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        /**\n         * Creates a new Response instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.Response\n         * @static\n         * @param {tendermint.abci.IResponse=} [properties] Properties to set\n         * @returns {tendermint.abci.Response} Response instance\n         */\n\n        Response.create = function create(properties) {\n          return new Response(properties);\n        };\n        /**\n         * Encodes the specified Response message. Does not implicitly {@link tendermint.abci.Response.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.Response\n         * @static\n         * @param {tendermint.abci.IResponse} message Response message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Response.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.exception != null && Object.hasOwnProperty.call(message, \"exception\")) $root.tendermint.abci.ResponseException.encode(message.exception, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.echo != null && Object.hasOwnProperty.call(message, \"echo\")) $root.tendermint.abci.ResponseEcho.encode(message.echo, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          if (message.flush != null && Object.hasOwnProperty.call(message, \"flush\")) $root.tendermint.abci.ResponseFlush.encode(message.flush, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          if (message.info != null && Object.hasOwnProperty.call(message, \"info\")) $root.tendermint.abci.ResponseInfo.encode(message.info, writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).fork()).ldelim();\n          if (message.setOption != null && Object.hasOwnProperty.call(message, \"setOption\")) $root.tendermint.abci.ResponseSetOption.encode(message.setOption, writer.uint32(\n          /* id 5, wireType 2 =*/\n          42).fork()).ldelim();\n          if (message.initChain != null && Object.hasOwnProperty.call(message, \"initChain\")) $root.tendermint.abci.ResponseInitChain.encode(message.initChain, writer.uint32(\n          /* id 6, wireType 2 =*/\n          50).fork()).ldelim();\n          if (message.query != null && Object.hasOwnProperty.call(message, \"query\")) $root.tendermint.abci.ResponseQuery.encode(message.query, writer.uint32(\n          /* id 7, wireType 2 =*/\n          58).fork()).ldelim();\n          if (message.beginBlock != null && Object.hasOwnProperty.call(message, \"beginBlock\")) $root.tendermint.abci.ResponseBeginBlock.encode(message.beginBlock, writer.uint32(\n          /* id 8, wireType 2 =*/\n          66).fork()).ldelim();\n          if (message.checkTx != null && Object.hasOwnProperty.call(message, \"checkTx\")) $root.tendermint.abci.ResponseCheckTx.encode(message.checkTx, writer.uint32(\n          /* id 9, wireType 2 =*/\n          74).fork()).ldelim();\n          if (message.deliverTx != null && Object.hasOwnProperty.call(message, \"deliverTx\")) $root.tendermint.abci.ResponseDeliverTx.encode(message.deliverTx, writer.uint32(\n          /* id 10, wireType 2 =*/\n          82).fork()).ldelim();\n          if (message.endBlock != null && Object.hasOwnProperty.call(message, \"endBlock\")) $root.tendermint.abci.ResponseEndBlock.encode(message.endBlock, writer.uint32(\n          /* id 11, wireType 2 =*/\n          90).fork()).ldelim();\n          if (message.commit != null && Object.hasOwnProperty.call(message, \"commit\")) $root.tendermint.abci.ResponseCommit.encode(message.commit, writer.uint32(\n          /* id 12, wireType 2 =*/\n          98).fork()).ldelim();\n          if (message.listSnapshots != null && Object.hasOwnProperty.call(message, \"listSnapshots\")) $root.tendermint.abci.ResponseListSnapshots.encode(message.listSnapshots, writer.uint32(\n          /* id 13, wireType 2 =*/\n          106).fork()).ldelim();\n          if (message.offerSnapshot != null && Object.hasOwnProperty.call(message, \"offerSnapshot\")) $root.tendermint.abci.ResponseOfferSnapshot.encode(message.offerSnapshot, writer.uint32(\n          /* id 14, wireType 2 =*/\n          114).fork()).ldelim();\n          if (message.loadSnapshotChunk != null && Object.hasOwnProperty.call(message, \"loadSnapshotChunk\")) $root.tendermint.abci.ResponseLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(\n          /* id 15, wireType 2 =*/\n          122).fork()).ldelim();\n          if (message.applySnapshotChunk != null && Object.hasOwnProperty.call(message, \"applySnapshotChunk\")) $root.tendermint.abci.ResponseApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(\n          /* id 16, wireType 2 =*/\n          130).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified Response message, length delimited. Does not implicitly {@link tendermint.abci.Response.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.Response\n         * @static\n         * @param {tendermint.abci.IResponse} message Response message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Response.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Response message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.Response\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.Response} Response\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Response.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.Response();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.exception = $root.tendermint.abci.ResponseException.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.echo = $root.tendermint.abci.ResponseEcho.decode(reader, reader.uint32());\n                break;\n\n              case 3:\n                message.flush = $root.tendermint.abci.ResponseFlush.decode(reader, reader.uint32());\n                break;\n\n              case 4:\n                message.info = $root.tendermint.abci.ResponseInfo.decode(reader, reader.uint32());\n                break;\n\n              case 5:\n                message.setOption = $root.tendermint.abci.ResponseSetOption.decode(reader, reader.uint32());\n                break;\n\n              case 6:\n                message.initChain = $root.tendermint.abci.ResponseInitChain.decode(reader, reader.uint32());\n                break;\n\n              case 7:\n                message.query = $root.tendermint.abci.ResponseQuery.decode(reader, reader.uint32());\n                break;\n\n              case 8:\n                message.beginBlock = $root.tendermint.abci.ResponseBeginBlock.decode(reader, reader.uint32());\n                break;\n\n              case 9:\n                message.checkTx = $root.tendermint.abci.ResponseCheckTx.decode(reader, reader.uint32());\n                break;\n\n              case 10:\n                message.deliverTx = $root.tendermint.abci.ResponseDeliverTx.decode(reader, reader.uint32());\n                break;\n\n              case 11:\n                message.endBlock = $root.tendermint.abci.ResponseEndBlock.decode(reader, reader.uint32());\n                break;\n\n              case 12:\n                message.commit = $root.tendermint.abci.ResponseCommit.decode(reader, reader.uint32());\n                break;\n\n              case 13:\n                message.listSnapshots = $root.tendermint.abci.ResponseListSnapshots.decode(reader, reader.uint32());\n                break;\n\n              case 14:\n                message.offerSnapshot = $root.tendermint.abci.ResponseOfferSnapshot.decode(reader, reader.uint32());\n                break;\n\n              case 15:\n                message.loadSnapshotChunk = $root.tendermint.abci.ResponseLoadSnapshotChunk.decode(reader, reader.uint32());\n                break;\n\n              case 16:\n                message.applySnapshotChunk = $root.tendermint.abci.ResponseApplySnapshotChunk.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Response message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.Response\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.Response} Response\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Response.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Response message.\n         * @function verify\n         * @memberof tendermint.abci.Response\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Response.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          var properties = {};\n\n          if (message.exception != null && message.hasOwnProperty(\"exception\")) {\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseException.verify(message.exception);\n              if (error) return \"exception.\" + error;\n            }\n          }\n\n          if (message.echo != null && message.hasOwnProperty(\"echo\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseEcho.verify(message.echo);\n              if (error) return \"echo.\" + error;\n            }\n          }\n\n          if (message.flush != null && message.hasOwnProperty(\"flush\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseFlush.verify(message.flush);\n              if (error) return \"flush.\" + error;\n            }\n          }\n\n          if (message.info != null && message.hasOwnProperty(\"info\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseInfo.verify(message.info);\n              if (error) return \"info.\" + error;\n            }\n          }\n\n          if (message.setOption != null && message.hasOwnProperty(\"setOption\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseSetOption.verify(message.setOption);\n              if (error) return \"setOption.\" + error;\n            }\n          }\n\n          if (message.initChain != null && message.hasOwnProperty(\"initChain\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseInitChain.verify(message.initChain);\n              if (error) return \"initChain.\" + error;\n            }\n          }\n\n          if (message.query != null && message.hasOwnProperty(\"query\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseQuery.verify(message.query);\n              if (error) return \"query.\" + error;\n            }\n          }\n\n          if (message.beginBlock != null && message.hasOwnProperty(\"beginBlock\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseBeginBlock.verify(message.beginBlock);\n              if (error) return \"beginBlock.\" + error;\n            }\n          }\n\n          if (message.checkTx != null && message.hasOwnProperty(\"checkTx\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseCheckTx.verify(message.checkTx);\n              if (error) return \"checkTx.\" + error;\n            }\n          }\n\n          if (message.deliverTx != null && message.hasOwnProperty(\"deliverTx\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseDeliverTx.verify(message.deliverTx);\n              if (error) return \"deliverTx.\" + error;\n            }\n          }\n\n          if (message.endBlock != null && message.hasOwnProperty(\"endBlock\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseEndBlock.verify(message.endBlock);\n              if (error) return \"endBlock.\" + error;\n            }\n          }\n\n          if (message.commit != null && message.hasOwnProperty(\"commit\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseCommit.verify(message.commit);\n              if (error) return \"commit.\" + error;\n            }\n          }\n\n          if (message.listSnapshots != null && message.hasOwnProperty(\"listSnapshots\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseListSnapshots.verify(message.listSnapshots);\n              if (error) return \"listSnapshots.\" + error;\n            }\n          }\n\n          if (message.offerSnapshot != null && message.hasOwnProperty(\"offerSnapshot\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseOfferSnapshot.verify(message.offerSnapshot);\n              if (error) return \"offerSnapshot.\" + error;\n            }\n          }\n\n          if (message.loadSnapshotChunk != null && message.hasOwnProperty(\"loadSnapshotChunk\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseLoadSnapshotChunk.verify(message.loadSnapshotChunk);\n              if (error) return \"loadSnapshotChunk.\" + error;\n            }\n          }\n\n          if (message.applySnapshotChunk != null && message.hasOwnProperty(\"applySnapshotChunk\")) {\n            if (properties.value === 1) return \"value: multiple values\";\n            properties.value = 1;\n            {\n              var error = $root.tendermint.abci.ResponseApplySnapshotChunk.verify(message.applySnapshotChunk);\n              if (error) return \"applySnapshotChunk.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a Response message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.Response\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.Response} Response\n         */\n\n\n        Response.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.Response) return object;\n          var message = new $root.tendermint.abci.Response();\n\n          if (object.exception != null) {\n            if (typeof object.exception !== \"object\") throw TypeError(\".tendermint.abci.Response.exception: object expected\");\n            message.exception = $root.tendermint.abci.ResponseException.fromObject(object.exception);\n          }\n\n          if (object.echo != null) {\n            if (typeof object.echo !== \"object\") throw TypeError(\".tendermint.abci.Response.echo: object expected\");\n            message.echo = $root.tendermint.abci.ResponseEcho.fromObject(object.echo);\n          }\n\n          if (object.flush != null) {\n            if (typeof object.flush !== \"object\") throw TypeError(\".tendermint.abci.Response.flush: object expected\");\n            message.flush = $root.tendermint.abci.ResponseFlush.fromObject(object.flush);\n          }\n\n          if (object.info != null) {\n            if (typeof object.info !== \"object\") throw TypeError(\".tendermint.abci.Response.info: object expected\");\n            message.info = $root.tendermint.abci.ResponseInfo.fromObject(object.info);\n          }\n\n          if (object.setOption != null) {\n            if (typeof object.setOption !== \"object\") throw TypeError(\".tendermint.abci.Response.setOption: object expected\");\n            message.setOption = $root.tendermint.abci.ResponseSetOption.fromObject(object.setOption);\n          }\n\n          if (object.initChain != null) {\n            if (typeof object.initChain !== \"object\") throw TypeError(\".tendermint.abci.Response.initChain: object expected\");\n            message.initChain = $root.tendermint.abci.ResponseInitChain.fromObject(object.initChain);\n          }\n\n          if (object.query != null) {\n            if (typeof object.query !== \"object\") throw TypeError(\".tendermint.abci.Response.query: object expected\");\n            message.query = $root.tendermint.abci.ResponseQuery.fromObject(object.query);\n          }\n\n          if (object.beginBlock != null) {\n            if (typeof object.beginBlock !== \"object\") throw TypeError(\".tendermint.abci.Response.beginBlock: object expected\");\n            message.beginBlock = $root.tendermint.abci.ResponseBeginBlock.fromObject(object.beginBlock);\n          }\n\n          if (object.checkTx != null) {\n            if (typeof object.checkTx !== \"object\") throw TypeError(\".tendermint.abci.Response.checkTx: object expected\");\n            message.checkTx = $root.tendermint.abci.ResponseCheckTx.fromObject(object.checkTx);\n          }\n\n          if (object.deliverTx != null) {\n            if (typeof object.deliverTx !== \"object\") throw TypeError(\".tendermint.abci.Response.deliverTx: object expected\");\n            message.deliverTx = $root.tendermint.abci.ResponseDeliverTx.fromObject(object.deliverTx);\n          }\n\n          if (object.endBlock != null) {\n            if (typeof object.endBlock !== \"object\") throw TypeError(\".tendermint.abci.Response.endBlock: object expected\");\n            message.endBlock = $root.tendermint.abci.ResponseEndBlock.fromObject(object.endBlock);\n          }\n\n          if (object.commit != null) {\n            if (typeof object.commit !== \"object\") throw TypeError(\".tendermint.abci.Response.commit: object expected\");\n            message.commit = $root.tendermint.abci.ResponseCommit.fromObject(object.commit);\n          }\n\n          if (object.listSnapshots != null) {\n            if (typeof object.listSnapshots !== \"object\") throw TypeError(\".tendermint.abci.Response.listSnapshots: object expected\");\n            message.listSnapshots = $root.tendermint.abci.ResponseListSnapshots.fromObject(object.listSnapshots);\n          }\n\n          if (object.offerSnapshot != null) {\n            if (typeof object.offerSnapshot !== \"object\") throw TypeError(\".tendermint.abci.Response.offerSnapshot: object expected\");\n            message.offerSnapshot = $root.tendermint.abci.ResponseOfferSnapshot.fromObject(object.offerSnapshot);\n          }\n\n          if (object.loadSnapshotChunk != null) {\n            if (typeof object.loadSnapshotChunk !== \"object\") throw TypeError(\".tendermint.abci.Response.loadSnapshotChunk: object expected\");\n            message.loadSnapshotChunk = $root.tendermint.abci.ResponseLoadSnapshotChunk.fromObject(object.loadSnapshotChunk);\n          }\n\n          if (object.applySnapshotChunk != null) {\n            if (typeof object.applySnapshotChunk !== \"object\") throw TypeError(\".tendermint.abci.Response.applySnapshotChunk: object expected\");\n            message.applySnapshotChunk = $root.tendermint.abci.ResponseApplySnapshotChunk.fromObject(object.applySnapshotChunk);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a Response message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.Response\n         * @static\n         * @param {tendermint.abci.Response} message Response\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Response.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (message.exception != null && message.hasOwnProperty(\"exception\")) {\n            object.exception = $root.tendermint.abci.ResponseException.toObject(message.exception, options);\n            if (options.oneofs) object.value = \"exception\";\n          }\n\n          if (message.echo != null && message.hasOwnProperty(\"echo\")) {\n            object.echo = $root.tendermint.abci.ResponseEcho.toObject(message.echo, options);\n            if (options.oneofs) object.value = \"echo\";\n          }\n\n          if (message.flush != null && message.hasOwnProperty(\"flush\")) {\n            object.flush = $root.tendermint.abci.ResponseFlush.toObject(message.flush, options);\n            if (options.oneofs) object.value = \"flush\";\n          }\n\n          if (message.info != null && message.hasOwnProperty(\"info\")) {\n            object.info = $root.tendermint.abci.ResponseInfo.toObject(message.info, options);\n            if (options.oneofs) object.value = \"info\";\n          }\n\n          if (message.setOption != null && message.hasOwnProperty(\"setOption\")) {\n            object.setOption = $root.tendermint.abci.ResponseSetOption.toObject(message.setOption, options);\n            if (options.oneofs) object.value = \"setOption\";\n          }\n\n          if (message.initChain != null && message.hasOwnProperty(\"initChain\")) {\n            object.initChain = $root.tendermint.abci.ResponseInitChain.toObject(message.initChain, options);\n            if (options.oneofs) object.value = \"initChain\";\n          }\n\n          if (message.query != null && message.hasOwnProperty(\"query\")) {\n            object.query = $root.tendermint.abci.ResponseQuery.toObject(message.query, options);\n            if (options.oneofs) object.value = \"query\";\n          }\n\n          if (message.beginBlock != null && message.hasOwnProperty(\"beginBlock\")) {\n            object.beginBlock = $root.tendermint.abci.ResponseBeginBlock.toObject(message.beginBlock, options);\n            if (options.oneofs) object.value = \"beginBlock\";\n          }\n\n          if (message.checkTx != null && message.hasOwnProperty(\"checkTx\")) {\n            object.checkTx = $root.tendermint.abci.ResponseCheckTx.toObject(message.checkTx, options);\n            if (options.oneofs) object.value = \"checkTx\";\n          }\n\n          if (message.deliverTx != null && message.hasOwnProperty(\"deliverTx\")) {\n            object.deliverTx = $root.tendermint.abci.ResponseDeliverTx.toObject(message.deliverTx, options);\n            if (options.oneofs) object.value = \"deliverTx\";\n          }\n\n          if (message.endBlock != null && message.hasOwnProperty(\"endBlock\")) {\n            object.endBlock = $root.tendermint.abci.ResponseEndBlock.toObject(message.endBlock, options);\n            if (options.oneofs) object.value = \"endBlock\";\n          }\n\n          if (message.commit != null && message.hasOwnProperty(\"commit\")) {\n            object.commit = $root.tendermint.abci.ResponseCommit.toObject(message.commit, options);\n            if (options.oneofs) object.value = \"commit\";\n          }\n\n          if (message.listSnapshots != null && message.hasOwnProperty(\"listSnapshots\")) {\n            object.listSnapshots = $root.tendermint.abci.ResponseListSnapshots.toObject(message.listSnapshots, options);\n            if (options.oneofs) object.value = \"listSnapshots\";\n          }\n\n          if (message.offerSnapshot != null && message.hasOwnProperty(\"offerSnapshot\")) {\n            object.offerSnapshot = $root.tendermint.abci.ResponseOfferSnapshot.toObject(message.offerSnapshot, options);\n            if (options.oneofs) object.value = \"offerSnapshot\";\n          }\n\n          if (message.loadSnapshotChunk != null && message.hasOwnProperty(\"loadSnapshotChunk\")) {\n            object.loadSnapshotChunk = $root.tendermint.abci.ResponseLoadSnapshotChunk.toObject(message.loadSnapshotChunk, options);\n            if (options.oneofs) object.value = \"loadSnapshotChunk\";\n          }\n\n          if (message.applySnapshotChunk != null && message.hasOwnProperty(\"applySnapshotChunk\")) {\n            object.applySnapshotChunk = $root.tendermint.abci.ResponseApplySnapshotChunk.toObject(message.applySnapshotChunk, options);\n            if (options.oneofs) object.value = \"applySnapshotChunk\";\n          }\n\n          return object;\n        };\n        /**\n         * Converts this Response to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.Response\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Response.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Response;\n      }();\n\n      abci.ResponseException = function () {\n        /**\n         * Properties of a ResponseException.\n         * @memberof tendermint.abci\n         * @interface IResponseException\n         * @property {string|null} [error] ResponseException error\n         */\n\n        /**\n         * Constructs a new ResponseException.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseException.\n         * @implements IResponseException\n         * @constructor\n         * @param {tendermint.abci.IResponseException=} [properties] Properties to set\n         */\n        function ResponseException(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseException error.\n         * @member {string} error\n         * @memberof tendermint.abci.ResponseException\n         * @instance\n         */\n\n\n        ResponseException.prototype.error = \"\";\n        /**\n         * Creates a new ResponseException instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseException\n         * @static\n         * @param {tendermint.abci.IResponseException=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseException} ResponseException instance\n         */\n\n        ResponseException.create = function create(properties) {\n          return new ResponseException(properties);\n        };\n        /**\n         * Encodes the specified ResponseException message. Does not implicitly {@link tendermint.abci.ResponseException.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseException\n         * @static\n         * @param {tendermint.abci.IResponseException} message ResponseException message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseException.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.error != null && Object.hasOwnProperty.call(message, \"error\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.error);\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseException message, length delimited. Does not implicitly {@link tendermint.abci.ResponseException.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseException\n         * @static\n         * @param {tendermint.abci.IResponseException} message ResponseException message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseException.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseException message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseException\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseException} ResponseException\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseException.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseException();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.error = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseException message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseException\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseException} ResponseException\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseException.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseException message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseException\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseException.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.error != null && message.hasOwnProperty(\"error\")) if (!$util.isString(message.error)) return \"error: string expected\";\n          return null;\n        };\n        /**\n         * Creates a ResponseException message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseException\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseException} ResponseException\n         */\n\n\n        ResponseException.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseException) return object;\n          var message = new $root.tendermint.abci.ResponseException();\n          if (object.error != null) message.error = String(object.error);\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseException message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseException\n         * @static\n         * @param {tendermint.abci.ResponseException} message ResponseException\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseException.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.defaults) object.error = \"\";\n          if (message.error != null && message.hasOwnProperty(\"error\")) object.error = message.error;\n          return object;\n        };\n        /**\n         * Converts this ResponseException to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseException\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseException.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseException;\n      }();\n\n      abci.ResponseEcho = function () {\n        /**\n         * Properties of a ResponseEcho.\n         * @memberof tendermint.abci\n         * @interface IResponseEcho\n         * @property {string|null} [message] ResponseEcho message\n         */\n\n        /**\n         * Constructs a new ResponseEcho.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseEcho.\n         * @implements IResponseEcho\n         * @constructor\n         * @param {tendermint.abci.IResponseEcho=} [properties] Properties to set\n         */\n        function ResponseEcho(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseEcho message.\n         * @member {string} message\n         * @memberof tendermint.abci.ResponseEcho\n         * @instance\n         */\n\n\n        ResponseEcho.prototype.message = \"\";\n        /**\n         * Creates a new ResponseEcho instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseEcho\n         * @static\n         * @param {tendermint.abci.IResponseEcho=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseEcho} ResponseEcho instance\n         */\n\n        ResponseEcho.create = function create(properties) {\n          return new ResponseEcho(properties);\n        };\n        /**\n         * Encodes the specified ResponseEcho message. Does not implicitly {@link tendermint.abci.ResponseEcho.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseEcho\n         * @static\n         * @param {tendermint.abci.IResponseEcho} message ResponseEcho message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseEcho.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.message != null && Object.hasOwnProperty.call(message, \"message\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.message);\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseEcho message, length delimited. Does not implicitly {@link tendermint.abci.ResponseEcho.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseEcho\n         * @static\n         * @param {tendermint.abci.IResponseEcho} message ResponseEcho message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseEcho.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseEcho message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseEcho\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseEcho} ResponseEcho\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseEcho.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseEcho();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.message = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseEcho message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseEcho\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseEcho} ResponseEcho\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseEcho.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseEcho message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseEcho\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseEcho.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.message != null && message.hasOwnProperty(\"message\")) if (!$util.isString(message.message)) return \"message: string expected\";\n          return null;\n        };\n        /**\n         * Creates a ResponseEcho message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseEcho\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseEcho} ResponseEcho\n         */\n\n\n        ResponseEcho.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseEcho) return object;\n          var message = new $root.tendermint.abci.ResponseEcho();\n          if (object.message != null) message.message = String(object.message);\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseEcho message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseEcho\n         * @static\n         * @param {tendermint.abci.ResponseEcho} message ResponseEcho\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseEcho.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.defaults) object.message = \"\";\n          if (message.message != null && message.hasOwnProperty(\"message\")) object.message = message.message;\n          return object;\n        };\n        /**\n         * Converts this ResponseEcho to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseEcho\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseEcho.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseEcho;\n      }();\n\n      abci.ResponseFlush = function () {\n        /**\n         * Properties of a ResponseFlush.\n         * @memberof tendermint.abci\n         * @interface IResponseFlush\n         */\n\n        /**\n         * Constructs a new ResponseFlush.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseFlush.\n         * @implements IResponseFlush\n         * @constructor\n         * @param {tendermint.abci.IResponseFlush=} [properties] Properties to set\n         */\n        function ResponseFlush(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Creates a new ResponseFlush instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseFlush\n         * @static\n         * @param {tendermint.abci.IResponseFlush=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseFlush} ResponseFlush instance\n         */\n\n\n        ResponseFlush.create = function create(properties) {\n          return new ResponseFlush(properties);\n        };\n        /**\n         * Encodes the specified ResponseFlush message. Does not implicitly {@link tendermint.abci.ResponseFlush.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseFlush\n         * @static\n         * @param {tendermint.abci.IResponseFlush} message ResponseFlush message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseFlush.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseFlush message, length delimited. Does not implicitly {@link tendermint.abci.ResponseFlush.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseFlush\n         * @static\n         * @param {tendermint.abci.IResponseFlush} message ResponseFlush message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseFlush.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseFlush message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseFlush\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseFlush} ResponseFlush\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseFlush.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseFlush();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseFlush message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseFlush\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseFlush} ResponseFlush\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseFlush.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseFlush message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseFlush\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseFlush.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          return null;\n        };\n        /**\n         * Creates a ResponseFlush message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseFlush\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseFlush} ResponseFlush\n         */\n\n\n        ResponseFlush.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseFlush) return object;\n          return new $root.tendermint.abci.ResponseFlush();\n        };\n        /**\n         * Creates a plain object from a ResponseFlush message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseFlush\n         * @static\n         * @param {tendermint.abci.ResponseFlush} message ResponseFlush\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseFlush.toObject = function toObject() {\n          return {};\n        };\n        /**\n         * Converts this ResponseFlush to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseFlush\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseFlush.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseFlush;\n      }();\n\n      abci.ResponseInfo = function () {\n        /**\n         * Properties of a ResponseInfo.\n         * @memberof tendermint.abci\n         * @interface IResponseInfo\n         * @property {string|null} [data] ResponseInfo data\n         * @property {string|null} [version] ResponseInfo version\n         * @property {number|Long|null} [appVersion] ResponseInfo appVersion\n         * @property {number|Long|null} [lastBlockHeight] ResponseInfo lastBlockHeight\n         * @property {Uint8Array|null} [lastBlockAppHash] ResponseInfo lastBlockAppHash\n         */\n\n        /**\n         * Constructs a new ResponseInfo.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseInfo.\n         * @implements IResponseInfo\n         * @constructor\n         * @param {tendermint.abci.IResponseInfo=} [properties] Properties to set\n         */\n        function ResponseInfo(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseInfo data.\n         * @member {string} data\n         * @memberof tendermint.abci.ResponseInfo\n         * @instance\n         */\n\n\n        ResponseInfo.prototype.data = \"\";\n        /**\n         * ResponseInfo version.\n         * @member {string} version\n         * @memberof tendermint.abci.ResponseInfo\n         * @instance\n         */\n\n        ResponseInfo.prototype.version = \"\";\n        /**\n         * ResponseInfo appVersion.\n         * @member {number|Long} appVersion\n         * @memberof tendermint.abci.ResponseInfo\n         * @instance\n         */\n\n        ResponseInfo.prototype.appVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        /**\n         * ResponseInfo lastBlockHeight.\n         * @member {number|Long} lastBlockHeight\n         * @memberof tendermint.abci.ResponseInfo\n         * @instance\n         */\n\n        ResponseInfo.prototype.lastBlockHeight = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * ResponseInfo lastBlockAppHash.\n         * @member {Uint8Array} lastBlockAppHash\n         * @memberof tendermint.abci.ResponseInfo\n         * @instance\n         */\n\n        ResponseInfo.prototype.lastBlockAppHash = $util.newBuffer([]);\n        /**\n         * Creates a new ResponseInfo instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseInfo\n         * @static\n         * @param {tendermint.abci.IResponseInfo=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseInfo} ResponseInfo instance\n         */\n\n        ResponseInfo.create = function create(properties) {\n          return new ResponseInfo(properties);\n        };\n        /**\n         * Encodes the specified ResponseInfo message. Does not implicitly {@link tendermint.abci.ResponseInfo.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseInfo\n         * @static\n         * @param {tendermint.abci.IResponseInfo} message ResponseInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseInfo.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.data);\n          if (message.version != null && Object.hasOwnProperty.call(message, \"version\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).string(message.version);\n          if (message.appVersion != null && Object.hasOwnProperty.call(message, \"appVersion\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).uint64(message.appVersion);\n          if (message.lastBlockHeight != null && Object.hasOwnProperty.call(message, \"lastBlockHeight\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).int64(message.lastBlockHeight);\n          if (message.lastBlockAppHash != null && Object.hasOwnProperty.call(message, \"lastBlockAppHash\")) writer.uint32(\n          /* id 5, wireType 2 =*/\n          42).bytes(message.lastBlockAppHash);\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseInfo message, length delimited. Does not implicitly {@link tendermint.abci.ResponseInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseInfo\n         * @static\n         * @param {tendermint.abci.IResponseInfo} message ResponseInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseInfo.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseInfo} ResponseInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseInfo.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseInfo();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.data = reader.string();\n                break;\n\n              case 2:\n                message.version = reader.string();\n                break;\n\n              case 3:\n                message.appVersion = reader.uint64();\n                break;\n\n              case 4:\n                message.lastBlockHeight = reader.int64();\n                break;\n\n              case 5:\n                message.lastBlockAppHash = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseInfo} ResponseInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseInfo.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseInfo message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseInfo.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.data != null && message.hasOwnProperty(\"data\")) if (!$util.isString(message.data)) return \"data: string expected\";\n          if (message.version != null && message.hasOwnProperty(\"version\")) if (!$util.isString(message.version)) return \"version: string expected\";\n          if (message.appVersion != null && message.hasOwnProperty(\"appVersion\")) if (!$util.isInteger(message.appVersion) && !(message.appVersion && $util.isInteger(message.appVersion.low) && $util.isInteger(message.appVersion.high))) return \"appVersion: integer|Long expected\";\n          if (message.lastBlockHeight != null && message.hasOwnProperty(\"lastBlockHeight\")) if (!$util.isInteger(message.lastBlockHeight) && !(message.lastBlockHeight && $util.isInteger(message.lastBlockHeight.low) && $util.isInteger(message.lastBlockHeight.high))) return \"lastBlockHeight: integer|Long expected\";\n          if (message.lastBlockAppHash != null && message.hasOwnProperty(\"lastBlockAppHash\")) if (!(message.lastBlockAppHash && typeof message.lastBlockAppHash.length === \"number\" || $util.isString(message.lastBlockAppHash))) return \"lastBlockAppHash: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates a ResponseInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseInfo} ResponseInfo\n         */\n\n\n        ResponseInfo.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseInfo) return object;\n          var message = new $root.tendermint.abci.ResponseInfo();\n          if (object.data != null) message.data = String(object.data);\n          if (object.version != null) message.version = String(object.version);\n          if (object.appVersion != null) if ($util.Long) (message.appVersion = $util.Long.fromValue(object.appVersion)).unsigned = true;else if (typeof object.appVersion === \"string\") message.appVersion = parseInt(object.appVersion, 10);else if (typeof object.appVersion === \"number\") message.appVersion = object.appVersion;else if (typeof object.appVersion === \"object\") message.appVersion = new $util.LongBits(object.appVersion.low >>> 0, object.appVersion.high >>> 0).toNumber(true);\n          if (object.lastBlockHeight != null) if ($util.Long) (message.lastBlockHeight = $util.Long.fromValue(object.lastBlockHeight)).unsigned = false;else if (typeof object.lastBlockHeight === \"string\") message.lastBlockHeight = parseInt(object.lastBlockHeight, 10);else if (typeof object.lastBlockHeight === \"number\") message.lastBlockHeight = object.lastBlockHeight;else if (typeof object.lastBlockHeight === \"object\") message.lastBlockHeight = new $util.LongBits(object.lastBlockHeight.low >>> 0, object.lastBlockHeight.high >>> 0).toNumber();\n          if (object.lastBlockAppHash != null) if (typeof object.lastBlockAppHash === \"string\") $util.base64.decode(object.lastBlockAppHash, message.lastBlockAppHash = $util.newBuffer($util.base64.length(object.lastBlockAppHash)), 0);else if (object.lastBlockAppHash.length) message.lastBlockAppHash = object.lastBlockAppHash;\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseInfo\n         * @static\n         * @param {tendermint.abci.ResponseInfo} message ResponseInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseInfo.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.data = \"\";\n            object.version = \"\";\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.appVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.appVersion = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.lastBlockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.lastBlockHeight = options.longs === String ? \"0\" : 0;\n\n            if (options.bytes === String) object.lastBlockAppHash = \"\";else {\n              object.lastBlockAppHash = [];\n              if (options.bytes !== Array) object.lastBlockAppHash = $util.newBuffer(object.lastBlockAppHash);\n            }\n          }\n\n          if (message.data != null && message.hasOwnProperty(\"data\")) object.data = message.data;\n          if (message.version != null && message.hasOwnProperty(\"version\")) object.version = message.version;\n          if (message.appVersion != null && message.hasOwnProperty(\"appVersion\")) if (typeof message.appVersion === \"number\") object.appVersion = options.longs === String ? String(message.appVersion) : message.appVersion;else object.appVersion = options.longs === String ? $util.Long.prototype.toString.call(message.appVersion) : options.longs === Number ? new $util.LongBits(message.appVersion.low >>> 0, message.appVersion.high >>> 0).toNumber(true) : message.appVersion;\n          if (message.lastBlockHeight != null && message.hasOwnProperty(\"lastBlockHeight\")) if (typeof message.lastBlockHeight === \"number\") object.lastBlockHeight = options.longs === String ? String(message.lastBlockHeight) : message.lastBlockHeight;else object.lastBlockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.lastBlockHeight) : options.longs === Number ? new $util.LongBits(message.lastBlockHeight.low >>> 0, message.lastBlockHeight.high >>> 0).toNumber() : message.lastBlockHeight;\n          if (message.lastBlockAppHash != null && message.hasOwnProperty(\"lastBlockAppHash\")) object.lastBlockAppHash = options.bytes === String ? $util.base64.encode(message.lastBlockAppHash, 0, message.lastBlockAppHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.lastBlockAppHash) : message.lastBlockAppHash;\n          return object;\n        };\n        /**\n         * Converts this ResponseInfo to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseInfo.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseInfo;\n      }();\n\n      abci.ResponseSetOption = function () {\n        /**\n         * Properties of a ResponseSetOption.\n         * @memberof tendermint.abci\n         * @interface IResponseSetOption\n         * @property {number|null} [code] ResponseSetOption code\n         * @property {string|null} [log] ResponseSetOption log\n         * @property {string|null} [info] ResponseSetOption info\n         */\n\n        /**\n         * Constructs a new ResponseSetOption.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseSetOption.\n         * @implements IResponseSetOption\n         * @constructor\n         * @param {tendermint.abci.IResponseSetOption=} [properties] Properties to set\n         */\n        function ResponseSetOption(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseSetOption code.\n         * @member {number} code\n         * @memberof tendermint.abci.ResponseSetOption\n         * @instance\n         */\n\n\n        ResponseSetOption.prototype.code = 0;\n        /**\n         * ResponseSetOption log.\n         * @member {string} log\n         * @memberof tendermint.abci.ResponseSetOption\n         * @instance\n         */\n\n        ResponseSetOption.prototype.log = \"\";\n        /**\n         * ResponseSetOption info.\n         * @member {string} info\n         * @memberof tendermint.abci.ResponseSetOption\n         * @instance\n         */\n\n        ResponseSetOption.prototype.info = \"\";\n        /**\n         * Creates a new ResponseSetOption instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseSetOption\n         * @static\n         * @param {tendermint.abci.IResponseSetOption=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseSetOption} ResponseSetOption instance\n         */\n\n        ResponseSetOption.create = function create(properties) {\n          return new ResponseSetOption(properties);\n        };\n        /**\n         * Encodes the specified ResponseSetOption message. Does not implicitly {@link tendermint.abci.ResponseSetOption.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseSetOption\n         * @static\n         * @param {tendermint.abci.IResponseSetOption} message ResponseSetOption message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseSetOption.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.code != null && Object.hasOwnProperty.call(message, \"code\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).uint32(message.code);\n          if (message.log != null && Object.hasOwnProperty.call(message, \"log\")) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).string(message.log);\n          if (message.info != null && Object.hasOwnProperty.call(message, \"info\")) writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).string(message.info);\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseSetOption message, length delimited. Does not implicitly {@link tendermint.abci.ResponseSetOption.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseSetOption\n         * @static\n         * @param {tendermint.abci.IResponseSetOption} message ResponseSetOption message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseSetOption.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseSetOption message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseSetOption\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseSetOption} ResponseSetOption\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseSetOption.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseSetOption();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.code = reader.uint32();\n                break;\n\n              case 3:\n                message.log = reader.string();\n                break;\n\n              case 4:\n                message.info = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseSetOption message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseSetOption\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseSetOption} ResponseSetOption\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseSetOption.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseSetOption message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseSetOption\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseSetOption.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.code != null && message.hasOwnProperty(\"code\")) if (!$util.isInteger(message.code)) return \"code: integer expected\";\n          if (message.log != null && message.hasOwnProperty(\"log\")) if (!$util.isString(message.log)) return \"log: string expected\";\n          if (message.info != null && message.hasOwnProperty(\"info\")) if (!$util.isString(message.info)) return \"info: string expected\";\n          return null;\n        };\n        /**\n         * Creates a ResponseSetOption message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseSetOption\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseSetOption} ResponseSetOption\n         */\n\n\n        ResponseSetOption.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseSetOption) return object;\n          var message = new $root.tendermint.abci.ResponseSetOption();\n          if (object.code != null) message.code = object.code >>> 0;\n          if (object.log != null) message.log = String(object.log);\n          if (object.info != null) message.info = String(object.info);\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseSetOption message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseSetOption\n         * @static\n         * @param {tendermint.abci.ResponseSetOption} message ResponseSetOption\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseSetOption.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.code = 0;\n            object.log = \"\";\n            object.info = \"\";\n          }\n\n          if (message.code != null && message.hasOwnProperty(\"code\")) object.code = message.code;\n          if (message.log != null && message.hasOwnProperty(\"log\")) object.log = message.log;\n          if (message.info != null && message.hasOwnProperty(\"info\")) object.info = message.info;\n          return object;\n        };\n        /**\n         * Converts this ResponseSetOption to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseSetOption\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseSetOption.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseSetOption;\n      }();\n\n      abci.ResponseInitChain = function () {\n        /**\n         * Properties of a ResponseInitChain.\n         * @memberof tendermint.abci\n         * @interface IResponseInitChain\n         * @property {tendermint.abci.IConsensusParams|null} [consensusParams] ResponseInitChain consensusParams\n         * @property {Array.<tendermint.abci.IValidatorUpdate>|null} [validators] ResponseInitChain validators\n         * @property {Uint8Array|null} [appHash] ResponseInitChain appHash\n         */\n\n        /**\n         * Constructs a new ResponseInitChain.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseInitChain.\n         * @implements IResponseInitChain\n         * @constructor\n         * @param {tendermint.abci.IResponseInitChain=} [properties] Properties to set\n         */\n        function ResponseInitChain(properties) {\n          this.validators = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseInitChain consensusParams.\n         * @member {tendermint.abci.IConsensusParams|null|undefined} consensusParams\n         * @memberof tendermint.abci.ResponseInitChain\n         * @instance\n         */\n\n\n        ResponseInitChain.prototype.consensusParams = null;\n        /**\n         * ResponseInitChain validators.\n         * @member {Array.<tendermint.abci.IValidatorUpdate>} validators\n         * @memberof tendermint.abci.ResponseInitChain\n         * @instance\n         */\n\n        ResponseInitChain.prototype.validators = $util.emptyArray;\n        /**\n         * ResponseInitChain appHash.\n         * @member {Uint8Array} appHash\n         * @memberof tendermint.abci.ResponseInitChain\n         * @instance\n         */\n\n        ResponseInitChain.prototype.appHash = $util.newBuffer([]);\n        /**\n         * Creates a new ResponseInitChain instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseInitChain\n         * @static\n         * @param {tendermint.abci.IResponseInitChain=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseInitChain} ResponseInitChain instance\n         */\n\n        ResponseInitChain.create = function create(properties) {\n          return new ResponseInitChain(properties);\n        };\n        /**\n         * Encodes the specified ResponseInitChain message. Does not implicitly {@link tendermint.abci.ResponseInitChain.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseInitChain\n         * @static\n         * @param {tendermint.abci.IResponseInitChain} message ResponseInitChain message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseInitChain.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.consensusParams != null && Object.hasOwnProperty.call(message, \"consensusParams\")) $root.tendermint.abci.ConsensusParams.encode(message.consensusParams, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.validators != null && message.validators.length) for (var i = 0; i < message.validators.length; ++i) {\n            $root.tendermint.abci.ValidatorUpdate.encode(message.validators[i], writer.uint32(\n            /* id 2, wireType 2 =*/\n            18).fork()).ldelim();\n          }\n          if (message.appHash != null && Object.hasOwnProperty.call(message, \"appHash\")) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).bytes(message.appHash);\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseInitChain message, length delimited. Does not implicitly {@link tendermint.abci.ResponseInitChain.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseInitChain\n         * @static\n         * @param {tendermint.abci.IResponseInitChain} message ResponseInitChain message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseInitChain.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseInitChain message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseInitChain\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseInitChain} ResponseInitChain\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseInitChain.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseInitChain();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.consensusParams = $root.tendermint.abci.ConsensusParams.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                if (!(message.validators && message.validators.length)) message.validators = [];\n                message.validators.push($root.tendermint.abci.ValidatorUpdate.decode(reader, reader.uint32()));\n                break;\n\n              case 3:\n                message.appHash = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseInitChain message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseInitChain\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseInitChain} ResponseInitChain\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseInitChain.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseInitChain message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseInitChain\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseInitChain.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.consensusParams != null && message.hasOwnProperty(\"consensusParams\")) {\n            var error = $root.tendermint.abci.ConsensusParams.verify(message.consensusParams);\n            if (error) return \"consensusParams.\" + error;\n          }\n\n          if (message.validators != null && message.hasOwnProperty(\"validators\")) {\n            if (!Array.isArray(message.validators)) return \"validators: array expected\";\n\n            for (var i = 0; i < message.validators.length; ++i) {\n              var error = $root.tendermint.abci.ValidatorUpdate.verify(message.validators[i]);\n              if (error) return \"validators.\" + error;\n            }\n          }\n\n          if (message.appHash != null && message.hasOwnProperty(\"appHash\")) if (!(message.appHash && typeof message.appHash.length === \"number\" || $util.isString(message.appHash))) return \"appHash: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates a ResponseInitChain message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseInitChain\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseInitChain} ResponseInitChain\n         */\n\n\n        ResponseInitChain.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseInitChain) return object;\n          var message = new $root.tendermint.abci.ResponseInitChain();\n\n          if (object.consensusParams != null) {\n            if (typeof object.consensusParams !== \"object\") throw TypeError(\".tendermint.abci.ResponseInitChain.consensusParams: object expected\");\n            message.consensusParams = $root.tendermint.abci.ConsensusParams.fromObject(object.consensusParams);\n          }\n\n          if (object.validators) {\n            if (!Array.isArray(object.validators)) throw TypeError(\".tendermint.abci.ResponseInitChain.validators: array expected\");\n            message.validators = [];\n\n            for (var i = 0; i < object.validators.length; ++i) {\n              if (typeof object.validators[i] !== \"object\") throw TypeError(\".tendermint.abci.ResponseInitChain.validators: object expected\");\n              message.validators[i] = $root.tendermint.abci.ValidatorUpdate.fromObject(object.validators[i]);\n            }\n          }\n\n          if (object.appHash != null) if (typeof object.appHash === \"string\") $util.base64.decode(object.appHash, message.appHash = $util.newBuffer($util.base64.length(object.appHash)), 0);else if (object.appHash.length) message.appHash = object.appHash;\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseInitChain message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseInitChain\n         * @static\n         * @param {tendermint.abci.ResponseInitChain} message ResponseInitChain\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseInitChain.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.validators = [];\n\n          if (options.defaults) {\n            object.consensusParams = null;\n            if (options.bytes === String) object.appHash = \"\";else {\n              object.appHash = [];\n              if (options.bytes !== Array) object.appHash = $util.newBuffer(object.appHash);\n            }\n          }\n\n          if (message.consensusParams != null && message.hasOwnProperty(\"consensusParams\")) object.consensusParams = $root.tendermint.abci.ConsensusParams.toObject(message.consensusParams, options);\n\n          if (message.validators && message.validators.length) {\n            object.validators = [];\n\n            for (var j = 0; j < message.validators.length; ++j) {\n              object.validators[j] = $root.tendermint.abci.ValidatorUpdate.toObject(message.validators[j], options);\n            }\n          }\n\n          if (message.appHash != null && message.hasOwnProperty(\"appHash\")) object.appHash = options.bytes === String ? $util.base64.encode(message.appHash, 0, message.appHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.appHash) : message.appHash;\n          return object;\n        };\n        /**\n         * Converts this ResponseInitChain to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseInitChain\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseInitChain.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseInitChain;\n      }();\n\n      abci.ResponseQuery = function () {\n        /**\n         * Properties of a ResponseQuery.\n         * @memberof tendermint.abci\n         * @interface IResponseQuery\n         * @property {number|null} [code] ResponseQuery code\n         * @property {string|null} [log] ResponseQuery log\n         * @property {string|null} [info] ResponseQuery info\n         * @property {number|Long|null} [index] ResponseQuery index\n         * @property {Uint8Array|null} [key] ResponseQuery key\n         * @property {Uint8Array|null} [value] ResponseQuery value\n         * @property {tendermint.crypto.IProofOps|null} [proofOps] ResponseQuery proofOps\n         * @property {number|Long|null} [height] ResponseQuery height\n         * @property {string|null} [codespace] ResponseQuery codespace\n         */\n\n        /**\n         * Constructs a new ResponseQuery.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseQuery.\n         * @implements IResponseQuery\n         * @constructor\n         * @param {tendermint.abci.IResponseQuery=} [properties] Properties to set\n         */\n        function ResponseQuery(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseQuery code.\n         * @member {number} code\n         * @memberof tendermint.abci.ResponseQuery\n         * @instance\n         */\n\n\n        ResponseQuery.prototype.code = 0;\n        /**\n         * ResponseQuery log.\n         * @member {string} log\n         * @memberof tendermint.abci.ResponseQuery\n         * @instance\n         */\n\n        ResponseQuery.prototype.log = \"\";\n        /**\n         * ResponseQuery info.\n         * @member {string} info\n         * @memberof tendermint.abci.ResponseQuery\n         * @instance\n         */\n\n        ResponseQuery.prototype.info = \"\";\n        /**\n         * ResponseQuery index.\n         * @member {number|Long} index\n         * @memberof tendermint.abci.ResponseQuery\n         * @instance\n         */\n\n        ResponseQuery.prototype.index = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * ResponseQuery key.\n         * @member {Uint8Array} key\n         * @memberof tendermint.abci.ResponseQuery\n         * @instance\n         */\n\n        ResponseQuery.prototype.key = $util.newBuffer([]);\n        /**\n         * ResponseQuery value.\n         * @member {Uint8Array} value\n         * @memberof tendermint.abci.ResponseQuery\n         * @instance\n         */\n\n        ResponseQuery.prototype.value = $util.newBuffer([]);\n        /**\n         * ResponseQuery proofOps.\n         * @member {tendermint.crypto.IProofOps|null|undefined} proofOps\n         * @memberof tendermint.abci.ResponseQuery\n         * @instance\n         */\n\n        ResponseQuery.prototype.proofOps = null;\n        /**\n         * ResponseQuery height.\n         * @member {number|Long} height\n         * @memberof tendermint.abci.ResponseQuery\n         * @instance\n         */\n\n        ResponseQuery.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * ResponseQuery codespace.\n         * @member {string} codespace\n         * @memberof tendermint.abci.ResponseQuery\n         * @instance\n         */\n\n        ResponseQuery.prototype.codespace = \"\";\n        /**\n         * Creates a new ResponseQuery instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseQuery\n         * @static\n         * @param {tendermint.abci.IResponseQuery=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseQuery} ResponseQuery instance\n         */\n\n        ResponseQuery.create = function create(properties) {\n          return new ResponseQuery(properties);\n        };\n        /**\n         * Encodes the specified ResponseQuery message. Does not implicitly {@link tendermint.abci.ResponseQuery.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseQuery\n         * @static\n         * @param {tendermint.abci.IResponseQuery} message ResponseQuery message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseQuery.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.code != null && Object.hasOwnProperty.call(message, \"code\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).uint32(message.code);\n          if (message.log != null && Object.hasOwnProperty.call(message, \"log\")) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).string(message.log);\n          if (message.info != null && Object.hasOwnProperty.call(message, \"info\")) writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).string(message.info);\n          if (message.index != null && Object.hasOwnProperty.call(message, \"index\")) writer.uint32(\n          /* id 5, wireType 0 =*/\n          40).int64(message.index);\n          if (message.key != null && Object.hasOwnProperty.call(message, \"key\")) writer.uint32(\n          /* id 6, wireType 2 =*/\n          50).bytes(message.key);\n          if (message.value != null && Object.hasOwnProperty.call(message, \"value\")) writer.uint32(\n          /* id 7, wireType 2 =*/\n          58).bytes(message.value);\n          if (message.proofOps != null && Object.hasOwnProperty.call(message, \"proofOps\")) $root.tendermint.crypto.ProofOps.encode(message.proofOps, writer.uint32(\n          /* id 8, wireType 2 =*/\n          66).fork()).ldelim();\n          if (message.height != null && Object.hasOwnProperty.call(message, \"height\")) writer.uint32(\n          /* id 9, wireType 0 =*/\n          72).int64(message.height);\n          if (message.codespace != null && Object.hasOwnProperty.call(message, \"codespace\")) writer.uint32(\n          /* id 10, wireType 2 =*/\n          82).string(message.codespace);\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseQuery message, length delimited. Does not implicitly {@link tendermint.abci.ResponseQuery.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseQuery\n         * @static\n         * @param {tendermint.abci.IResponseQuery} message ResponseQuery message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseQuery.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseQuery message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseQuery\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseQuery} ResponseQuery\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseQuery.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseQuery();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.code = reader.uint32();\n                break;\n\n              case 3:\n                message.log = reader.string();\n                break;\n\n              case 4:\n                message.info = reader.string();\n                break;\n\n              case 5:\n                message.index = reader.int64();\n                break;\n\n              case 6:\n                message.key = reader.bytes();\n                break;\n\n              case 7:\n                message.value = reader.bytes();\n                break;\n\n              case 8:\n                message.proofOps = $root.tendermint.crypto.ProofOps.decode(reader, reader.uint32());\n                break;\n\n              case 9:\n                message.height = reader.int64();\n                break;\n\n              case 10:\n                message.codespace = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseQuery message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseQuery\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseQuery} ResponseQuery\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseQuery.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseQuery message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseQuery\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseQuery.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.code != null && message.hasOwnProperty(\"code\")) if (!$util.isInteger(message.code)) return \"code: integer expected\";\n          if (message.log != null && message.hasOwnProperty(\"log\")) if (!$util.isString(message.log)) return \"log: string expected\";\n          if (message.info != null && message.hasOwnProperty(\"info\")) if (!$util.isString(message.info)) return \"info: string expected\";\n          if (message.index != null && message.hasOwnProperty(\"index\")) if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high))) return \"index: integer|Long expected\";\n          if (message.key != null && message.hasOwnProperty(\"key\")) if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key))) return \"key: buffer expected\";\n          if (message.value != null && message.hasOwnProperty(\"value\")) if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value))) return \"value: buffer expected\";\n\n          if (message.proofOps != null && message.hasOwnProperty(\"proofOps\")) {\n            var error = $root.tendermint.crypto.ProofOps.verify(message.proofOps);\n            if (error) return \"proofOps.\" + error;\n          }\n\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))) return \"height: integer|Long expected\";\n          if (message.codespace != null && message.hasOwnProperty(\"codespace\")) if (!$util.isString(message.codespace)) return \"codespace: string expected\";\n          return null;\n        };\n        /**\n         * Creates a ResponseQuery message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseQuery\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseQuery} ResponseQuery\n         */\n\n\n        ResponseQuery.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseQuery) return object;\n          var message = new $root.tendermint.abci.ResponseQuery();\n          if (object.code != null) message.code = object.code >>> 0;\n          if (object.log != null) message.log = String(object.log);\n          if (object.info != null) message.info = String(object.info);\n          if (object.index != null) if ($util.Long) (message.index = $util.Long.fromValue(object.index)).unsigned = false;else if (typeof object.index === \"string\") message.index = parseInt(object.index, 10);else if (typeof object.index === \"number\") message.index = object.index;else if (typeof object.index === \"object\") message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber();\n          if (object.key != null) if (typeof object.key === \"string\") $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);else if (object.key.length) message.key = object.key;\n          if (object.value != null) if (typeof object.value === \"string\") $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);else if (object.value.length) message.value = object.value;\n\n          if (object.proofOps != null) {\n            if (typeof object.proofOps !== \"object\") throw TypeError(\".tendermint.abci.ResponseQuery.proofOps: object expected\");\n            message.proofOps = $root.tendermint.crypto.ProofOps.fromObject(object.proofOps);\n          }\n\n          if (object.height != null) if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;else if (typeof object.height === \"string\") message.height = parseInt(object.height, 10);else if (typeof object.height === \"number\") message.height = object.height;else if (typeof object.height === \"object\") message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();\n          if (object.codespace != null) message.codespace = String(object.codespace);\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseQuery message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseQuery\n         * @static\n         * @param {tendermint.abci.ResponseQuery} message ResponseQuery\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseQuery.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.code = 0;\n            object.log = \"\";\n            object.info = \"\";\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.index = options.longs === String ? \"0\" : 0;\n\n            if (options.bytes === String) object.key = \"\";else {\n              object.key = [];\n              if (options.bytes !== Array) object.key = $util.newBuffer(object.key);\n            }\n            if (options.bytes === String) object.value = \"\";else {\n              object.value = [];\n              if (options.bytes !== Array) object.value = $util.newBuffer(object.value);\n            }\n            object.proofOps = null;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.height = options.longs === String ? \"0\" : 0;\n\n            object.codespace = \"\";\n          }\n\n          if (message.code != null && message.hasOwnProperty(\"code\")) object.code = message.code;\n          if (message.log != null && message.hasOwnProperty(\"log\")) object.log = message.log;\n          if (message.info != null && message.hasOwnProperty(\"info\")) object.info = message.info;\n          if (message.index != null && message.hasOwnProperty(\"index\")) if (typeof message.index === \"number\") object.index = options.longs === String ? String(message.index) : message.index;else object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber() : message.index;\n          if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n          if (message.value != null && message.hasOwnProperty(\"value\")) object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n          if (message.proofOps != null && message.hasOwnProperty(\"proofOps\")) object.proofOps = $root.tendermint.crypto.ProofOps.toObject(message.proofOps, options);\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (typeof message.height === \"number\") object.height = options.longs === String ? String(message.height) : message.height;else object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;\n          if (message.codespace != null && message.hasOwnProperty(\"codespace\")) object.codespace = message.codespace;\n          return object;\n        };\n        /**\n         * Converts this ResponseQuery to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseQuery\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseQuery.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseQuery;\n      }();\n\n      abci.ResponseBeginBlock = function () {\n        /**\n         * Properties of a ResponseBeginBlock.\n         * @memberof tendermint.abci\n         * @interface IResponseBeginBlock\n         * @property {Array.<tendermint.abci.IEvent>|null} [events] ResponseBeginBlock events\n         */\n\n        /**\n         * Constructs a new ResponseBeginBlock.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseBeginBlock.\n         * @implements IResponseBeginBlock\n         * @constructor\n         * @param {tendermint.abci.IResponseBeginBlock=} [properties] Properties to set\n         */\n        function ResponseBeginBlock(properties) {\n          this.events = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseBeginBlock events.\n         * @member {Array.<tendermint.abci.IEvent>} events\n         * @memberof tendermint.abci.ResponseBeginBlock\n         * @instance\n         */\n\n\n        ResponseBeginBlock.prototype.events = $util.emptyArray;\n        /**\n         * Creates a new ResponseBeginBlock instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseBeginBlock\n         * @static\n         * @param {tendermint.abci.IResponseBeginBlock=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseBeginBlock} ResponseBeginBlock instance\n         */\n\n        ResponseBeginBlock.create = function create(properties) {\n          return new ResponseBeginBlock(properties);\n        };\n        /**\n         * Encodes the specified ResponseBeginBlock message. Does not implicitly {@link tendermint.abci.ResponseBeginBlock.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseBeginBlock\n         * @static\n         * @param {tendermint.abci.IResponseBeginBlock} message ResponseBeginBlock message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseBeginBlock.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.events != null && message.events.length) for (var i = 0; i < message.events.length; ++i) {\n            $root.tendermint.abci.Event.encode(message.events[i], writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseBeginBlock message, length delimited. Does not implicitly {@link tendermint.abci.ResponseBeginBlock.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseBeginBlock\n         * @static\n         * @param {tendermint.abci.IResponseBeginBlock} message ResponseBeginBlock message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseBeginBlock.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseBeginBlock message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseBeginBlock\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseBeginBlock} ResponseBeginBlock\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseBeginBlock.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseBeginBlock();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.events && message.events.length)) message.events = [];\n                message.events.push($root.tendermint.abci.Event.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseBeginBlock message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseBeginBlock\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseBeginBlock} ResponseBeginBlock\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseBeginBlock.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseBeginBlock message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseBeginBlock\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseBeginBlock.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.events != null && message.hasOwnProperty(\"events\")) {\n            if (!Array.isArray(message.events)) return \"events: array expected\";\n\n            for (var i = 0; i < message.events.length; ++i) {\n              var error = $root.tendermint.abci.Event.verify(message.events[i]);\n              if (error) return \"events.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a ResponseBeginBlock message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseBeginBlock\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseBeginBlock} ResponseBeginBlock\n         */\n\n\n        ResponseBeginBlock.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseBeginBlock) return object;\n          var message = new $root.tendermint.abci.ResponseBeginBlock();\n\n          if (object.events) {\n            if (!Array.isArray(object.events)) throw TypeError(\".tendermint.abci.ResponseBeginBlock.events: array expected\");\n            message.events = [];\n\n            for (var i = 0; i < object.events.length; ++i) {\n              if (typeof object.events[i] !== \"object\") throw TypeError(\".tendermint.abci.ResponseBeginBlock.events: object expected\");\n              message.events[i] = $root.tendermint.abci.Event.fromObject(object.events[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseBeginBlock message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseBeginBlock\n         * @static\n         * @param {tendermint.abci.ResponseBeginBlock} message ResponseBeginBlock\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseBeginBlock.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.events = [];\n\n          if (message.events && message.events.length) {\n            object.events = [];\n\n            for (var j = 0; j < message.events.length; ++j) {\n              object.events[j] = $root.tendermint.abci.Event.toObject(message.events[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this ResponseBeginBlock to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseBeginBlock\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseBeginBlock.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseBeginBlock;\n      }();\n\n      abci.ResponseCheckTx = function () {\n        /**\n         * Properties of a ResponseCheckTx.\n         * @memberof tendermint.abci\n         * @interface IResponseCheckTx\n         * @property {number|null} [code] ResponseCheckTx code\n         * @property {Uint8Array|null} [data] ResponseCheckTx data\n         * @property {string|null} [log] ResponseCheckTx log\n         * @property {string|null} [info] ResponseCheckTx info\n         * @property {number|Long|null} [gasWanted] ResponseCheckTx gasWanted\n         * @property {number|Long|null} [gasUsed] ResponseCheckTx gasUsed\n         * @property {Array.<tendermint.abci.IEvent>|null} [events] ResponseCheckTx events\n         * @property {string|null} [codespace] ResponseCheckTx codespace\n         */\n\n        /**\n         * Constructs a new ResponseCheckTx.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseCheckTx.\n         * @implements IResponseCheckTx\n         * @constructor\n         * @param {tendermint.abci.IResponseCheckTx=} [properties] Properties to set\n         */\n        function ResponseCheckTx(properties) {\n          this.events = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseCheckTx code.\n         * @member {number} code\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @instance\n         */\n\n\n        ResponseCheckTx.prototype.code = 0;\n        /**\n         * ResponseCheckTx data.\n         * @member {Uint8Array} data\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @instance\n         */\n\n        ResponseCheckTx.prototype.data = $util.newBuffer([]);\n        /**\n         * ResponseCheckTx log.\n         * @member {string} log\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @instance\n         */\n\n        ResponseCheckTx.prototype.log = \"\";\n        /**\n         * ResponseCheckTx info.\n         * @member {string} info\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @instance\n         */\n\n        ResponseCheckTx.prototype.info = \"\";\n        /**\n         * ResponseCheckTx gasWanted.\n         * @member {number|Long} gasWanted\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @instance\n         */\n\n        ResponseCheckTx.prototype.gasWanted = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * ResponseCheckTx gasUsed.\n         * @member {number|Long} gasUsed\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @instance\n         */\n\n        ResponseCheckTx.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * ResponseCheckTx events.\n         * @member {Array.<tendermint.abci.IEvent>} events\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @instance\n         */\n\n        ResponseCheckTx.prototype.events = $util.emptyArray;\n        /**\n         * ResponseCheckTx codespace.\n         * @member {string} codespace\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @instance\n         */\n\n        ResponseCheckTx.prototype.codespace = \"\";\n        /**\n         * Creates a new ResponseCheckTx instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @static\n         * @param {tendermint.abci.IResponseCheckTx=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseCheckTx} ResponseCheckTx instance\n         */\n\n        ResponseCheckTx.create = function create(properties) {\n          return new ResponseCheckTx(properties);\n        };\n        /**\n         * Encodes the specified ResponseCheckTx message. Does not implicitly {@link tendermint.abci.ResponseCheckTx.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @static\n         * @param {tendermint.abci.IResponseCheckTx} message ResponseCheckTx message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseCheckTx.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.code != null && Object.hasOwnProperty.call(message, \"code\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).uint32(message.code);\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.data);\n          if (message.log != null && Object.hasOwnProperty.call(message, \"log\")) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).string(message.log);\n          if (message.info != null && Object.hasOwnProperty.call(message, \"info\")) writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).string(message.info);\n          if (message.gasWanted != null && Object.hasOwnProperty.call(message, \"gasWanted\")) writer.uint32(\n          /* id 5, wireType 0 =*/\n          40).int64(message.gasWanted);\n          if (message.gasUsed != null && Object.hasOwnProperty.call(message, \"gasUsed\")) writer.uint32(\n          /* id 6, wireType 0 =*/\n          48).int64(message.gasUsed);\n          if (message.events != null && message.events.length) for (var i = 0; i < message.events.length; ++i) {\n            $root.tendermint.abci.Event.encode(message.events[i], writer.uint32(\n            /* id 7, wireType 2 =*/\n            58).fork()).ldelim();\n          }\n          if (message.codespace != null && Object.hasOwnProperty.call(message, \"codespace\")) writer.uint32(\n          /* id 8, wireType 2 =*/\n          66).string(message.codespace);\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseCheckTx message, length delimited. Does not implicitly {@link tendermint.abci.ResponseCheckTx.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @static\n         * @param {tendermint.abci.IResponseCheckTx} message ResponseCheckTx message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseCheckTx.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseCheckTx message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseCheckTx} ResponseCheckTx\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseCheckTx.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseCheckTx();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.code = reader.uint32();\n                break;\n\n              case 2:\n                message.data = reader.bytes();\n                break;\n\n              case 3:\n                message.log = reader.string();\n                break;\n\n              case 4:\n                message.info = reader.string();\n                break;\n\n              case 5:\n                message.gasWanted = reader.int64();\n                break;\n\n              case 6:\n                message.gasUsed = reader.int64();\n                break;\n\n              case 7:\n                if (!(message.events && message.events.length)) message.events = [];\n                message.events.push($root.tendermint.abci.Event.decode(reader, reader.uint32()));\n                break;\n\n              case 8:\n                message.codespace = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseCheckTx message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseCheckTx} ResponseCheckTx\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseCheckTx.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseCheckTx message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseCheckTx.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.code != null && message.hasOwnProperty(\"code\")) if (!$util.isInteger(message.code)) return \"code: integer expected\";\n          if (message.data != null && message.hasOwnProperty(\"data\")) if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data))) return \"data: buffer expected\";\n          if (message.log != null && message.hasOwnProperty(\"log\")) if (!$util.isString(message.log)) return \"log: string expected\";\n          if (message.info != null && message.hasOwnProperty(\"info\")) if (!$util.isString(message.info)) return \"info: string expected\";\n          if (message.gasWanted != null && message.hasOwnProperty(\"gasWanted\")) if (!$util.isInteger(message.gasWanted) && !(message.gasWanted && $util.isInteger(message.gasWanted.low) && $util.isInteger(message.gasWanted.high))) return \"gasWanted: integer|Long expected\";\n          if (message.gasUsed != null && message.hasOwnProperty(\"gasUsed\")) if (!$util.isInteger(message.gasUsed) && !(message.gasUsed && $util.isInteger(message.gasUsed.low) && $util.isInteger(message.gasUsed.high))) return \"gasUsed: integer|Long expected\";\n\n          if (message.events != null && message.hasOwnProperty(\"events\")) {\n            if (!Array.isArray(message.events)) return \"events: array expected\";\n\n            for (var i = 0; i < message.events.length; ++i) {\n              var error = $root.tendermint.abci.Event.verify(message.events[i]);\n              if (error) return \"events.\" + error;\n            }\n          }\n\n          if (message.codespace != null && message.hasOwnProperty(\"codespace\")) if (!$util.isString(message.codespace)) return \"codespace: string expected\";\n          return null;\n        };\n        /**\n         * Creates a ResponseCheckTx message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseCheckTx} ResponseCheckTx\n         */\n\n\n        ResponseCheckTx.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseCheckTx) return object;\n          var message = new $root.tendermint.abci.ResponseCheckTx();\n          if (object.code != null) message.code = object.code >>> 0;\n          if (object.data != null) if (typeof object.data === \"string\") $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;\n          if (object.log != null) message.log = String(object.log);\n          if (object.info != null) message.info = String(object.info);\n          if (object.gasWanted != null) if ($util.Long) (message.gasWanted = $util.Long.fromValue(object.gasWanted)).unsigned = false;else if (typeof object.gasWanted === \"string\") message.gasWanted = parseInt(object.gasWanted, 10);else if (typeof object.gasWanted === \"number\") message.gasWanted = object.gasWanted;else if (typeof object.gasWanted === \"object\") message.gasWanted = new $util.LongBits(object.gasWanted.low >>> 0, object.gasWanted.high >>> 0).toNumber();\n          if (object.gasUsed != null) if ($util.Long) (message.gasUsed = $util.Long.fromValue(object.gasUsed)).unsigned = false;else if (typeof object.gasUsed === \"string\") message.gasUsed = parseInt(object.gasUsed, 10);else if (typeof object.gasUsed === \"number\") message.gasUsed = object.gasUsed;else if (typeof object.gasUsed === \"object\") message.gasUsed = new $util.LongBits(object.gasUsed.low >>> 0, object.gasUsed.high >>> 0).toNumber();\n\n          if (object.events) {\n            if (!Array.isArray(object.events)) throw TypeError(\".tendermint.abci.ResponseCheckTx.events: array expected\");\n            message.events = [];\n\n            for (var i = 0; i < object.events.length; ++i) {\n              if (typeof object.events[i] !== \"object\") throw TypeError(\".tendermint.abci.ResponseCheckTx.events: object expected\");\n              message.events[i] = $root.tendermint.abci.Event.fromObject(object.events[i]);\n            }\n          }\n\n          if (object.codespace != null) message.codespace = String(object.codespace);\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseCheckTx message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @static\n         * @param {tendermint.abci.ResponseCheckTx} message ResponseCheckTx\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseCheckTx.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.events = [];\n\n          if (options.defaults) {\n            object.code = 0;\n            if (options.bytes === String) object.data = \"\";else {\n              object.data = [];\n              if (options.bytes !== Array) object.data = $util.newBuffer(object.data);\n            }\n            object.log = \"\";\n            object.info = \"\";\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.gasWanted = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.gasWanted = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.gasUsed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.gasUsed = options.longs === String ? \"0\" : 0;\n\n            object.codespace = \"\";\n          }\n\n          if (message.code != null && message.hasOwnProperty(\"code\")) object.code = message.code;\n          if (message.data != null && message.hasOwnProperty(\"data\")) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n          if (message.log != null && message.hasOwnProperty(\"log\")) object.log = message.log;\n          if (message.info != null && message.hasOwnProperty(\"info\")) object.info = message.info;\n          if (message.gasWanted != null && message.hasOwnProperty(\"gasWanted\")) if (typeof message.gasWanted === \"number\") object.gasWanted = options.longs === String ? String(message.gasWanted) : message.gasWanted;else object.gasWanted = options.longs === String ? $util.Long.prototype.toString.call(message.gasWanted) : options.longs === Number ? new $util.LongBits(message.gasWanted.low >>> 0, message.gasWanted.high >>> 0).toNumber() : message.gasWanted;\n          if (message.gasUsed != null && message.hasOwnProperty(\"gasUsed\")) if (typeof message.gasUsed === \"number\") object.gasUsed = options.longs === String ? String(message.gasUsed) : message.gasUsed;else object.gasUsed = options.longs === String ? $util.Long.prototype.toString.call(message.gasUsed) : options.longs === Number ? new $util.LongBits(message.gasUsed.low >>> 0, message.gasUsed.high >>> 0).toNumber() : message.gasUsed;\n\n          if (message.events && message.events.length) {\n            object.events = [];\n\n            for (var j = 0; j < message.events.length; ++j) {\n              object.events[j] = $root.tendermint.abci.Event.toObject(message.events[j], options);\n            }\n          }\n\n          if (message.codespace != null && message.hasOwnProperty(\"codespace\")) object.codespace = message.codespace;\n          return object;\n        };\n        /**\n         * Converts this ResponseCheckTx to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseCheckTx\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseCheckTx.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseCheckTx;\n      }();\n\n      abci.ResponseDeliverTx = function () {\n        /**\n         * Properties of a ResponseDeliverTx.\n         * @memberof tendermint.abci\n         * @interface IResponseDeliverTx\n         * @property {number|null} [code] ResponseDeliverTx code\n         * @property {Uint8Array|null} [data] ResponseDeliverTx data\n         * @property {string|null} [log] ResponseDeliverTx log\n         * @property {string|null} [info] ResponseDeliverTx info\n         * @property {number|Long|null} [gasWanted] ResponseDeliverTx gasWanted\n         * @property {number|Long|null} [gasUsed] ResponseDeliverTx gasUsed\n         * @property {Array.<tendermint.abci.IEvent>|null} [events] ResponseDeliverTx events\n         * @property {string|null} [codespace] ResponseDeliverTx codespace\n         */\n\n        /**\n         * Constructs a new ResponseDeliverTx.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseDeliverTx.\n         * @implements IResponseDeliverTx\n         * @constructor\n         * @param {tendermint.abci.IResponseDeliverTx=} [properties] Properties to set\n         */\n        function ResponseDeliverTx(properties) {\n          this.events = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseDeliverTx code.\n         * @member {number} code\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @instance\n         */\n\n\n        ResponseDeliverTx.prototype.code = 0;\n        /**\n         * ResponseDeliverTx data.\n         * @member {Uint8Array} data\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @instance\n         */\n\n        ResponseDeliverTx.prototype.data = $util.newBuffer([]);\n        /**\n         * ResponseDeliverTx log.\n         * @member {string} log\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @instance\n         */\n\n        ResponseDeliverTx.prototype.log = \"\";\n        /**\n         * ResponseDeliverTx info.\n         * @member {string} info\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @instance\n         */\n\n        ResponseDeliverTx.prototype.info = \"\";\n        /**\n         * ResponseDeliverTx gasWanted.\n         * @member {number|Long} gasWanted\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @instance\n         */\n\n        ResponseDeliverTx.prototype.gasWanted = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * ResponseDeliverTx gasUsed.\n         * @member {number|Long} gasUsed\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @instance\n         */\n\n        ResponseDeliverTx.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * ResponseDeliverTx events.\n         * @member {Array.<tendermint.abci.IEvent>} events\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @instance\n         */\n\n        ResponseDeliverTx.prototype.events = $util.emptyArray;\n        /**\n         * ResponseDeliverTx codespace.\n         * @member {string} codespace\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @instance\n         */\n\n        ResponseDeliverTx.prototype.codespace = \"\";\n        /**\n         * Creates a new ResponseDeliverTx instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @static\n         * @param {tendermint.abci.IResponseDeliverTx=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseDeliverTx} ResponseDeliverTx instance\n         */\n\n        ResponseDeliverTx.create = function create(properties) {\n          return new ResponseDeliverTx(properties);\n        };\n        /**\n         * Encodes the specified ResponseDeliverTx message. Does not implicitly {@link tendermint.abci.ResponseDeliverTx.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @static\n         * @param {tendermint.abci.IResponseDeliverTx} message ResponseDeliverTx message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseDeliverTx.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.code != null && Object.hasOwnProperty.call(message, \"code\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).uint32(message.code);\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.data);\n          if (message.log != null && Object.hasOwnProperty.call(message, \"log\")) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).string(message.log);\n          if (message.info != null && Object.hasOwnProperty.call(message, \"info\")) writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).string(message.info);\n          if (message.gasWanted != null && Object.hasOwnProperty.call(message, \"gasWanted\")) writer.uint32(\n          /* id 5, wireType 0 =*/\n          40).int64(message.gasWanted);\n          if (message.gasUsed != null && Object.hasOwnProperty.call(message, \"gasUsed\")) writer.uint32(\n          /* id 6, wireType 0 =*/\n          48).int64(message.gasUsed);\n          if (message.events != null && message.events.length) for (var i = 0; i < message.events.length; ++i) {\n            $root.tendermint.abci.Event.encode(message.events[i], writer.uint32(\n            /* id 7, wireType 2 =*/\n            58).fork()).ldelim();\n          }\n          if (message.codespace != null && Object.hasOwnProperty.call(message, \"codespace\")) writer.uint32(\n          /* id 8, wireType 2 =*/\n          66).string(message.codespace);\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseDeliverTx message, length delimited. Does not implicitly {@link tendermint.abci.ResponseDeliverTx.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @static\n         * @param {tendermint.abci.IResponseDeliverTx} message ResponseDeliverTx message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseDeliverTx.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseDeliverTx message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseDeliverTx} ResponseDeliverTx\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseDeliverTx.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseDeliverTx();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.code = reader.uint32();\n                break;\n\n              case 2:\n                message.data = reader.bytes();\n                break;\n\n              case 3:\n                message.log = reader.string();\n                break;\n\n              case 4:\n                message.info = reader.string();\n                break;\n\n              case 5:\n                message.gasWanted = reader.int64();\n                break;\n\n              case 6:\n                message.gasUsed = reader.int64();\n                break;\n\n              case 7:\n                if (!(message.events && message.events.length)) message.events = [];\n                message.events.push($root.tendermint.abci.Event.decode(reader, reader.uint32()));\n                break;\n\n              case 8:\n                message.codespace = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseDeliverTx message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseDeliverTx} ResponseDeliverTx\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseDeliverTx.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseDeliverTx message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseDeliverTx.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.code != null && message.hasOwnProperty(\"code\")) if (!$util.isInteger(message.code)) return \"code: integer expected\";\n          if (message.data != null && message.hasOwnProperty(\"data\")) if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data))) return \"data: buffer expected\";\n          if (message.log != null && message.hasOwnProperty(\"log\")) if (!$util.isString(message.log)) return \"log: string expected\";\n          if (message.info != null && message.hasOwnProperty(\"info\")) if (!$util.isString(message.info)) return \"info: string expected\";\n          if (message.gasWanted != null && message.hasOwnProperty(\"gasWanted\")) if (!$util.isInteger(message.gasWanted) && !(message.gasWanted && $util.isInteger(message.gasWanted.low) && $util.isInteger(message.gasWanted.high))) return \"gasWanted: integer|Long expected\";\n          if (message.gasUsed != null && message.hasOwnProperty(\"gasUsed\")) if (!$util.isInteger(message.gasUsed) && !(message.gasUsed && $util.isInteger(message.gasUsed.low) && $util.isInteger(message.gasUsed.high))) return \"gasUsed: integer|Long expected\";\n\n          if (message.events != null && message.hasOwnProperty(\"events\")) {\n            if (!Array.isArray(message.events)) return \"events: array expected\";\n\n            for (var i = 0; i < message.events.length; ++i) {\n              var error = $root.tendermint.abci.Event.verify(message.events[i]);\n              if (error) return \"events.\" + error;\n            }\n          }\n\n          if (message.codespace != null && message.hasOwnProperty(\"codespace\")) if (!$util.isString(message.codespace)) return \"codespace: string expected\";\n          return null;\n        };\n        /**\n         * Creates a ResponseDeliverTx message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseDeliverTx} ResponseDeliverTx\n         */\n\n\n        ResponseDeliverTx.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseDeliverTx) return object;\n          var message = new $root.tendermint.abci.ResponseDeliverTx();\n          if (object.code != null) message.code = object.code >>> 0;\n          if (object.data != null) if (typeof object.data === \"string\") $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;\n          if (object.log != null) message.log = String(object.log);\n          if (object.info != null) message.info = String(object.info);\n          if (object.gasWanted != null) if ($util.Long) (message.gasWanted = $util.Long.fromValue(object.gasWanted)).unsigned = false;else if (typeof object.gasWanted === \"string\") message.gasWanted = parseInt(object.gasWanted, 10);else if (typeof object.gasWanted === \"number\") message.gasWanted = object.gasWanted;else if (typeof object.gasWanted === \"object\") message.gasWanted = new $util.LongBits(object.gasWanted.low >>> 0, object.gasWanted.high >>> 0).toNumber();\n          if (object.gasUsed != null) if ($util.Long) (message.gasUsed = $util.Long.fromValue(object.gasUsed)).unsigned = false;else if (typeof object.gasUsed === \"string\") message.gasUsed = parseInt(object.gasUsed, 10);else if (typeof object.gasUsed === \"number\") message.gasUsed = object.gasUsed;else if (typeof object.gasUsed === \"object\") message.gasUsed = new $util.LongBits(object.gasUsed.low >>> 0, object.gasUsed.high >>> 0).toNumber();\n\n          if (object.events) {\n            if (!Array.isArray(object.events)) throw TypeError(\".tendermint.abci.ResponseDeliverTx.events: array expected\");\n            message.events = [];\n\n            for (var i = 0; i < object.events.length; ++i) {\n              if (typeof object.events[i] !== \"object\") throw TypeError(\".tendermint.abci.ResponseDeliverTx.events: object expected\");\n              message.events[i] = $root.tendermint.abci.Event.fromObject(object.events[i]);\n            }\n          }\n\n          if (object.codespace != null) message.codespace = String(object.codespace);\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseDeliverTx message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @static\n         * @param {tendermint.abci.ResponseDeliverTx} message ResponseDeliverTx\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseDeliverTx.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.events = [];\n\n          if (options.defaults) {\n            object.code = 0;\n            if (options.bytes === String) object.data = \"\";else {\n              object.data = [];\n              if (options.bytes !== Array) object.data = $util.newBuffer(object.data);\n            }\n            object.log = \"\";\n            object.info = \"\";\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.gasWanted = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.gasWanted = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.gasUsed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.gasUsed = options.longs === String ? \"0\" : 0;\n\n            object.codespace = \"\";\n          }\n\n          if (message.code != null && message.hasOwnProperty(\"code\")) object.code = message.code;\n          if (message.data != null && message.hasOwnProperty(\"data\")) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n          if (message.log != null && message.hasOwnProperty(\"log\")) object.log = message.log;\n          if (message.info != null && message.hasOwnProperty(\"info\")) object.info = message.info;\n          if (message.gasWanted != null && message.hasOwnProperty(\"gasWanted\")) if (typeof message.gasWanted === \"number\") object.gasWanted = options.longs === String ? String(message.gasWanted) : message.gasWanted;else object.gasWanted = options.longs === String ? $util.Long.prototype.toString.call(message.gasWanted) : options.longs === Number ? new $util.LongBits(message.gasWanted.low >>> 0, message.gasWanted.high >>> 0).toNumber() : message.gasWanted;\n          if (message.gasUsed != null && message.hasOwnProperty(\"gasUsed\")) if (typeof message.gasUsed === \"number\") object.gasUsed = options.longs === String ? String(message.gasUsed) : message.gasUsed;else object.gasUsed = options.longs === String ? $util.Long.prototype.toString.call(message.gasUsed) : options.longs === Number ? new $util.LongBits(message.gasUsed.low >>> 0, message.gasUsed.high >>> 0).toNumber() : message.gasUsed;\n\n          if (message.events && message.events.length) {\n            object.events = [];\n\n            for (var j = 0; j < message.events.length; ++j) {\n              object.events[j] = $root.tendermint.abci.Event.toObject(message.events[j], options);\n            }\n          }\n\n          if (message.codespace != null && message.hasOwnProperty(\"codespace\")) object.codespace = message.codespace;\n          return object;\n        };\n        /**\n         * Converts this ResponseDeliverTx to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseDeliverTx\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseDeliverTx.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseDeliverTx;\n      }();\n\n      abci.ResponseEndBlock = function () {\n        /**\n         * Properties of a ResponseEndBlock.\n         * @memberof tendermint.abci\n         * @interface IResponseEndBlock\n         * @property {Array.<tendermint.abci.IValidatorUpdate>|null} [validatorUpdates] ResponseEndBlock validatorUpdates\n         * @property {tendermint.abci.IConsensusParams|null} [consensusParamUpdates] ResponseEndBlock consensusParamUpdates\n         * @property {Array.<tendermint.abci.IEvent>|null} [events] ResponseEndBlock events\n         */\n\n        /**\n         * Constructs a new ResponseEndBlock.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseEndBlock.\n         * @implements IResponseEndBlock\n         * @constructor\n         * @param {tendermint.abci.IResponseEndBlock=} [properties] Properties to set\n         */\n        function ResponseEndBlock(properties) {\n          this.validatorUpdates = [];\n          this.events = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseEndBlock validatorUpdates.\n         * @member {Array.<tendermint.abci.IValidatorUpdate>} validatorUpdates\n         * @memberof tendermint.abci.ResponseEndBlock\n         * @instance\n         */\n\n\n        ResponseEndBlock.prototype.validatorUpdates = $util.emptyArray;\n        /**\n         * ResponseEndBlock consensusParamUpdates.\n         * @member {tendermint.abci.IConsensusParams|null|undefined} consensusParamUpdates\n         * @memberof tendermint.abci.ResponseEndBlock\n         * @instance\n         */\n\n        ResponseEndBlock.prototype.consensusParamUpdates = null;\n        /**\n         * ResponseEndBlock events.\n         * @member {Array.<tendermint.abci.IEvent>} events\n         * @memberof tendermint.abci.ResponseEndBlock\n         * @instance\n         */\n\n        ResponseEndBlock.prototype.events = $util.emptyArray;\n        /**\n         * Creates a new ResponseEndBlock instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseEndBlock\n         * @static\n         * @param {tendermint.abci.IResponseEndBlock=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseEndBlock} ResponseEndBlock instance\n         */\n\n        ResponseEndBlock.create = function create(properties) {\n          return new ResponseEndBlock(properties);\n        };\n        /**\n         * Encodes the specified ResponseEndBlock message. Does not implicitly {@link tendermint.abci.ResponseEndBlock.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseEndBlock\n         * @static\n         * @param {tendermint.abci.IResponseEndBlock} message ResponseEndBlock message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseEndBlock.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.validatorUpdates != null && message.validatorUpdates.length) for (var i = 0; i < message.validatorUpdates.length; ++i) {\n            $root.tendermint.abci.ValidatorUpdate.encode(message.validatorUpdates[i], writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).fork()).ldelim();\n          }\n          if (message.consensusParamUpdates != null && Object.hasOwnProperty.call(message, \"consensusParamUpdates\")) $root.tendermint.abci.ConsensusParams.encode(message.consensusParamUpdates, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          if (message.events != null && message.events.length) for (var i = 0; i < message.events.length; ++i) {\n            $root.tendermint.abci.Event.encode(message.events[i], writer.uint32(\n            /* id 3, wireType 2 =*/\n            26).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseEndBlock message, length delimited. Does not implicitly {@link tendermint.abci.ResponseEndBlock.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseEndBlock\n         * @static\n         * @param {tendermint.abci.IResponseEndBlock} message ResponseEndBlock message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseEndBlock.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseEndBlock message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseEndBlock\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseEndBlock} ResponseEndBlock\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseEndBlock.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseEndBlock();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.validatorUpdates && message.validatorUpdates.length)) message.validatorUpdates = [];\n                message.validatorUpdates.push($root.tendermint.abci.ValidatorUpdate.decode(reader, reader.uint32()));\n                break;\n\n              case 2:\n                message.consensusParamUpdates = $root.tendermint.abci.ConsensusParams.decode(reader, reader.uint32());\n                break;\n\n              case 3:\n                if (!(message.events && message.events.length)) message.events = [];\n                message.events.push($root.tendermint.abci.Event.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseEndBlock message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseEndBlock\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseEndBlock} ResponseEndBlock\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseEndBlock.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseEndBlock message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseEndBlock\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseEndBlock.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.validatorUpdates != null && message.hasOwnProperty(\"validatorUpdates\")) {\n            if (!Array.isArray(message.validatorUpdates)) return \"validatorUpdates: array expected\";\n\n            for (var i = 0; i < message.validatorUpdates.length; ++i) {\n              var error = $root.tendermint.abci.ValidatorUpdate.verify(message.validatorUpdates[i]);\n              if (error) return \"validatorUpdates.\" + error;\n            }\n          }\n\n          if (message.consensusParamUpdates != null && message.hasOwnProperty(\"consensusParamUpdates\")) {\n            var error = $root.tendermint.abci.ConsensusParams.verify(message.consensusParamUpdates);\n            if (error) return \"consensusParamUpdates.\" + error;\n          }\n\n          if (message.events != null && message.hasOwnProperty(\"events\")) {\n            if (!Array.isArray(message.events)) return \"events: array expected\";\n\n            for (var i = 0; i < message.events.length; ++i) {\n              var error = $root.tendermint.abci.Event.verify(message.events[i]);\n              if (error) return \"events.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a ResponseEndBlock message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseEndBlock\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseEndBlock} ResponseEndBlock\n         */\n\n\n        ResponseEndBlock.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseEndBlock) return object;\n          var message = new $root.tendermint.abci.ResponseEndBlock();\n\n          if (object.validatorUpdates) {\n            if (!Array.isArray(object.validatorUpdates)) throw TypeError(\".tendermint.abci.ResponseEndBlock.validatorUpdates: array expected\");\n            message.validatorUpdates = [];\n\n            for (var i = 0; i < object.validatorUpdates.length; ++i) {\n              if (typeof object.validatorUpdates[i] !== \"object\") throw TypeError(\".tendermint.abci.ResponseEndBlock.validatorUpdates: object expected\");\n              message.validatorUpdates[i] = $root.tendermint.abci.ValidatorUpdate.fromObject(object.validatorUpdates[i]);\n            }\n          }\n\n          if (object.consensusParamUpdates != null) {\n            if (typeof object.consensusParamUpdates !== \"object\") throw TypeError(\".tendermint.abci.ResponseEndBlock.consensusParamUpdates: object expected\");\n            message.consensusParamUpdates = $root.tendermint.abci.ConsensusParams.fromObject(object.consensusParamUpdates);\n          }\n\n          if (object.events) {\n            if (!Array.isArray(object.events)) throw TypeError(\".tendermint.abci.ResponseEndBlock.events: array expected\");\n            message.events = [];\n\n            for (var i = 0; i < object.events.length; ++i) {\n              if (typeof object.events[i] !== \"object\") throw TypeError(\".tendermint.abci.ResponseEndBlock.events: object expected\");\n              message.events[i] = $root.tendermint.abci.Event.fromObject(object.events[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseEndBlock message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseEndBlock\n         * @static\n         * @param {tendermint.abci.ResponseEndBlock} message ResponseEndBlock\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseEndBlock.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.arrays || options.defaults) {\n            object.validatorUpdates = [];\n            object.events = [];\n          }\n\n          if (options.defaults) object.consensusParamUpdates = null;\n\n          if (message.validatorUpdates && message.validatorUpdates.length) {\n            object.validatorUpdates = [];\n\n            for (var j = 0; j < message.validatorUpdates.length; ++j) {\n              object.validatorUpdates[j] = $root.tendermint.abci.ValidatorUpdate.toObject(message.validatorUpdates[j], options);\n            }\n          }\n\n          if (message.consensusParamUpdates != null && message.hasOwnProperty(\"consensusParamUpdates\")) object.consensusParamUpdates = $root.tendermint.abci.ConsensusParams.toObject(message.consensusParamUpdates, options);\n\n          if (message.events && message.events.length) {\n            object.events = [];\n\n            for (var j = 0; j < message.events.length; ++j) {\n              object.events[j] = $root.tendermint.abci.Event.toObject(message.events[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this ResponseEndBlock to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseEndBlock\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseEndBlock.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseEndBlock;\n      }();\n\n      abci.ResponseCommit = function () {\n        /**\n         * Properties of a ResponseCommit.\n         * @memberof tendermint.abci\n         * @interface IResponseCommit\n         * @property {Uint8Array|null} [data] ResponseCommit data\n         * @property {number|Long|null} [retainHeight] ResponseCommit retainHeight\n         */\n\n        /**\n         * Constructs a new ResponseCommit.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseCommit.\n         * @implements IResponseCommit\n         * @constructor\n         * @param {tendermint.abci.IResponseCommit=} [properties] Properties to set\n         */\n        function ResponseCommit(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseCommit data.\n         * @member {Uint8Array} data\n         * @memberof tendermint.abci.ResponseCommit\n         * @instance\n         */\n\n\n        ResponseCommit.prototype.data = $util.newBuffer([]);\n        /**\n         * ResponseCommit retainHeight.\n         * @member {number|Long} retainHeight\n         * @memberof tendermint.abci.ResponseCommit\n         * @instance\n         */\n\n        ResponseCommit.prototype.retainHeight = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new ResponseCommit instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseCommit\n         * @static\n         * @param {tendermint.abci.IResponseCommit=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseCommit} ResponseCommit instance\n         */\n\n        ResponseCommit.create = function create(properties) {\n          return new ResponseCommit(properties);\n        };\n        /**\n         * Encodes the specified ResponseCommit message. Does not implicitly {@link tendermint.abci.ResponseCommit.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseCommit\n         * @static\n         * @param {tendermint.abci.IResponseCommit} message ResponseCommit message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseCommit.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.data);\n          if (message.retainHeight != null && Object.hasOwnProperty.call(message, \"retainHeight\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int64(message.retainHeight);\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseCommit message, length delimited. Does not implicitly {@link tendermint.abci.ResponseCommit.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseCommit\n         * @static\n         * @param {tendermint.abci.IResponseCommit} message ResponseCommit message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseCommit.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseCommit message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseCommit\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseCommit} ResponseCommit\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseCommit.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseCommit();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 2:\n                message.data = reader.bytes();\n                break;\n\n              case 3:\n                message.retainHeight = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseCommit message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseCommit\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseCommit} ResponseCommit\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseCommit.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseCommit message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseCommit\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseCommit.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.data != null && message.hasOwnProperty(\"data\")) if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data))) return \"data: buffer expected\";\n          if (message.retainHeight != null && message.hasOwnProperty(\"retainHeight\")) if (!$util.isInteger(message.retainHeight) && !(message.retainHeight && $util.isInteger(message.retainHeight.low) && $util.isInteger(message.retainHeight.high))) return \"retainHeight: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a ResponseCommit message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseCommit\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseCommit} ResponseCommit\n         */\n\n\n        ResponseCommit.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseCommit) return object;\n          var message = new $root.tendermint.abci.ResponseCommit();\n          if (object.data != null) if (typeof object.data === \"string\") $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;\n          if (object.retainHeight != null) if ($util.Long) (message.retainHeight = $util.Long.fromValue(object.retainHeight)).unsigned = false;else if (typeof object.retainHeight === \"string\") message.retainHeight = parseInt(object.retainHeight, 10);else if (typeof object.retainHeight === \"number\") message.retainHeight = object.retainHeight;else if (typeof object.retainHeight === \"object\") message.retainHeight = new $util.LongBits(object.retainHeight.low >>> 0, object.retainHeight.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseCommit message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseCommit\n         * @static\n         * @param {tendermint.abci.ResponseCommit} message ResponseCommit\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseCommit.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if (options.bytes === String) object.data = \"\";else {\n              object.data = [];\n              if (options.bytes !== Array) object.data = $util.newBuffer(object.data);\n            }\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.retainHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.retainHeight = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.data != null && message.hasOwnProperty(\"data\")) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n          if (message.retainHeight != null && message.hasOwnProperty(\"retainHeight\")) if (typeof message.retainHeight === \"number\") object.retainHeight = options.longs === String ? String(message.retainHeight) : message.retainHeight;else object.retainHeight = options.longs === String ? $util.Long.prototype.toString.call(message.retainHeight) : options.longs === Number ? new $util.LongBits(message.retainHeight.low >>> 0, message.retainHeight.high >>> 0).toNumber() : message.retainHeight;\n          return object;\n        };\n        /**\n         * Converts this ResponseCommit to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseCommit\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseCommit.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseCommit;\n      }();\n\n      abci.ResponseListSnapshots = function () {\n        /**\n         * Properties of a ResponseListSnapshots.\n         * @memberof tendermint.abci\n         * @interface IResponseListSnapshots\n         * @property {Array.<tendermint.abci.ISnapshot>|null} [snapshots] ResponseListSnapshots snapshots\n         */\n\n        /**\n         * Constructs a new ResponseListSnapshots.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseListSnapshots.\n         * @implements IResponseListSnapshots\n         * @constructor\n         * @param {tendermint.abci.IResponseListSnapshots=} [properties] Properties to set\n         */\n        function ResponseListSnapshots(properties) {\n          this.snapshots = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseListSnapshots snapshots.\n         * @member {Array.<tendermint.abci.ISnapshot>} snapshots\n         * @memberof tendermint.abci.ResponseListSnapshots\n         * @instance\n         */\n\n\n        ResponseListSnapshots.prototype.snapshots = $util.emptyArray;\n        /**\n         * Creates a new ResponseListSnapshots instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseListSnapshots\n         * @static\n         * @param {tendermint.abci.IResponseListSnapshots=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseListSnapshots} ResponseListSnapshots instance\n         */\n\n        ResponseListSnapshots.create = function create(properties) {\n          return new ResponseListSnapshots(properties);\n        };\n        /**\n         * Encodes the specified ResponseListSnapshots message. Does not implicitly {@link tendermint.abci.ResponseListSnapshots.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseListSnapshots\n         * @static\n         * @param {tendermint.abci.IResponseListSnapshots} message ResponseListSnapshots message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseListSnapshots.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.snapshots != null && message.snapshots.length) for (var i = 0; i < message.snapshots.length; ++i) {\n            $root.tendermint.abci.Snapshot.encode(message.snapshots[i], writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseListSnapshots message, length delimited. Does not implicitly {@link tendermint.abci.ResponseListSnapshots.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseListSnapshots\n         * @static\n         * @param {tendermint.abci.IResponseListSnapshots} message ResponseListSnapshots message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseListSnapshots.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseListSnapshots message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseListSnapshots\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseListSnapshots} ResponseListSnapshots\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseListSnapshots.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseListSnapshots();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.snapshots && message.snapshots.length)) message.snapshots = [];\n                message.snapshots.push($root.tendermint.abci.Snapshot.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseListSnapshots message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseListSnapshots\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseListSnapshots} ResponseListSnapshots\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseListSnapshots.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseListSnapshots message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseListSnapshots\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseListSnapshots.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.snapshots != null && message.hasOwnProperty(\"snapshots\")) {\n            if (!Array.isArray(message.snapshots)) return \"snapshots: array expected\";\n\n            for (var i = 0; i < message.snapshots.length; ++i) {\n              var error = $root.tendermint.abci.Snapshot.verify(message.snapshots[i]);\n              if (error) return \"snapshots.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a ResponseListSnapshots message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseListSnapshots\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseListSnapshots} ResponseListSnapshots\n         */\n\n\n        ResponseListSnapshots.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseListSnapshots) return object;\n          var message = new $root.tendermint.abci.ResponseListSnapshots();\n\n          if (object.snapshots) {\n            if (!Array.isArray(object.snapshots)) throw TypeError(\".tendermint.abci.ResponseListSnapshots.snapshots: array expected\");\n            message.snapshots = [];\n\n            for (var i = 0; i < object.snapshots.length; ++i) {\n              if (typeof object.snapshots[i] !== \"object\") throw TypeError(\".tendermint.abci.ResponseListSnapshots.snapshots: object expected\");\n              message.snapshots[i] = $root.tendermint.abci.Snapshot.fromObject(object.snapshots[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseListSnapshots message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseListSnapshots\n         * @static\n         * @param {tendermint.abci.ResponseListSnapshots} message ResponseListSnapshots\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseListSnapshots.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.snapshots = [];\n\n          if (message.snapshots && message.snapshots.length) {\n            object.snapshots = [];\n\n            for (var j = 0; j < message.snapshots.length; ++j) {\n              object.snapshots[j] = $root.tendermint.abci.Snapshot.toObject(message.snapshots[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this ResponseListSnapshots to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseListSnapshots\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseListSnapshots.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseListSnapshots;\n      }();\n\n      abci.ResponseOfferSnapshot = function () {\n        /**\n         * Properties of a ResponseOfferSnapshot.\n         * @memberof tendermint.abci\n         * @interface IResponseOfferSnapshot\n         * @property {tendermint.abci.ResponseOfferSnapshot.Result|null} [result] ResponseOfferSnapshot result\n         */\n\n        /**\n         * Constructs a new ResponseOfferSnapshot.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseOfferSnapshot.\n         * @implements IResponseOfferSnapshot\n         * @constructor\n         * @param {tendermint.abci.IResponseOfferSnapshot=} [properties] Properties to set\n         */\n        function ResponseOfferSnapshot(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseOfferSnapshot result.\n         * @member {tendermint.abci.ResponseOfferSnapshot.Result} result\n         * @memberof tendermint.abci.ResponseOfferSnapshot\n         * @instance\n         */\n\n\n        ResponseOfferSnapshot.prototype.result = 0;\n        /**\n         * Creates a new ResponseOfferSnapshot instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseOfferSnapshot\n         * @static\n         * @param {tendermint.abci.IResponseOfferSnapshot=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseOfferSnapshot} ResponseOfferSnapshot instance\n         */\n\n        ResponseOfferSnapshot.create = function create(properties) {\n          return new ResponseOfferSnapshot(properties);\n        };\n        /**\n         * Encodes the specified ResponseOfferSnapshot message. Does not implicitly {@link tendermint.abci.ResponseOfferSnapshot.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseOfferSnapshot\n         * @static\n         * @param {tendermint.abci.IResponseOfferSnapshot} message ResponseOfferSnapshot message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseOfferSnapshot.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.result != null && Object.hasOwnProperty.call(message, \"result\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int32(message.result);\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseOfferSnapshot message, length delimited. Does not implicitly {@link tendermint.abci.ResponseOfferSnapshot.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseOfferSnapshot\n         * @static\n         * @param {tendermint.abci.IResponseOfferSnapshot} message ResponseOfferSnapshot message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseOfferSnapshot.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseOfferSnapshot message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseOfferSnapshot\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseOfferSnapshot} ResponseOfferSnapshot\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseOfferSnapshot.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseOfferSnapshot();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.result = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseOfferSnapshot message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseOfferSnapshot\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseOfferSnapshot} ResponseOfferSnapshot\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseOfferSnapshot.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseOfferSnapshot message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseOfferSnapshot\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseOfferSnapshot.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.result != null && message.hasOwnProperty(\"result\")) switch (message.result) {\n            default:\n              return \"result: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n              break;\n          }\n          return null;\n        };\n        /**\n         * Creates a ResponseOfferSnapshot message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseOfferSnapshot\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseOfferSnapshot} ResponseOfferSnapshot\n         */\n\n\n        ResponseOfferSnapshot.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseOfferSnapshot) return object;\n          var message = new $root.tendermint.abci.ResponseOfferSnapshot();\n\n          switch (object.result) {\n            case \"UNKNOWN\":\n            case 0:\n              message.result = 0;\n              break;\n\n            case \"ACCEPT\":\n            case 1:\n              message.result = 1;\n              break;\n\n            case \"ABORT\":\n            case 2:\n              message.result = 2;\n              break;\n\n            case \"REJECT\":\n            case 3:\n              message.result = 3;\n              break;\n\n            case \"REJECT_FORMAT\":\n            case 4:\n              message.result = 4;\n              break;\n\n            case \"REJECT_SENDER\":\n            case 5:\n              message.result = 5;\n              break;\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseOfferSnapshot message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseOfferSnapshot\n         * @static\n         * @param {tendermint.abci.ResponseOfferSnapshot} message ResponseOfferSnapshot\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseOfferSnapshot.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.defaults) object.result = options.enums === String ? \"UNKNOWN\" : 0;\n          if (message.result != null && message.hasOwnProperty(\"result\")) object.result = options.enums === String ? $root.tendermint.abci.ResponseOfferSnapshot.Result[message.result] : message.result;\n          return object;\n        };\n        /**\n         * Converts this ResponseOfferSnapshot to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseOfferSnapshot\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseOfferSnapshot.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        /**\n         * Result enum.\n         * @name tendermint.abci.ResponseOfferSnapshot.Result\n         * @enum {number}\n         * @property {number} UNKNOWN=0 UNKNOWN value\n         * @property {number} ACCEPT=1 ACCEPT value\n         * @property {number} ABORT=2 ABORT value\n         * @property {number} REJECT=3 REJECT value\n         * @property {number} REJECT_FORMAT=4 REJECT_FORMAT value\n         * @property {number} REJECT_SENDER=5 REJECT_SENDER value\n         */\n\n\n        ResponseOfferSnapshot.Result = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[0] = \"UNKNOWN\"] = 0;\n          values[valuesById[1] = \"ACCEPT\"] = 1;\n          values[valuesById[2] = \"ABORT\"] = 2;\n          values[valuesById[3] = \"REJECT\"] = 3;\n          values[valuesById[4] = \"REJECT_FORMAT\"] = 4;\n          values[valuesById[5] = \"REJECT_SENDER\"] = 5;\n          return values;\n        }();\n\n        return ResponseOfferSnapshot;\n      }();\n\n      abci.ResponseLoadSnapshotChunk = function () {\n        /**\n         * Properties of a ResponseLoadSnapshotChunk.\n         * @memberof tendermint.abci\n         * @interface IResponseLoadSnapshotChunk\n         * @property {Uint8Array|null} [chunk] ResponseLoadSnapshotChunk chunk\n         */\n\n        /**\n         * Constructs a new ResponseLoadSnapshotChunk.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseLoadSnapshotChunk.\n         * @implements IResponseLoadSnapshotChunk\n         * @constructor\n         * @param {tendermint.abci.IResponseLoadSnapshotChunk=} [properties] Properties to set\n         */\n        function ResponseLoadSnapshotChunk(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseLoadSnapshotChunk chunk.\n         * @member {Uint8Array} chunk\n         * @memberof tendermint.abci.ResponseLoadSnapshotChunk\n         * @instance\n         */\n\n\n        ResponseLoadSnapshotChunk.prototype.chunk = $util.newBuffer([]);\n        /**\n         * Creates a new ResponseLoadSnapshotChunk instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseLoadSnapshotChunk\n         * @static\n         * @param {tendermint.abci.IResponseLoadSnapshotChunk=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseLoadSnapshotChunk} ResponseLoadSnapshotChunk instance\n         */\n\n        ResponseLoadSnapshotChunk.create = function create(properties) {\n          return new ResponseLoadSnapshotChunk(properties);\n        };\n        /**\n         * Encodes the specified ResponseLoadSnapshotChunk message. Does not implicitly {@link tendermint.abci.ResponseLoadSnapshotChunk.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseLoadSnapshotChunk\n         * @static\n         * @param {tendermint.abci.IResponseLoadSnapshotChunk} message ResponseLoadSnapshotChunk message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseLoadSnapshotChunk.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.chunk != null && Object.hasOwnProperty.call(message, \"chunk\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).bytes(message.chunk);\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseLoadSnapshotChunk message, length delimited. Does not implicitly {@link tendermint.abci.ResponseLoadSnapshotChunk.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseLoadSnapshotChunk\n         * @static\n         * @param {tendermint.abci.IResponseLoadSnapshotChunk} message ResponseLoadSnapshotChunk message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseLoadSnapshotChunk.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseLoadSnapshotChunk message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseLoadSnapshotChunk\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseLoadSnapshotChunk} ResponseLoadSnapshotChunk\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseLoadSnapshotChunk.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseLoadSnapshotChunk();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.chunk = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseLoadSnapshotChunk message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseLoadSnapshotChunk\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseLoadSnapshotChunk} ResponseLoadSnapshotChunk\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseLoadSnapshotChunk.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseLoadSnapshotChunk message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseLoadSnapshotChunk\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseLoadSnapshotChunk.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.chunk != null && message.hasOwnProperty(\"chunk\")) if (!(message.chunk && typeof message.chunk.length === \"number\" || $util.isString(message.chunk))) return \"chunk: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates a ResponseLoadSnapshotChunk message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseLoadSnapshotChunk\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseLoadSnapshotChunk} ResponseLoadSnapshotChunk\n         */\n\n\n        ResponseLoadSnapshotChunk.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseLoadSnapshotChunk) return object;\n          var message = new $root.tendermint.abci.ResponseLoadSnapshotChunk();\n          if (object.chunk != null) if (typeof object.chunk === \"string\") $util.base64.decode(object.chunk, message.chunk = $util.newBuffer($util.base64.length(object.chunk)), 0);else if (object.chunk.length) message.chunk = object.chunk;\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseLoadSnapshotChunk message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseLoadSnapshotChunk\n         * @static\n         * @param {tendermint.abci.ResponseLoadSnapshotChunk} message ResponseLoadSnapshotChunk\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseLoadSnapshotChunk.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.defaults) if (options.bytes === String) object.chunk = \"\";else {\n            object.chunk = [];\n            if (options.bytes !== Array) object.chunk = $util.newBuffer(object.chunk);\n          }\n          if (message.chunk != null && message.hasOwnProperty(\"chunk\")) object.chunk = options.bytes === String ? $util.base64.encode(message.chunk, 0, message.chunk.length) : options.bytes === Array ? Array.prototype.slice.call(message.chunk) : message.chunk;\n          return object;\n        };\n        /**\n         * Converts this ResponseLoadSnapshotChunk to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseLoadSnapshotChunk\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseLoadSnapshotChunk.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ResponseLoadSnapshotChunk;\n      }();\n\n      abci.ResponseApplySnapshotChunk = function () {\n        /**\n         * Properties of a ResponseApplySnapshotChunk.\n         * @memberof tendermint.abci\n         * @interface IResponseApplySnapshotChunk\n         * @property {tendermint.abci.ResponseApplySnapshotChunk.Result|null} [result] ResponseApplySnapshotChunk result\n         * @property {Array.<number>|null} [refetchChunks] ResponseApplySnapshotChunk refetchChunks\n         * @property {Array.<string>|null} [rejectSenders] ResponseApplySnapshotChunk rejectSenders\n         */\n\n        /**\n         * Constructs a new ResponseApplySnapshotChunk.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ResponseApplySnapshotChunk.\n         * @implements IResponseApplySnapshotChunk\n         * @constructor\n         * @param {tendermint.abci.IResponseApplySnapshotChunk=} [properties] Properties to set\n         */\n        function ResponseApplySnapshotChunk(properties) {\n          this.refetchChunks = [];\n          this.rejectSenders = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ResponseApplySnapshotChunk result.\n         * @member {tendermint.abci.ResponseApplySnapshotChunk.Result} result\n         * @memberof tendermint.abci.ResponseApplySnapshotChunk\n         * @instance\n         */\n\n\n        ResponseApplySnapshotChunk.prototype.result = 0;\n        /**\n         * ResponseApplySnapshotChunk refetchChunks.\n         * @member {Array.<number>} refetchChunks\n         * @memberof tendermint.abci.ResponseApplySnapshotChunk\n         * @instance\n         */\n\n        ResponseApplySnapshotChunk.prototype.refetchChunks = $util.emptyArray;\n        /**\n         * ResponseApplySnapshotChunk rejectSenders.\n         * @member {Array.<string>} rejectSenders\n         * @memberof tendermint.abci.ResponseApplySnapshotChunk\n         * @instance\n         */\n\n        ResponseApplySnapshotChunk.prototype.rejectSenders = $util.emptyArray;\n        /**\n         * Creates a new ResponseApplySnapshotChunk instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ResponseApplySnapshotChunk\n         * @static\n         * @param {tendermint.abci.IResponseApplySnapshotChunk=} [properties] Properties to set\n         * @returns {tendermint.abci.ResponseApplySnapshotChunk} ResponseApplySnapshotChunk instance\n         */\n\n        ResponseApplySnapshotChunk.create = function create(properties) {\n          return new ResponseApplySnapshotChunk(properties);\n        };\n        /**\n         * Encodes the specified ResponseApplySnapshotChunk message. Does not implicitly {@link tendermint.abci.ResponseApplySnapshotChunk.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ResponseApplySnapshotChunk\n         * @static\n         * @param {tendermint.abci.IResponseApplySnapshotChunk} message ResponseApplySnapshotChunk message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseApplySnapshotChunk.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.result != null && Object.hasOwnProperty.call(message, \"result\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int32(message.result);\n\n          if (message.refetchChunks != null && message.refetchChunks.length) {\n            writer.uint32(\n            /* id 2, wireType 2 =*/\n            18).fork();\n\n            for (var i = 0; i < message.refetchChunks.length; ++i) {\n              writer.uint32(message.refetchChunks[i]);\n            }\n\n            writer.ldelim();\n          }\n\n          if (message.rejectSenders != null && message.rejectSenders.length) for (var i = 0; i < message.rejectSenders.length; ++i) {\n            writer.uint32(\n            /* id 3, wireType 2 =*/\n            26).string(message.rejectSenders[i]);\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified ResponseApplySnapshotChunk message, length delimited. Does not implicitly {@link tendermint.abci.ResponseApplySnapshotChunk.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ResponseApplySnapshotChunk\n         * @static\n         * @param {tendermint.abci.IResponseApplySnapshotChunk} message ResponseApplySnapshotChunk message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ResponseApplySnapshotChunk.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ResponseApplySnapshotChunk message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ResponseApplySnapshotChunk\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ResponseApplySnapshotChunk} ResponseApplySnapshotChunk\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseApplySnapshotChunk.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ResponseApplySnapshotChunk();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.result = reader.int32();\n                break;\n\n              case 2:\n                if (!(message.refetchChunks && message.refetchChunks.length)) message.refetchChunks = [];\n\n                if ((tag & 7) === 2) {\n                  var end2 = reader.uint32() + reader.pos;\n\n                  while (reader.pos < end2) {\n                    message.refetchChunks.push(reader.uint32());\n                  }\n                } else message.refetchChunks.push(reader.uint32());\n\n                break;\n\n              case 3:\n                if (!(message.rejectSenders && message.rejectSenders.length)) message.rejectSenders = [];\n                message.rejectSenders.push(reader.string());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ResponseApplySnapshotChunk message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ResponseApplySnapshotChunk\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ResponseApplySnapshotChunk} ResponseApplySnapshotChunk\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ResponseApplySnapshotChunk.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ResponseApplySnapshotChunk message.\n         * @function verify\n         * @memberof tendermint.abci.ResponseApplySnapshotChunk\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ResponseApplySnapshotChunk.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.result != null && message.hasOwnProperty(\"result\")) switch (message.result) {\n            default:\n              return \"result: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n              break;\n          }\n\n          if (message.refetchChunks != null && message.hasOwnProperty(\"refetchChunks\")) {\n            if (!Array.isArray(message.refetchChunks)) return \"refetchChunks: array expected\";\n\n            for (var i = 0; i < message.refetchChunks.length; ++i) {\n              if (!$util.isInteger(message.refetchChunks[i])) return \"refetchChunks: integer[] expected\";\n            }\n          }\n\n          if (message.rejectSenders != null && message.hasOwnProperty(\"rejectSenders\")) {\n            if (!Array.isArray(message.rejectSenders)) return \"rejectSenders: array expected\";\n\n            for (var i = 0; i < message.rejectSenders.length; ++i) {\n              if (!$util.isString(message.rejectSenders[i])) return \"rejectSenders: string[] expected\";\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a ResponseApplySnapshotChunk message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ResponseApplySnapshotChunk\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ResponseApplySnapshotChunk} ResponseApplySnapshotChunk\n         */\n\n\n        ResponseApplySnapshotChunk.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ResponseApplySnapshotChunk) return object;\n          var message = new $root.tendermint.abci.ResponseApplySnapshotChunk();\n\n          switch (object.result) {\n            case \"UNKNOWN\":\n            case 0:\n              message.result = 0;\n              break;\n\n            case \"ACCEPT\":\n            case 1:\n              message.result = 1;\n              break;\n\n            case \"ABORT\":\n            case 2:\n              message.result = 2;\n              break;\n\n            case \"RETRY\":\n            case 3:\n              message.result = 3;\n              break;\n\n            case \"RETRY_SNAPSHOT\":\n            case 4:\n              message.result = 4;\n              break;\n\n            case \"REJECT_SNAPSHOT\":\n            case 5:\n              message.result = 5;\n              break;\n          }\n\n          if (object.refetchChunks) {\n            if (!Array.isArray(object.refetchChunks)) throw TypeError(\".tendermint.abci.ResponseApplySnapshotChunk.refetchChunks: array expected\");\n            message.refetchChunks = [];\n\n            for (var i = 0; i < object.refetchChunks.length; ++i) {\n              message.refetchChunks[i] = object.refetchChunks[i] >>> 0;\n            }\n          }\n\n          if (object.rejectSenders) {\n            if (!Array.isArray(object.rejectSenders)) throw TypeError(\".tendermint.abci.ResponseApplySnapshotChunk.rejectSenders: array expected\");\n            message.rejectSenders = [];\n\n            for (var i = 0; i < object.rejectSenders.length; ++i) {\n              message.rejectSenders[i] = String(object.rejectSenders[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a ResponseApplySnapshotChunk message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ResponseApplySnapshotChunk\n         * @static\n         * @param {tendermint.abci.ResponseApplySnapshotChunk} message ResponseApplySnapshotChunk\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ResponseApplySnapshotChunk.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.arrays || options.defaults) {\n            object.refetchChunks = [];\n            object.rejectSenders = [];\n          }\n\n          if (options.defaults) object.result = options.enums === String ? \"UNKNOWN\" : 0;\n          if (message.result != null && message.hasOwnProperty(\"result\")) object.result = options.enums === String ? $root.tendermint.abci.ResponseApplySnapshotChunk.Result[message.result] : message.result;\n\n          if (message.refetchChunks && message.refetchChunks.length) {\n            object.refetchChunks = [];\n\n            for (var j = 0; j < message.refetchChunks.length; ++j) {\n              object.refetchChunks[j] = message.refetchChunks[j];\n            }\n          }\n\n          if (message.rejectSenders && message.rejectSenders.length) {\n            object.rejectSenders = [];\n\n            for (var j = 0; j < message.rejectSenders.length; ++j) {\n              object.rejectSenders[j] = message.rejectSenders[j];\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this ResponseApplySnapshotChunk to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ResponseApplySnapshotChunk\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ResponseApplySnapshotChunk.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        /**\n         * Result enum.\n         * @name tendermint.abci.ResponseApplySnapshotChunk.Result\n         * @enum {number}\n         * @property {number} UNKNOWN=0 UNKNOWN value\n         * @property {number} ACCEPT=1 ACCEPT value\n         * @property {number} ABORT=2 ABORT value\n         * @property {number} RETRY=3 RETRY value\n         * @property {number} RETRY_SNAPSHOT=4 RETRY_SNAPSHOT value\n         * @property {number} REJECT_SNAPSHOT=5 REJECT_SNAPSHOT value\n         */\n\n\n        ResponseApplySnapshotChunk.Result = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[0] = \"UNKNOWN\"] = 0;\n          values[valuesById[1] = \"ACCEPT\"] = 1;\n          values[valuesById[2] = \"ABORT\"] = 2;\n          values[valuesById[3] = \"RETRY\"] = 3;\n          values[valuesById[4] = \"RETRY_SNAPSHOT\"] = 4;\n          values[valuesById[5] = \"REJECT_SNAPSHOT\"] = 5;\n          return values;\n        }();\n\n        return ResponseApplySnapshotChunk;\n      }();\n\n      abci.ConsensusParams = function () {\n        /**\n         * Properties of a ConsensusParams.\n         * @memberof tendermint.abci\n         * @interface IConsensusParams\n         * @property {tendermint.abci.IBlockParams|null} [block] ConsensusParams block\n         * @property {tendermint.types.IEvidenceParams|null} [evidence] ConsensusParams evidence\n         * @property {tendermint.types.IValidatorParams|null} [validator] ConsensusParams validator\n         * @property {tendermint.types.IVersionParams|null} [version] ConsensusParams version\n         */\n\n        /**\n         * Constructs a new ConsensusParams.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ConsensusParams.\n         * @implements IConsensusParams\n         * @constructor\n         * @param {tendermint.abci.IConsensusParams=} [properties] Properties to set\n         */\n        function ConsensusParams(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ConsensusParams block.\n         * @member {tendermint.abci.IBlockParams|null|undefined} block\n         * @memberof tendermint.abci.ConsensusParams\n         * @instance\n         */\n\n\n        ConsensusParams.prototype.block = null;\n        /**\n         * ConsensusParams evidence.\n         * @member {tendermint.types.IEvidenceParams|null|undefined} evidence\n         * @memberof tendermint.abci.ConsensusParams\n         * @instance\n         */\n\n        ConsensusParams.prototype.evidence = null;\n        /**\n         * ConsensusParams validator.\n         * @member {tendermint.types.IValidatorParams|null|undefined} validator\n         * @memberof tendermint.abci.ConsensusParams\n         * @instance\n         */\n\n        ConsensusParams.prototype.validator = null;\n        /**\n         * ConsensusParams version.\n         * @member {tendermint.types.IVersionParams|null|undefined} version\n         * @memberof tendermint.abci.ConsensusParams\n         * @instance\n         */\n\n        ConsensusParams.prototype.version = null;\n        /**\n         * Creates a new ConsensusParams instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ConsensusParams\n         * @static\n         * @param {tendermint.abci.IConsensusParams=} [properties] Properties to set\n         * @returns {tendermint.abci.ConsensusParams} ConsensusParams instance\n         */\n\n        ConsensusParams.create = function create(properties) {\n          return new ConsensusParams(properties);\n        };\n        /**\n         * Encodes the specified ConsensusParams message. Does not implicitly {@link tendermint.abci.ConsensusParams.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ConsensusParams\n         * @static\n         * @param {tendermint.abci.IConsensusParams} message ConsensusParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ConsensusParams.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.block != null && Object.hasOwnProperty.call(message, \"block\")) $root.tendermint.abci.BlockParams.encode(message.block, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.evidence != null && Object.hasOwnProperty.call(message, \"evidence\")) $root.tendermint.types.EvidenceParams.encode(message.evidence, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          if (message.validator != null && Object.hasOwnProperty.call(message, \"validator\")) $root.tendermint.types.ValidatorParams.encode(message.validator, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          if (message.version != null && Object.hasOwnProperty.call(message, \"version\")) $root.tendermint.types.VersionParams.encode(message.version, writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified ConsensusParams message, length delimited. Does not implicitly {@link tendermint.abci.ConsensusParams.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ConsensusParams\n         * @static\n         * @param {tendermint.abci.IConsensusParams} message ConsensusParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ConsensusParams.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ConsensusParams message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ConsensusParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ConsensusParams} ConsensusParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ConsensusParams.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ConsensusParams();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.block = $root.tendermint.abci.BlockParams.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.evidence = $root.tendermint.types.EvidenceParams.decode(reader, reader.uint32());\n                break;\n\n              case 3:\n                message.validator = $root.tendermint.types.ValidatorParams.decode(reader, reader.uint32());\n                break;\n\n              case 4:\n                message.version = $root.tendermint.types.VersionParams.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ConsensusParams message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ConsensusParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ConsensusParams} ConsensusParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ConsensusParams.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ConsensusParams message.\n         * @function verify\n         * @memberof tendermint.abci.ConsensusParams\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ConsensusParams.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.block != null && message.hasOwnProperty(\"block\")) {\n            var error = $root.tendermint.abci.BlockParams.verify(message.block);\n            if (error) return \"block.\" + error;\n          }\n\n          if (message.evidence != null && message.hasOwnProperty(\"evidence\")) {\n            var error = $root.tendermint.types.EvidenceParams.verify(message.evidence);\n            if (error) return \"evidence.\" + error;\n          }\n\n          if (message.validator != null && message.hasOwnProperty(\"validator\")) {\n            var error = $root.tendermint.types.ValidatorParams.verify(message.validator);\n            if (error) return \"validator.\" + error;\n          }\n\n          if (message.version != null && message.hasOwnProperty(\"version\")) {\n            var error = $root.tendermint.types.VersionParams.verify(message.version);\n            if (error) return \"version.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a ConsensusParams message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ConsensusParams\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ConsensusParams} ConsensusParams\n         */\n\n\n        ConsensusParams.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ConsensusParams) return object;\n          var message = new $root.tendermint.abci.ConsensusParams();\n\n          if (object.block != null) {\n            if (typeof object.block !== \"object\") throw TypeError(\".tendermint.abci.ConsensusParams.block: object expected\");\n            message.block = $root.tendermint.abci.BlockParams.fromObject(object.block);\n          }\n\n          if (object.evidence != null) {\n            if (typeof object.evidence !== \"object\") throw TypeError(\".tendermint.abci.ConsensusParams.evidence: object expected\");\n            message.evidence = $root.tendermint.types.EvidenceParams.fromObject(object.evidence);\n          }\n\n          if (object.validator != null) {\n            if (typeof object.validator !== \"object\") throw TypeError(\".tendermint.abci.ConsensusParams.validator: object expected\");\n            message.validator = $root.tendermint.types.ValidatorParams.fromObject(object.validator);\n          }\n\n          if (object.version != null) {\n            if (typeof object.version !== \"object\") throw TypeError(\".tendermint.abci.ConsensusParams.version: object expected\");\n            message.version = $root.tendermint.types.VersionParams.fromObject(object.version);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a ConsensusParams message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ConsensusParams\n         * @static\n         * @param {tendermint.abci.ConsensusParams} message ConsensusParams\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ConsensusParams.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.block = null;\n            object.evidence = null;\n            object.validator = null;\n            object.version = null;\n          }\n\n          if (message.block != null && message.hasOwnProperty(\"block\")) object.block = $root.tendermint.abci.BlockParams.toObject(message.block, options);\n          if (message.evidence != null && message.hasOwnProperty(\"evidence\")) object.evidence = $root.tendermint.types.EvidenceParams.toObject(message.evidence, options);\n          if (message.validator != null && message.hasOwnProperty(\"validator\")) object.validator = $root.tendermint.types.ValidatorParams.toObject(message.validator, options);\n          if (message.version != null && message.hasOwnProperty(\"version\")) object.version = $root.tendermint.types.VersionParams.toObject(message.version, options);\n          return object;\n        };\n        /**\n         * Converts this ConsensusParams to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ConsensusParams\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ConsensusParams.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ConsensusParams;\n      }();\n\n      abci.BlockParams = function () {\n        /**\n         * Properties of a BlockParams.\n         * @memberof tendermint.abci\n         * @interface IBlockParams\n         * @property {number|Long|null} [maxBytes] BlockParams maxBytes\n         * @property {number|Long|null} [maxGas] BlockParams maxGas\n         */\n\n        /**\n         * Constructs a new BlockParams.\n         * @memberof tendermint.abci\n         * @classdesc Represents a BlockParams.\n         * @implements IBlockParams\n         * @constructor\n         * @param {tendermint.abci.IBlockParams=} [properties] Properties to set\n         */\n        function BlockParams(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * BlockParams maxBytes.\n         * @member {number|Long} maxBytes\n         * @memberof tendermint.abci.BlockParams\n         * @instance\n         */\n\n\n        BlockParams.prototype.maxBytes = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * BlockParams maxGas.\n         * @member {number|Long} maxGas\n         * @memberof tendermint.abci.BlockParams\n         * @instance\n         */\n\n        BlockParams.prototype.maxGas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new BlockParams instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.BlockParams\n         * @static\n         * @param {tendermint.abci.IBlockParams=} [properties] Properties to set\n         * @returns {tendermint.abci.BlockParams} BlockParams instance\n         */\n\n        BlockParams.create = function create(properties) {\n          return new BlockParams(properties);\n        };\n        /**\n         * Encodes the specified BlockParams message. Does not implicitly {@link tendermint.abci.BlockParams.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.BlockParams\n         * @static\n         * @param {tendermint.abci.IBlockParams} message BlockParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        BlockParams.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.maxBytes != null && Object.hasOwnProperty.call(message, \"maxBytes\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int64(message.maxBytes);\n          if (message.maxGas != null && Object.hasOwnProperty.call(message, \"maxGas\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int64(message.maxGas);\n          return writer;\n        };\n        /**\n         * Encodes the specified BlockParams message, length delimited. Does not implicitly {@link tendermint.abci.BlockParams.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.BlockParams\n         * @static\n         * @param {tendermint.abci.IBlockParams} message BlockParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        BlockParams.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a BlockParams message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.BlockParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.BlockParams} BlockParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        BlockParams.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.BlockParams();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.maxBytes = reader.int64();\n                break;\n\n              case 2:\n                message.maxGas = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a BlockParams message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.BlockParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.BlockParams} BlockParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        BlockParams.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a BlockParams message.\n         * @function verify\n         * @memberof tendermint.abci.BlockParams\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        BlockParams.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.maxBytes != null && message.hasOwnProperty(\"maxBytes\")) if (!$util.isInteger(message.maxBytes) && !(message.maxBytes && $util.isInteger(message.maxBytes.low) && $util.isInteger(message.maxBytes.high))) return \"maxBytes: integer|Long expected\";\n          if (message.maxGas != null && message.hasOwnProperty(\"maxGas\")) if (!$util.isInteger(message.maxGas) && !(message.maxGas && $util.isInteger(message.maxGas.low) && $util.isInteger(message.maxGas.high))) return \"maxGas: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a BlockParams message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.BlockParams\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.BlockParams} BlockParams\n         */\n\n\n        BlockParams.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.BlockParams) return object;\n          var message = new $root.tendermint.abci.BlockParams();\n          if (object.maxBytes != null) if ($util.Long) (message.maxBytes = $util.Long.fromValue(object.maxBytes)).unsigned = false;else if (typeof object.maxBytes === \"string\") message.maxBytes = parseInt(object.maxBytes, 10);else if (typeof object.maxBytes === \"number\") message.maxBytes = object.maxBytes;else if (typeof object.maxBytes === \"object\") message.maxBytes = new $util.LongBits(object.maxBytes.low >>> 0, object.maxBytes.high >>> 0).toNumber();\n          if (object.maxGas != null) if ($util.Long) (message.maxGas = $util.Long.fromValue(object.maxGas)).unsigned = false;else if (typeof object.maxGas === \"string\") message.maxGas = parseInt(object.maxGas, 10);else if (typeof object.maxGas === \"number\") message.maxGas = object.maxGas;else if (typeof object.maxGas === \"object\") message.maxGas = new $util.LongBits(object.maxGas.low >>> 0, object.maxGas.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a BlockParams message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.BlockParams\n         * @static\n         * @param {tendermint.abci.BlockParams} message BlockParams\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        BlockParams.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.maxBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.maxBytes = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.maxGas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.maxGas = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.maxBytes != null && message.hasOwnProperty(\"maxBytes\")) if (typeof message.maxBytes === \"number\") object.maxBytes = options.longs === String ? String(message.maxBytes) : message.maxBytes;else object.maxBytes = options.longs === String ? $util.Long.prototype.toString.call(message.maxBytes) : options.longs === Number ? new $util.LongBits(message.maxBytes.low >>> 0, message.maxBytes.high >>> 0).toNumber() : message.maxBytes;\n          if (message.maxGas != null && message.hasOwnProperty(\"maxGas\")) if (typeof message.maxGas === \"number\") object.maxGas = options.longs === String ? String(message.maxGas) : message.maxGas;else object.maxGas = options.longs === String ? $util.Long.prototype.toString.call(message.maxGas) : options.longs === Number ? new $util.LongBits(message.maxGas.low >>> 0, message.maxGas.high >>> 0).toNumber() : message.maxGas;\n          return object;\n        };\n        /**\n         * Converts this BlockParams to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.BlockParams\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        BlockParams.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BlockParams;\n      }();\n\n      abci.LastCommitInfo = function () {\n        /**\n         * Properties of a LastCommitInfo.\n         * @memberof tendermint.abci\n         * @interface ILastCommitInfo\n         * @property {number|null} [round] LastCommitInfo round\n         * @property {Array.<tendermint.abci.IVoteInfo>|null} [votes] LastCommitInfo votes\n         */\n\n        /**\n         * Constructs a new LastCommitInfo.\n         * @memberof tendermint.abci\n         * @classdesc Represents a LastCommitInfo.\n         * @implements ILastCommitInfo\n         * @constructor\n         * @param {tendermint.abci.ILastCommitInfo=} [properties] Properties to set\n         */\n        function LastCommitInfo(properties) {\n          this.votes = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * LastCommitInfo round.\n         * @member {number} round\n         * @memberof tendermint.abci.LastCommitInfo\n         * @instance\n         */\n\n\n        LastCommitInfo.prototype.round = 0;\n        /**\n         * LastCommitInfo votes.\n         * @member {Array.<tendermint.abci.IVoteInfo>} votes\n         * @memberof tendermint.abci.LastCommitInfo\n         * @instance\n         */\n\n        LastCommitInfo.prototype.votes = $util.emptyArray;\n        /**\n         * Creates a new LastCommitInfo instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.LastCommitInfo\n         * @static\n         * @param {tendermint.abci.ILastCommitInfo=} [properties] Properties to set\n         * @returns {tendermint.abci.LastCommitInfo} LastCommitInfo instance\n         */\n\n        LastCommitInfo.create = function create(properties) {\n          return new LastCommitInfo(properties);\n        };\n        /**\n         * Encodes the specified LastCommitInfo message. Does not implicitly {@link tendermint.abci.LastCommitInfo.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.LastCommitInfo\n         * @static\n         * @param {tendermint.abci.ILastCommitInfo} message LastCommitInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        LastCommitInfo.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.round != null && Object.hasOwnProperty.call(message, \"round\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int32(message.round);\n          if (message.votes != null && message.votes.length) for (var i = 0; i < message.votes.length; ++i) {\n            $root.tendermint.abci.VoteInfo.encode(message.votes[i], writer.uint32(\n            /* id 2, wireType 2 =*/\n            18).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified LastCommitInfo message, length delimited. Does not implicitly {@link tendermint.abci.LastCommitInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.LastCommitInfo\n         * @static\n         * @param {tendermint.abci.ILastCommitInfo} message LastCommitInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        LastCommitInfo.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a LastCommitInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.LastCommitInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.LastCommitInfo} LastCommitInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        LastCommitInfo.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.LastCommitInfo();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.round = reader.int32();\n                break;\n\n              case 2:\n                if (!(message.votes && message.votes.length)) message.votes = [];\n                message.votes.push($root.tendermint.abci.VoteInfo.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a LastCommitInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.LastCommitInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.LastCommitInfo} LastCommitInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        LastCommitInfo.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a LastCommitInfo message.\n         * @function verify\n         * @memberof tendermint.abci.LastCommitInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        LastCommitInfo.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.round != null && message.hasOwnProperty(\"round\")) if (!$util.isInteger(message.round)) return \"round: integer expected\";\n\n          if (message.votes != null && message.hasOwnProperty(\"votes\")) {\n            if (!Array.isArray(message.votes)) return \"votes: array expected\";\n\n            for (var i = 0; i < message.votes.length; ++i) {\n              var error = $root.tendermint.abci.VoteInfo.verify(message.votes[i]);\n              if (error) return \"votes.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a LastCommitInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.LastCommitInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.LastCommitInfo} LastCommitInfo\n         */\n\n\n        LastCommitInfo.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.LastCommitInfo) return object;\n          var message = new $root.tendermint.abci.LastCommitInfo();\n          if (object.round != null) message.round = object.round | 0;\n\n          if (object.votes) {\n            if (!Array.isArray(object.votes)) throw TypeError(\".tendermint.abci.LastCommitInfo.votes: array expected\");\n            message.votes = [];\n\n            for (var i = 0; i < object.votes.length; ++i) {\n              if (typeof object.votes[i] !== \"object\") throw TypeError(\".tendermint.abci.LastCommitInfo.votes: object expected\");\n              message.votes[i] = $root.tendermint.abci.VoteInfo.fromObject(object.votes[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a LastCommitInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.LastCommitInfo\n         * @static\n         * @param {tendermint.abci.LastCommitInfo} message LastCommitInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        LastCommitInfo.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.votes = [];\n          if (options.defaults) object.round = 0;\n          if (message.round != null && message.hasOwnProperty(\"round\")) object.round = message.round;\n\n          if (message.votes && message.votes.length) {\n            object.votes = [];\n\n            for (var j = 0; j < message.votes.length; ++j) {\n              object.votes[j] = $root.tendermint.abci.VoteInfo.toObject(message.votes[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this LastCommitInfo to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.LastCommitInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        LastCommitInfo.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LastCommitInfo;\n      }();\n\n      abci.Event = function () {\n        /**\n         * Properties of an Event.\n         * @memberof tendermint.abci\n         * @interface IEvent\n         * @property {string|null} [type] Event type\n         * @property {Array.<tendermint.abci.IEventAttribute>|null} [attributes] Event attributes\n         */\n\n        /**\n         * Constructs a new Event.\n         * @memberof tendermint.abci\n         * @classdesc Represents an Event.\n         * @implements IEvent\n         * @constructor\n         * @param {tendermint.abci.IEvent=} [properties] Properties to set\n         */\n        function Event(properties) {\n          this.attributes = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Event type.\n         * @member {string} type\n         * @memberof tendermint.abci.Event\n         * @instance\n         */\n\n\n        Event.prototype.type = \"\";\n        /**\n         * Event attributes.\n         * @member {Array.<tendermint.abci.IEventAttribute>} attributes\n         * @memberof tendermint.abci.Event\n         * @instance\n         */\n\n        Event.prototype.attributes = $util.emptyArray;\n        /**\n         * Creates a new Event instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.Event\n         * @static\n         * @param {tendermint.abci.IEvent=} [properties] Properties to set\n         * @returns {tendermint.abci.Event} Event instance\n         */\n\n        Event.create = function create(properties) {\n          return new Event(properties);\n        };\n        /**\n         * Encodes the specified Event message. Does not implicitly {@link tendermint.abci.Event.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.Event\n         * @static\n         * @param {tendermint.abci.IEvent} message Event message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Event.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.type);\n          if (message.attributes != null && message.attributes.length) for (var i = 0; i < message.attributes.length; ++i) {\n            $root.tendermint.abci.EventAttribute.encode(message.attributes[i], writer.uint32(\n            /* id 2, wireType 2 =*/\n            18).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified Event message, length delimited. Does not implicitly {@link tendermint.abci.Event.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.Event\n         * @static\n         * @param {tendermint.abci.IEvent} message Event message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Event.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an Event message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.Event\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.Event} Event\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Event.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.Event();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.type = reader.string();\n                break;\n\n              case 2:\n                if (!(message.attributes && message.attributes.length)) message.attributes = [];\n                message.attributes.push($root.tendermint.abci.EventAttribute.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an Event message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.Event\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.Event} Event\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Event.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an Event message.\n         * @function verify\n         * @memberof tendermint.abci.Event\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Event.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.type != null && message.hasOwnProperty(\"type\")) if (!$util.isString(message.type)) return \"type: string expected\";\n\n          if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n            if (!Array.isArray(message.attributes)) return \"attributes: array expected\";\n\n            for (var i = 0; i < message.attributes.length; ++i) {\n              var error = $root.tendermint.abci.EventAttribute.verify(message.attributes[i]);\n              if (error) return \"attributes.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates an Event message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.Event\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.Event} Event\n         */\n\n\n        Event.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.Event) return object;\n          var message = new $root.tendermint.abci.Event();\n          if (object.type != null) message.type = String(object.type);\n\n          if (object.attributes) {\n            if (!Array.isArray(object.attributes)) throw TypeError(\".tendermint.abci.Event.attributes: array expected\");\n            message.attributes = [];\n\n            for (var i = 0; i < object.attributes.length; ++i) {\n              if (typeof object.attributes[i] !== \"object\") throw TypeError(\".tendermint.abci.Event.attributes: object expected\");\n              message.attributes[i] = $root.tendermint.abci.EventAttribute.fromObject(object.attributes[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from an Event message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.Event\n         * @static\n         * @param {tendermint.abci.Event} message Event\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Event.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.attributes = [];\n          if (options.defaults) object.type = \"\";\n          if (message.type != null && message.hasOwnProperty(\"type\")) object.type = message.type;\n\n          if (message.attributes && message.attributes.length) {\n            object.attributes = [];\n\n            for (var j = 0; j < message.attributes.length; ++j) {\n              object.attributes[j] = $root.tendermint.abci.EventAttribute.toObject(message.attributes[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this Event to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.Event\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Event.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Event;\n      }();\n\n      abci.EventAttribute = function () {\n        /**\n         * Properties of an EventAttribute.\n         * @memberof tendermint.abci\n         * @interface IEventAttribute\n         * @property {Uint8Array|null} [key] EventAttribute key\n         * @property {Uint8Array|null} [value] EventAttribute value\n         * @property {boolean|null} [index] EventAttribute index\n         */\n\n        /**\n         * Constructs a new EventAttribute.\n         * @memberof tendermint.abci\n         * @classdesc Represents an EventAttribute.\n         * @implements IEventAttribute\n         * @constructor\n         * @param {tendermint.abci.IEventAttribute=} [properties] Properties to set\n         */\n        function EventAttribute(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * EventAttribute key.\n         * @member {Uint8Array} key\n         * @memberof tendermint.abci.EventAttribute\n         * @instance\n         */\n\n\n        EventAttribute.prototype.key = $util.newBuffer([]);\n        /**\n         * EventAttribute value.\n         * @member {Uint8Array} value\n         * @memberof tendermint.abci.EventAttribute\n         * @instance\n         */\n\n        EventAttribute.prototype.value = $util.newBuffer([]);\n        /**\n         * EventAttribute index.\n         * @member {boolean} index\n         * @memberof tendermint.abci.EventAttribute\n         * @instance\n         */\n\n        EventAttribute.prototype.index = false;\n        /**\n         * Creates a new EventAttribute instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.EventAttribute\n         * @static\n         * @param {tendermint.abci.IEventAttribute=} [properties] Properties to set\n         * @returns {tendermint.abci.EventAttribute} EventAttribute instance\n         */\n\n        EventAttribute.create = function create(properties) {\n          return new EventAttribute(properties);\n        };\n        /**\n         * Encodes the specified EventAttribute message. Does not implicitly {@link tendermint.abci.EventAttribute.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.EventAttribute\n         * @static\n         * @param {tendermint.abci.IEventAttribute} message EventAttribute message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EventAttribute.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.key != null && Object.hasOwnProperty.call(message, \"key\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).bytes(message.key);\n          if (message.value != null && Object.hasOwnProperty.call(message, \"value\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.value);\n          if (message.index != null && Object.hasOwnProperty.call(message, \"index\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).bool(message.index);\n          return writer;\n        };\n        /**\n         * Encodes the specified EventAttribute message, length delimited. Does not implicitly {@link tendermint.abci.EventAttribute.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.EventAttribute\n         * @static\n         * @param {tendermint.abci.IEventAttribute} message EventAttribute message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EventAttribute.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an EventAttribute message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.EventAttribute\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.EventAttribute} EventAttribute\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EventAttribute.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.EventAttribute();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.key = reader.bytes();\n                break;\n\n              case 2:\n                message.value = reader.bytes();\n                break;\n\n              case 3:\n                message.index = reader.bool();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an EventAttribute message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.EventAttribute\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.EventAttribute} EventAttribute\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EventAttribute.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an EventAttribute message.\n         * @function verify\n         * @memberof tendermint.abci.EventAttribute\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        EventAttribute.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.key != null && message.hasOwnProperty(\"key\")) if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key))) return \"key: buffer expected\";\n          if (message.value != null && message.hasOwnProperty(\"value\")) if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value))) return \"value: buffer expected\";\n          if (message.index != null && message.hasOwnProperty(\"index\")) if (typeof message.index !== \"boolean\") return \"index: boolean expected\";\n          return null;\n        };\n        /**\n         * Creates an EventAttribute message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.EventAttribute\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.EventAttribute} EventAttribute\n         */\n\n\n        EventAttribute.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.EventAttribute) return object;\n          var message = new $root.tendermint.abci.EventAttribute();\n          if (object.key != null) if (typeof object.key === \"string\") $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);else if (object.key.length) message.key = object.key;\n          if (object.value != null) if (typeof object.value === \"string\") $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);else if (object.value.length) message.value = object.value;\n          if (object.index != null) message.index = Boolean(object.index);\n          return message;\n        };\n        /**\n         * Creates a plain object from an EventAttribute message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.EventAttribute\n         * @static\n         * @param {tendermint.abci.EventAttribute} message EventAttribute\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        EventAttribute.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if (options.bytes === String) object.key = \"\";else {\n              object.key = [];\n              if (options.bytes !== Array) object.key = $util.newBuffer(object.key);\n            }\n            if (options.bytes === String) object.value = \"\";else {\n              object.value = [];\n              if (options.bytes !== Array) object.value = $util.newBuffer(object.value);\n            }\n            object.index = false;\n          }\n\n          if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n          if (message.value != null && message.hasOwnProperty(\"value\")) object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n          if (message.index != null && message.hasOwnProperty(\"index\")) object.index = message.index;\n          return object;\n        };\n        /**\n         * Converts this EventAttribute to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.EventAttribute\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        EventAttribute.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return EventAttribute;\n      }();\n\n      abci.TxResult = function () {\n        /**\n         * Properties of a TxResult.\n         * @memberof tendermint.abci\n         * @interface ITxResult\n         * @property {number|Long|null} [height] TxResult height\n         * @property {number|null} [index] TxResult index\n         * @property {Uint8Array|null} [tx] TxResult tx\n         * @property {tendermint.abci.IResponseDeliverTx|null} [result] TxResult result\n         */\n\n        /**\n         * Constructs a new TxResult.\n         * @memberof tendermint.abci\n         * @classdesc Represents a TxResult.\n         * @implements ITxResult\n         * @constructor\n         * @param {tendermint.abci.ITxResult=} [properties] Properties to set\n         */\n        function TxResult(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * TxResult height.\n         * @member {number|Long} height\n         * @memberof tendermint.abci.TxResult\n         * @instance\n         */\n\n\n        TxResult.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * TxResult index.\n         * @member {number} index\n         * @memberof tendermint.abci.TxResult\n         * @instance\n         */\n\n        TxResult.prototype.index = 0;\n        /**\n         * TxResult tx.\n         * @member {Uint8Array} tx\n         * @memberof tendermint.abci.TxResult\n         * @instance\n         */\n\n        TxResult.prototype.tx = $util.newBuffer([]);\n        /**\n         * TxResult result.\n         * @member {tendermint.abci.IResponseDeliverTx|null|undefined} result\n         * @memberof tendermint.abci.TxResult\n         * @instance\n         */\n\n        TxResult.prototype.result = null;\n        /**\n         * Creates a new TxResult instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.TxResult\n         * @static\n         * @param {tendermint.abci.ITxResult=} [properties] Properties to set\n         * @returns {tendermint.abci.TxResult} TxResult instance\n         */\n\n        TxResult.create = function create(properties) {\n          return new TxResult(properties);\n        };\n        /**\n         * Encodes the specified TxResult message. Does not implicitly {@link tendermint.abci.TxResult.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.TxResult\n         * @static\n         * @param {tendermint.abci.ITxResult} message TxResult message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        TxResult.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.height != null && Object.hasOwnProperty.call(message, \"height\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int64(message.height);\n          if (message.index != null && Object.hasOwnProperty.call(message, \"index\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).uint32(message.index);\n          if (message.tx != null && Object.hasOwnProperty.call(message, \"tx\")) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).bytes(message.tx);\n          if (message.result != null && Object.hasOwnProperty.call(message, \"result\")) $root.tendermint.abci.ResponseDeliverTx.encode(message.result, writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified TxResult message, length delimited. Does not implicitly {@link tendermint.abci.TxResult.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.TxResult\n         * @static\n         * @param {tendermint.abci.ITxResult} message TxResult message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        TxResult.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a TxResult message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.TxResult\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.TxResult} TxResult\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        TxResult.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.TxResult();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.height = reader.int64();\n                break;\n\n              case 2:\n                message.index = reader.uint32();\n                break;\n\n              case 3:\n                message.tx = reader.bytes();\n                break;\n\n              case 4:\n                message.result = $root.tendermint.abci.ResponseDeliverTx.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a TxResult message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.TxResult\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.TxResult} TxResult\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        TxResult.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a TxResult message.\n         * @function verify\n         * @memberof tendermint.abci.TxResult\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        TxResult.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))) return \"height: integer|Long expected\";\n          if (message.index != null && message.hasOwnProperty(\"index\")) if (!$util.isInteger(message.index)) return \"index: integer expected\";\n          if (message.tx != null && message.hasOwnProperty(\"tx\")) if (!(message.tx && typeof message.tx.length === \"number\" || $util.isString(message.tx))) return \"tx: buffer expected\";\n\n          if (message.result != null && message.hasOwnProperty(\"result\")) {\n            var error = $root.tendermint.abci.ResponseDeliverTx.verify(message.result);\n            if (error) return \"result.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a TxResult message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.TxResult\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.TxResult} TxResult\n         */\n\n\n        TxResult.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.TxResult) return object;\n          var message = new $root.tendermint.abci.TxResult();\n          if (object.height != null) if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;else if (typeof object.height === \"string\") message.height = parseInt(object.height, 10);else if (typeof object.height === \"number\") message.height = object.height;else if (typeof object.height === \"object\") message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();\n          if (object.index != null) message.index = object.index >>> 0;\n          if (object.tx != null) if (typeof object.tx === \"string\") $util.base64.decode(object.tx, message.tx = $util.newBuffer($util.base64.length(object.tx)), 0);else if (object.tx.length) message.tx = object.tx;\n\n          if (object.result != null) {\n            if (typeof object.result !== \"object\") throw TypeError(\".tendermint.abci.TxResult.result: object expected\");\n            message.result = $root.tendermint.abci.ResponseDeliverTx.fromObject(object.result);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a TxResult message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.TxResult\n         * @static\n         * @param {tendermint.abci.TxResult} message TxResult\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        TxResult.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.height = options.longs === String ? \"0\" : 0;\n\n            object.index = 0;\n            if (options.bytes === String) object.tx = \"\";else {\n              object.tx = [];\n              if (options.bytes !== Array) object.tx = $util.newBuffer(object.tx);\n            }\n            object.result = null;\n          }\n\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (typeof message.height === \"number\") object.height = options.longs === String ? String(message.height) : message.height;else object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;\n          if (message.index != null && message.hasOwnProperty(\"index\")) object.index = message.index;\n          if (message.tx != null && message.hasOwnProperty(\"tx\")) object.tx = options.bytes === String ? $util.base64.encode(message.tx, 0, message.tx.length) : options.bytes === Array ? Array.prototype.slice.call(message.tx) : message.tx;\n          if (message.result != null && message.hasOwnProperty(\"result\")) object.result = $root.tendermint.abci.ResponseDeliverTx.toObject(message.result, options);\n          return object;\n        };\n        /**\n         * Converts this TxResult to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.TxResult\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        TxResult.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return TxResult;\n      }();\n\n      abci.Validator = function () {\n        /**\n         * Properties of a Validator.\n         * @memberof tendermint.abci\n         * @interface IValidator\n         * @property {Uint8Array|null} [address] Validator address\n         * @property {number|Long|null} [power] Validator power\n         */\n\n        /**\n         * Constructs a new Validator.\n         * @memberof tendermint.abci\n         * @classdesc Represents a Validator.\n         * @implements IValidator\n         * @constructor\n         * @param {tendermint.abci.IValidator=} [properties] Properties to set\n         */\n        function Validator(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Validator address.\n         * @member {Uint8Array} address\n         * @memberof tendermint.abci.Validator\n         * @instance\n         */\n\n\n        Validator.prototype.address = $util.newBuffer([]);\n        /**\n         * Validator power.\n         * @member {number|Long} power\n         * @memberof tendermint.abci.Validator\n         * @instance\n         */\n\n        Validator.prototype.power = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new Validator instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.Validator\n         * @static\n         * @param {tendermint.abci.IValidator=} [properties] Properties to set\n         * @returns {tendermint.abci.Validator} Validator instance\n         */\n\n        Validator.create = function create(properties) {\n          return new Validator(properties);\n        };\n        /**\n         * Encodes the specified Validator message. Does not implicitly {@link tendermint.abci.Validator.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.Validator\n         * @static\n         * @param {tendermint.abci.IValidator} message Validator message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Validator.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.address != null && Object.hasOwnProperty.call(message, \"address\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).bytes(message.address);\n          if (message.power != null && Object.hasOwnProperty.call(message, \"power\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int64(message.power);\n          return writer;\n        };\n        /**\n         * Encodes the specified Validator message, length delimited. Does not implicitly {@link tendermint.abci.Validator.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.Validator\n         * @static\n         * @param {tendermint.abci.IValidator} message Validator message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Validator.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Validator message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.Validator\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.Validator} Validator\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Validator.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.Validator();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.address = reader.bytes();\n                break;\n\n              case 3:\n                message.power = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Validator message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.Validator\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.Validator} Validator\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Validator.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Validator message.\n         * @function verify\n         * @memberof tendermint.abci.Validator\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Validator.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.address != null && message.hasOwnProperty(\"address\")) if (!(message.address && typeof message.address.length === \"number\" || $util.isString(message.address))) return \"address: buffer expected\";\n          if (message.power != null && message.hasOwnProperty(\"power\")) if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high))) return \"power: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a Validator message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.Validator\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.Validator} Validator\n         */\n\n\n        Validator.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.Validator) return object;\n          var message = new $root.tendermint.abci.Validator();\n          if (object.address != null) if (typeof object.address === \"string\") $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);else if (object.address.length) message.address = object.address;\n          if (object.power != null) if ($util.Long) (message.power = $util.Long.fromValue(object.power)).unsigned = false;else if (typeof object.power === \"string\") message.power = parseInt(object.power, 10);else if (typeof object.power === \"number\") message.power = object.power;else if (typeof object.power === \"object\") message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a Validator message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.Validator\n         * @static\n         * @param {tendermint.abci.Validator} message Validator\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Validator.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if (options.bytes === String) object.address = \"\";else {\n              object.address = [];\n              if (options.bytes !== Array) object.address = $util.newBuffer(object.address);\n            }\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.power = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.address != null && message.hasOwnProperty(\"address\")) object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;\n          if (message.power != null && message.hasOwnProperty(\"power\")) if (typeof message.power === \"number\") object.power = options.longs === String ? String(message.power) : message.power;else object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;\n          return object;\n        };\n        /**\n         * Converts this Validator to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.Validator\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Validator.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Validator;\n      }();\n\n      abci.ValidatorUpdate = function () {\n        /**\n         * Properties of a ValidatorUpdate.\n         * @memberof tendermint.abci\n         * @interface IValidatorUpdate\n         * @property {tendermint.crypto.IPublicKey|null} [pubKey] ValidatorUpdate pubKey\n         * @property {number|Long|null} [power] ValidatorUpdate power\n         */\n\n        /**\n         * Constructs a new ValidatorUpdate.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ValidatorUpdate.\n         * @implements IValidatorUpdate\n         * @constructor\n         * @param {tendermint.abci.IValidatorUpdate=} [properties] Properties to set\n         */\n        function ValidatorUpdate(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ValidatorUpdate pubKey.\n         * @member {tendermint.crypto.IPublicKey|null|undefined} pubKey\n         * @memberof tendermint.abci.ValidatorUpdate\n         * @instance\n         */\n\n\n        ValidatorUpdate.prototype.pubKey = null;\n        /**\n         * ValidatorUpdate power.\n         * @member {number|Long} power\n         * @memberof tendermint.abci.ValidatorUpdate\n         * @instance\n         */\n\n        ValidatorUpdate.prototype.power = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new ValidatorUpdate instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.ValidatorUpdate\n         * @static\n         * @param {tendermint.abci.IValidatorUpdate=} [properties] Properties to set\n         * @returns {tendermint.abci.ValidatorUpdate} ValidatorUpdate instance\n         */\n\n        ValidatorUpdate.create = function create(properties) {\n          return new ValidatorUpdate(properties);\n        };\n        /**\n         * Encodes the specified ValidatorUpdate message. Does not implicitly {@link tendermint.abci.ValidatorUpdate.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.ValidatorUpdate\n         * @static\n         * @param {tendermint.abci.IValidatorUpdate} message ValidatorUpdate message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ValidatorUpdate.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.pubKey != null && Object.hasOwnProperty.call(message, \"pubKey\")) $root.tendermint.crypto.PublicKey.encode(message.pubKey, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.power != null && Object.hasOwnProperty.call(message, \"power\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int64(message.power);\n          return writer;\n        };\n        /**\n         * Encodes the specified ValidatorUpdate message, length delimited. Does not implicitly {@link tendermint.abci.ValidatorUpdate.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.ValidatorUpdate\n         * @static\n         * @param {tendermint.abci.IValidatorUpdate} message ValidatorUpdate message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ValidatorUpdate.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ValidatorUpdate message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.ValidatorUpdate\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.ValidatorUpdate} ValidatorUpdate\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ValidatorUpdate.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.ValidatorUpdate();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.pubKey = $root.tendermint.crypto.PublicKey.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.power = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ValidatorUpdate message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.ValidatorUpdate\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.ValidatorUpdate} ValidatorUpdate\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ValidatorUpdate.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ValidatorUpdate message.\n         * @function verify\n         * @memberof tendermint.abci.ValidatorUpdate\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ValidatorUpdate.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.pubKey != null && message.hasOwnProperty(\"pubKey\")) {\n            var error = $root.tendermint.crypto.PublicKey.verify(message.pubKey);\n            if (error) return \"pubKey.\" + error;\n          }\n\n          if (message.power != null && message.hasOwnProperty(\"power\")) if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high))) return \"power: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a ValidatorUpdate message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.ValidatorUpdate\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.ValidatorUpdate} ValidatorUpdate\n         */\n\n\n        ValidatorUpdate.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.ValidatorUpdate) return object;\n          var message = new $root.tendermint.abci.ValidatorUpdate();\n\n          if (object.pubKey != null) {\n            if (typeof object.pubKey !== \"object\") throw TypeError(\".tendermint.abci.ValidatorUpdate.pubKey: object expected\");\n            message.pubKey = $root.tendermint.crypto.PublicKey.fromObject(object.pubKey);\n          }\n\n          if (object.power != null) if ($util.Long) (message.power = $util.Long.fromValue(object.power)).unsigned = false;else if (typeof object.power === \"string\") message.power = parseInt(object.power, 10);else if (typeof object.power === \"number\") message.power = object.power;else if (typeof object.power === \"object\") message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a ValidatorUpdate message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.ValidatorUpdate\n         * @static\n         * @param {tendermint.abci.ValidatorUpdate} message ValidatorUpdate\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ValidatorUpdate.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.pubKey = null;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.power = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.pubKey != null && message.hasOwnProperty(\"pubKey\")) object.pubKey = $root.tendermint.crypto.PublicKey.toObject(message.pubKey, options);\n          if (message.power != null && message.hasOwnProperty(\"power\")) if (typeof message.power === \"number\") object.power = options.longs === String ? String(message.power) : message.power;else object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;\n          return object;\n        };\n        /**\n         * Converts this ValidatorUpdate to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.ValidatorUpdate\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ValidatorUpdate.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ValidatorUpdate;\n      }();\n\n      abci.VoteInfo = function () {\n        /**\n         * Properties of a VoteInfo.\n         * @memberof tendermint.abci\n         * @interface IVoteInfo\n         * @property {tendermint.abci.IValidator|null} [validator] VoteInfo validator\n         * @property {boolean|null} [signedLastBlock] VoteInfo signedLastBlock\n         */\n\n        /**\n         * Constructs a new VoteInfo.\n         * @memberof tendermint.abci\n         * @classdesc Represents a VoteInfo.\n         * @implements IVoteInfo\n         * @constructor\n         * @param {tendermint.abci.IVoteInfo=} [properties] Properties to set\n         */\n        function VoteInfo(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * VoteInfo validator.\n         * @member {tendermint.abci.IValidator|null|undefined} validator\n         * @memberof tendermint.abci.VoteInfo\n         * @instance\n         */\n\n\n        VoteInfo.prototype.validator = null;\n        /**\n         * VoteInfo signedLastBlock.\n         * @member {boolean} signedLastBlock\n         * @memberof tendermint.abci.VoteInfo\n         * @instance\n         */\n\n        VoteInfo.prototype.signedLastBlock = false;\n        /**\n         * Creates a new VoteInfo instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.VoteInfo\n         * @static\n         * @param {tendermint.abci.IVoteInfo=} [properties] Properties to set\n         * @returns {tendermint.abci.VoteInfo} VoteInfo instance\n         */\n\n        VoteInfo.create = function create(properties) {\n          return new VoteInfo(properties);\n        };\n        /**\n         * Encodes the specified VoteInfo message. Does not implicitly {@link tendermint.abci.VoteInfo.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.VoteInfo\n         * @static\n         * @param {tendermint.abci.IVoteInfo} message VoteInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        VoteInfo.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.validator != null && Object.hasOwnProperty.call(message, \"validator\")) $root.tendermint.abci.Validator.encode(message.validator, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.signedLastBlock != null && Object.hasOwnProperty.call(message, \"signedLastBlock\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).bool(message.signedLastBlock);\n          return writer;\n        };\n        /**\n         * Encodes the specified VoteInfo message, length delimited. Does not implicitly {@link tendermint.abci.VoteInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.VoteInfo\n         * @static\n         * @param {tendermint.abci.IVoteInfo} message VoteInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        VoteInfo.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a VoteInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.VoteInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.VoteInfo} VoteInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        VoteInfo.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.VoteInfo();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.validator = $root.tendermint.abci.Validator.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.signedLastBlock = reader.bool();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a VoteInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.VoteInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.VoteInfo} VoteInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        VoteInfo.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a VoteInfo message.\n         * @function verify\n         * @memberof tendermint.abci.VoteInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        VoteInfo.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.validator != null && message.hasOwnProperty(\"validator\")) {\n            var error = $root.tendermint.abci.Validator.verify(message.validator);\n            if (error) return \"validator.\" + error;\n          }\n\n          if (message.signedLastBlock != null && message.hasOwnProperty(\"signedLastBlock\")) if (typeof message.signedLastBlock !== \"boolean\") return \"signedLastBlock: boolean expected\";\n          return null;\n        };\n        /**\n         * Creates a VoteInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.VoteInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.VoteInfo} VoteInfo\n         */\n\n\n        VoteInfo.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.VoteInfo) return object;\n          var message = new $root.tendermint.abci.VoteInfo();\n\n          if (object.validator != null) {\n            if (typeof object.validator !== \"object\") throw TypeError(\".tendermint.abci.VoteInfo.validator: object expected\");\n            message.validator = $root.tendermint.abci.Validator.fromObject(object.validator);\n          }\n\n          if (object.signedLastBlock != null) message.signedLastBlock = Boolean(object.signedLastBlock);\n          return message;\n        };\n        /**\n         * Creates a plain object from a VoteInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.VoteInfo\n         * @static\n         * @param {tendermint.abci.VoteInfo} message VoteInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        VoteInfo.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.validator = null;\n            object.signedLastBlock = false;\n          }\n\n          if (message.validator != null && message.hasOwnProperty(\"validator\")) object.validator = $root.tendermint.abci.Validator.toObject(message.validator, options);\n          if (message.signedLastBlock != null && message.hasOwnProperty(\"signedLastBlock\")) object.signedLastBlock = message.signedLastBlock;\n          return object;\n        };\n        /**\n         * Converts this VoteInfo to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.VoteInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        VoteInfo.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return VoteInfo;\n      }();\n      /**\n       * EvidenceType enum.\n       * @name tendermint.abci.EvidenceType\n       * @enum {number}\n       * @property {number} UNKNOWN=0 UNKNOWN value\n       * @property {number} DUPLICATE_VOTE=1 DUPLICATE_VOTE value\n       * @property {number} LIGHT_CLIENT_ATTACK=2 LIGHT_CLIENT_ATTACK value\n       */\n\n\n      abci.EvidenceType = function () {\n        var valuesById = {},\n            values = Object.create(valuesById);\n        values[valuesById[0] = \"UNKNOWN\"] = 0;\n        values[valuesById[1] = \"DUPLICATE_VOTE\"] = 1;\n        values[valuesById[2] = \"LIGHT_CLIENT_ATTACK\"] = 2;\n        return values;\n      }();\n\n      abci.Evidence = function () {\n        /**\n         * Properties of an Evidence.\n         * @memberof tendermint.abci\n         * @interface IEvidence\n         * @property {tendermint.abci.EvidenceType|null} [type] Evidence type\n         * @property {tendermint.abci.IValidator|null} [validator] Evidence validator\n         * @property {number|Long|null} [height] Evidence height\n         * @property {google.protobuf.ITimestamp|null} [time] Evidence time\n         * @property {number|Long|null} [totalVotingPower] Evidence totalVotingPower\n         */\n\n        /**\n         * Constructs a new Evidence.\n         * @memberof tendermint.abci\n         * @classdesc Represents an Evidence.\n         * @implements IEvidence\n         * @constructor\n         * @param {tendermint.abci.IEvidence=} [properties] Properties to set\n         */\n        function Evidence(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Evidence type.\n         * @member {tendermint.abci.EvidenceType} type\n         * @memberof tendermint.abci.Evidence\n         * @instance\n         */\n\n\n        Evidence.prototype.type = 0;\n        /**\n         * Evidence validator.\n         * @member {tendermint.abci.IValidator|null|undefined} validator\n         * @memberof tendermint.abci.Evidence\n         * @instance\n         */\n\n        Evidence.prototype.validator = null;\n        /**\n         * Evidence height.\n         * @member {number|Long} height\n         * @memberof tendermint.abci.Evidence\n         * @instance\n         */\n\n        Evidence.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Evidence time.\n         * @member {google.protobuf.ITimestamp|null|undefined} time\n         * @memberof tendermint.abci.Evidence\n         * @instance\n         */\n\n        Evidence.prototype.time = null;\n        /**\n         * Evidence totalVotingPower.\n         * @member {number|Long} totalVotingPower\n         * @memberof tendermint.abci.Evidence\n         * @instance\n         */\n\n        Evidence.prototype.totalVotingPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new Evidence instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.Evidence\n         * @static\n         * @param {tendermint.abci.IEvidence=} [properties] Properties to set\n         * @returns {tendermint.abci.Evidence} Evidence instance\n         */\n\n        Evidence.create = function create(properties) {\n          return new Evidence(properties);\n        };\n        /**\n         * Encodes the specified Evidence message. Does not implicitly {@link tendermint.abci.Evidence.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.Evidence\n         * @static\n         * @param {tendermint.abci.IEvidence} message Evidence message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Evidence.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int32(message.type);\n          if (message.validator != null && Object.hasOwnProperty.call(message, \"validator\")) $root.tendermint.abci.Validator.encode(message.validator, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          if (message.height != null && Object.hasOwnProperty.call(message, \"height\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int64(message.height);\n          if (message.time != null && Object.hasOwnProperty.call(message, \"time\")) $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).fork()).ldelim();\n          if (message.totalVotingPower != null && Object.hasOwnProperty.call(message, \"totalVotingPower\")) writer.uint32(\n          /* id 5, wireType 0 =*/\n          40).int64(message.totalVotingPower);\n          return writer;\n        };\n        /**\n         * Encodes the specified Evidence message, length delimited. Does not implicitly {@link tendermint.abci.Evidence.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.Evidence\n         * @static\n         * @param {tendermint.abci.IEvidence} message Evidence message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Evidence.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an Evidence message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.Evidence\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.Evidence} Evidence\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Evidence.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.Evidence();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.type = reader.int32();\n                break;\n\n              case 2:\n                message.validator = $root.tendermint.abci.Validator.decode(reader, reader.uint32());\n                break;\n\n              case 3:\n                message.height = reader.int64();\n                break;\n\n              case 4:\n                message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n\n              case 5:\n                message.totalVotingPower = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an Evidence message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.Evidence\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.Evidence} Evidence\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Evidence.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an Evidence message.\n         * @function verify\n         * @memberof tendermint.abci.Evidence\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Evidence.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.type != null && message.hasOwnProperty(\"type\")) switch (message.type) {\n            default:\n              return \"type: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n              break;\n          }\n\n          if (message.validator != null && message.hasOwnProperty(\"validator\")) {\n            var error = $root.tendermint.abci.Validator.verify(message.validator);\n            if (error) return \"validator.\" + error;\n          }\n\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))) return \"height: integer|Long expected\";\n\n          if (message.time != null && message.hasOwnProperty(\"time\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.time);\n            if (error) return \"time.\" + error;\n          }\n\n          if (message.totalVotingPower != null && message.hasOwnProperty(\"totalVotingPower\")) if (!$util.isInteger(message.totalVotingPower) && !(message.totalVotingPower && $util.isInteger(message.totalVotingPower.low) && $util.isInteger(message.totalVotingPower.high))) return \"totalVotingPower: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates an Evidence message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.Evidence\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.Evidence} Evidence\n         */\n\n\n        Evidence.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.Evidence) return object;\n          var message = new $root.tendermint.abci.Evidence();\n\n          switch (object.type) {\n            case \"UNKNOWN\":\n            case 0:\n              message.type = 0;\n              break;\n\n            case \"DUPLICATE_VOTE\":\n            case 1:\n              message.type = 1;\n              break;\n\n            case \"LIGHT_CLIENT_ATTACK\":\n            case 2:\n              message.type = 2;\n              break;\n          }\n\n          if (object.validator != null) {\n            if (typeof object.validator !== \"object\") throw TypeError(\".tendermint.abci.Evidence.validator: object expected\");\n            message.validator = $root.tendermint.abci.Validator.fromObject(object.validator);\n          }\n\n          if (object.height != null) if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;else if (typeof object.height === \"string\") message.height = parseInt(object.height, 10);else if (typeof object.height === \"number\") message.height = object.height;else if (typeof object.height === \"object\") message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();\n\n          if (object.time != null) {\n            if (typeof object.time !== \"object\") throw TypeError(\".tendermint.abci.Evidence.time: object expected\");\n            message.time = $root.google.protobuf.Timestamp.fromObject(object.time);\n          }\n\n          if (object.totalVotingPower != null) if ($util.Long) (message.totalVotingPower = $util.Long.fromValue(object.totalVotingPower)).unsigned = false;else if (typeof object.totalVotingPower === \"string\") message.totalVotingPower = parseInt(object.totalVotingPower, 10);else if (typeof object.totalVotingPower === \"number\") message.totalVotingPower = object.totalVotingPower;else if (typeof object.totalVotingPower === \"object\") message.totalVotingPower = new $util.LongBits(object.totalVotingPower.low >>> 0, object.totalVotingPower.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from an Evidence message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.Evidence\n         * @static\n         * @param {tendermint.abci.Evidence} message Evidence\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Evidence.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.type = options.enums === String ? \"UNKNOWN\" : 0;\n            object.validator = null;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.height = options.longs === String ? \"0\" : 0;\n\n            object.time = null;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.totalVotingPower = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.totalVotingPower = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.type != null && message.hasOwnProperty(\"type\")) object.type = options.enums === String ? $root.tendermint.abci.EvidenceType[message.type] : message.type;\n          if (message.validator != null && message.hasOwnProperty(\"validator\")) object.validator = $root.tendermint.abci.Validator.toObject(message.validator, options);\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (typeof message.height === \"number\") object.height = options.longs === String ? String(message.height) : message.height;else object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;\n          if (message.time != null && message.hasOwnProperty(\"time\")) object.time = $root.google.protobuf.Timestamp.toObject(message.time, options);\n          if (message.totalVotingPower != null && message.hasOwnProperty(\"totalVotingPower\")) if (typeof message.totalVotingPower === \"number\") object.totalVotingPower = options.longs === String ? String(message.totalVotingPower) : message.totalVotingPower;else object.totalVotingPower = options.longs === String ? $util.Long.prototype.toString.call(message.totalVotingPower) : options.longs === Number ? new $util.LongBits(message.totalVotingPower.low >>> 0, message.totalVotingPower.high >>> 0).toNumber() : message.totalVotingPower;\n          return object;\n        };\n        /**\n         * Converts this Evidence to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.Evidence\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Evidence.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Evidence;\n      }();\n\n      abci.Snapshot = function () {\n        /**\n         * Properties of a Snapshot.\n         * @memberof tendermint.abci\n         * @interface ISnapshot\n         * @property {number|Long|null} [height] Snapshot height\n         * @property {number|null} [format] Snapshot format\n         * @property {number|null} [chunks] Snapshot chunks\n         * @property {Uint8Array|null} [hash] Snapshot hash\n         * @property {Uint8Array|null} [metadata] Snapshot metadata\n         */\n\n        /**\n         * Constructs a new Snapshot.\n         * @memberof tendermint.abci\n         * @classdesc Represents a Snapshot.\n         * @implements ISnapshot\n         * @constructor\n         * @param {tendermint.abci.ISnapshot=} [properties] Properties to set\n         */\n        function Snapshot(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Snapshot height.\n         * @member {number|Long} height\n         * @memberof tendermint.abci.Snapshot\n         * @instance\n         */\n\n\n        Snapshot.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        /**\n         * Snapshot format.\n         * @member {number} format\n         * @memberof tendermint.abci.Snapshot\n         * @instance\n         */\n\n        Snapshot.prototype.format = 0;\n        /**\n         * Snapshot chunks.\n         * @member {number} chunks\n         * @memberof tendermint.abci.Snapshot\n         * @instance\n         */\n\n        Snapshot.prototype.chunks = 0;\n        /**\n         * Snapshot hash.\n         * @member {Uint8Array} hash\n         * @memberof tendermint.abci.Snapshot\n         * @instance\n         */\n\n        Snapshot.prototype.hash = $util.newBuffer([]);\n        /**\n         * Snapshot metadata.\n         * @member {Uint8Array} metadata\n         * @memberof tendermint.abci.Snapshot\n         * @instance\n         */\n\n        Snapshot.prototype.metadata = $util.newBuffer([]);\n        /**\n         * Creates a new Snapshot instance using the specified properties.\n         * @function create\n         * @memberof tendermint.abci.Snapshot\n         * @static\n         * @param {tendermint.abci.ISnapshot=} [properties] Properties to set\n         * @returns {tendermint.abci.Snapshot} Snapshot instance\n         */\n\n        Snapshot.create = function create(properties) {\n          return new Snapshot(properties);\n        };\n        /**\n         * Encodes the specified Snapshot message. Does not implicitly {@link tendermint.abci.Snapshot.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.abci.Snapshot\n         * @static\n         * @param {tendermint.abci.ISnapshot} message Snapshot message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Snapshot.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.height != null && Object.hasOwnProperty.call(message, \"height\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).uint64(message.height);\n          if (message.format != null && Object.hasOwnProperty.call(message, \"format\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).uint32(message.format);\n          if (message.chunks != null && Object.hasOwnProperty.call(message, \"chunks\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).uint32(message.chunks);\n          if (message.hash != null && Object.hasOwnProperty.call(message, \"hash\")) writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).bytes(message.hash);\n          if (message.metadata != null && Object.hasOwnProperty.call(message, \"metadata\")) writer.uint32(\n          /* id 5, wireType 2 =*/\n          42).bytes(message.metadata);\n          return writer;\n        };\n        /**\n         * Encodes the specified Snapshot message, length delimited. Does not implicitly {@link tendermint.abci.Snapshot.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.abci.Snapshot\n         * @static\n         * @param {tendermint.abci.ISnapshot} message Snapshot message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Snapshot.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Snapshot message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.abci.Snapshot\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.abci.Snapshot} Snapshot\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Snapshot.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.abci.Snapshot();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.height = reader.uint64();\n                break;\n\n              case 2:\n                message.format = reader.uint32();\n                break;\n\n              case 3:\n                message.chunks = reader.uint32();\n                break;\n\n              case 4:\n                message.hash = reader.bytes();\n                break;\n\n              case 5:\n                message.metadata = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Snapshot message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.abci.Snapshot\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.abci.Snapshot} Snapshot\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Snapshot.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Snapshot message.\n         * @function verify\n         * @memberof tendermint.abci.Snapshot\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Snapshot.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))) return \"height: integer|Long expected\";\n          if (message.format != null && message.hasOwnProperty(\"format\")) if (!$util.isInteger(message.format)) return \"format: integer expected\";\n          if (message.chunks != null && message.hasOwnProperty(\"chunks\")) if (!$util.isInteger(message.chunks)) return \"chunks: integer expected\";\n          if (message.hash != null && message.hasOwnProperty(\"hash\")) if (!(message.hash && typeof message.hash.length === \"number\" || $util.isString(message.hash))) return \"hash: buffer expected\";\n          if (message.metadata != null && message.hasOwnProperty(\"metadata\")) if (!(message.metadata && typeof message.metadata.length === \"number\" || $util.isString(message.metadata))) return \"metadata: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates a Snapshot message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.abci.Snapshot\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.abci.Snapshot} Snapshot\n         */\n\n\n        Snapshot.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.abci.Snapshot) return object;\n          var message = new $root.tendermint.abci.Snapshot();\n          if (object.height != null) if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = true;else if (typeof object.height === \"string\") message.height = parseInt(object.height, 10);else if (typeof object.height === \"number\") message.height = object.height;else if (typeof object.height === \"object\") message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);\n          if (object.format != null) message.format = object.format >>> 0;\n          if (object.chunks != null) message.chunks = object.chunks >>> 0;\n          if (object.hash != null) if (typeof object.hash === \"string\") $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);else if (object.hash.length) message.hash = object.hash;\n          if (object.metadata != null) if (typeof object.metadata === \"string\") $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);else if (object.metadata.length) message.metadata = object.metadata;\n          return message;\n        };\n        /**\n         * Creates a plain object from a Snapshot message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.abci.Snapshot\n         * @static\n         * @param {tendermint.abci.Snapshot} message Snapshot\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Snapshot.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.height = options.longs === String ? \"0\" : 0;\n\n            object.format = 0;\n            object.chunks = 0;\n            if (options.bytes === String) object.hash = \"\";else {\n              object.hash = [];\n              if (options.bytes !== Array) object.hash = $util.newBuffer(object.hash);\n            }\n            if (options.bytes === String) object.metadata = \"\";else {\n              object.metadata = [];\n              if (options.bytes !== Array) object.metadata = $util.newBuffer(object.metadata);\n            }\n          }\n\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (typeof message.height === \"number\") object.height = options.longs === String ? String(message.height) : message.height;else object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;\n          if (message.format != null && message.hasOwnProperty(\"format\")) object.format = message.format;\n          if (message.chunks != null && message.hasOwnProperty(\"chunks\")) object.chunks = message.chunks;\n          if (message.hash != null && message.hasOwnProperty(\"hash\")) object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;\n          if (message.metadata != null && message.hasOwnProperty(\"metadata\")) object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;\n          return object;\n        };\n        /**\n         * Converts this Snapshot to JSON.\n         * @function toJSON\n         * @memberof tendermint.abci.Snapshot\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Snapshot.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Snapshot;\n      }();\n\n      abci.ABCIApplication = function () {\n        /**\n         * Constructs a new ABCIApplication service.\n         * @memberof tendermint.abci\n         * @classdesc Represents a ABCIApplication\n         * @extends $protobuf.rpc.Service\n         * @constructor\n         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n         */\n        function ABCIApplication(rpcImpl, requestDelimited, responseDelimited) {\n          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);\n        }\n\n        (ABCIApplication.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ABCIApplication;\n        /**\n         * Creates new ABCIApplication service using the specified rpc implementation.\n         * @function create\n         * @memberof tendermint.abci.ABCIApplication\n         * @static\n         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n         * @returns {ABCIApplication} RPC service. Useful where requests and/or responses are streamed.\n         */\n\n        ABCIApplication.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n          return new this(rpcImpl, requestDelimited, responseDelimited);\n        };\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#echo}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef EchoCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseEcho} [response] ResponseEcho\n         */\n\n        /**\n         * Calls Echo.\n         * @function echo\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestEcho} request RequestEcho message or plain object\n         * @param {tendermint.abci.ABCIApplication.EchoCallback} callback Node-style callback called with the error, if any, and ResponseEcho\n         * @returns {undefined}\n         * @variation 1\n         */\n\n\n        Object.defineProperty(ABCIApplication.prototype.echo = function echo(request, callback) {\n          return this.rpcCall(echo, $root.tendermint.abci.RequestEcho, $root.tendermint.abci.ResponseEcho, request, callback);\n        }, \"name\", {\n          value: \"Echo\"\n        });\n        /**\n         * Calls Echo.\n         * @function echo\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestEcho} request RequestEcho message or plain object\n         * @returns {Promise<tendermint.abci.ResponseEcho>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#flush}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef FlushCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseFlush} [response] ResponseFlush\n         */\n\n        /**\n         * Calls Flush.\n         * @function flush\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestFlush} request RequestFlush message or plain object\n         * @param {tendermint.abci.ABCIApplication.FlushCallback} callback Node-style callback called with the error, if any, and ResponseFlush\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.flush = function flush(request, callback) {\n          return this.rpcCall(flush, $root.tendermint.abci.RequestFlush, $root.tendermint.abci.ResponseFlush, request, callback);\n        }, \"name\", {\n          value: \"Flush\"\n        });\n        /**\n         * Calls Flush.\n         * @function flush\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestFlush} request RequestFlush message or plain object\n         * @returns {Promise<tendermint.abci.ResponseFlush>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#info}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef InfoCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseInfo} [response] ResponseInfo\n         */\n\n        /**\n         * Calls Info.\n         * @function info\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestInfo} request RequestInfo message or plain object\n         * @param {tendermint.abci.ABCIApplication.InfoCallback} callback Node-style callback called with the error, if any, and ResponseInfo\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.info = function info(request, callback) {\n          return this.rpcCall(info, $root.tendermint.abci.RequestInfo, $root.tendermint.abci.ResponseInfo, request, callback);\n        }, \"name\", {\n          value: \"Info\"\n        });\n        /**\n         * Calls Info.\n         * @function info\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestInfo} request RequestInfo message or plain object\n         * @returns {Promise<tendermint.abci.ResponseInfo>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#setOption}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef SetOptionCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseSetOption} [response] ResponseSetOption\n         */\n\n        /**\n         * Calls SetOption.\n         * @function setOption\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestSetOption} request RequestSetOption message or plain object\n         * @param {tendermint.abci.ABCIApplication.SetOptionCallback} callback Node-style callback called with the error, if any, and ResponseSetOption\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.setOption = function setOption(request, callback) {\n          return this.rpcCall(setOption, $root.tendermint.abci.RequestSetOption, $root.tendermint.abci.ResponseSetOption, request, callback);\n        }, \"name\", {\n          value: \"SetOption\"\n        });\n        /**\n         * Calls SetOption.\n         * @function setOption\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestSetOption} request RequestSetOption message or plain object\n         * @returns {Promise<tendermint.abci.ResponseSetOption>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#deliverTx}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef DeliverTxCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseDeliverTx} [response] ResponseDeliverTx\n         */\n\n        /**\n         * Calls DeliverTx.\n         * @function deliverTx\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestDeliverTx} request RequestDeliverTx message or plain object\n         * @param {tendermint.abci.ABCIApplication.DeliverTxCallback} callback Node-style callback called with the error, if any, and ResponseDeliverTx\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.deliverTx = function deliverTx(request, callback) {\n          return this.rpcCall(deliverTx, $root.tendermint.abci.RequestDeliverTx, $root.tendermint.abci.ResponseDeliverTx, request, callback);\n        }, \"name\", {\n          value: \"DeliverTx\"\n        });\n        /**\n         * Calls DeliverTx.\n         * @function deliverTx\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestDeliverTx} request RequestDeliverTx message or plain object\n         * @returns {Promise<tendermint.abci.ResponseDeliverTx>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#checkTx}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef CheckTxCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseCheckTx} [response] ResponseCheckTx\n         */\n\n        /**\n         * Calls CheckTx.\n         * @function checkTx\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestCheckTx} request RequestCheckTx message or plain object\n         * @param {tendermint.abci.ABCIApplication.CheckTxCallback} callback Node-style callback called with the error, if any, and ResponseCheckTx\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.checkTx = function checkTx(request, callback) {\n          return this.rpcCall(checkTx, $root.tendermint.abci.RequestCheckTx, $root.tendermint.abci.ResponseCheckTx, request, callback);\n        }, \"name\", {\n          value: \"CheckTx\"\n        });\n        /**\n         * Calls CheckTx.\n         * @function checkTx\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestCheckTx} request RequestCheckTx message or plain object\n         * @returns {Promise<tendermint.abci.ResponseCheckTx>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#query}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef QueryCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseQuery} [response] ResponseQuery\n         */\n\n        /**\n         * Calls Query.\n         * @function query\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestQuery} request RequestQuery message or plain object\n         * @param {tendermint.abci.ABCIApplication.QueryCallback} callback Node-style callback called with the error, if any, and ResponseQuery\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.query = function query(request, callback) {\n          return this.rpcCall(query, $root.tendermint.abci.RequestQuery, $root.tendermint.abci.ResponseQuery, request, callback);\n        }, \"name\", {\n          value: \"Query\"\n        });\n        /**\n         * Calls Query.\n         * @function query\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestQuery} request RequestQuery message or plain object\n         * @returns {Promise<tendermint.abci.ResponseQuery>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#commit}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef CommitCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseCommit} [response] ResponseCommit\n         */\n\n        /**\n         * Calls Commit.\n         * @function commit\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestCommit} request RequestCommit message or plain object\n         * @param {tendermint.abci.ABCIApplication.CommitCallback} callback Node-style callback called with the error, if any, and ResponseCommit\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.commit = function commit(request, callback) {\n          return this.rpcCall(commit, $root.tendermint.abci.RequestCommit, $root.tendermint.abci.ResponseCommit, request, callback);\n        }, \"name\", {\n          value: \"Commit\"\n        });\n        /**\n         * Calls Commit.\n         * @function commit\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestCommit} request RequestCommit message or plain object\n         * @returns {Promise<tendermint.abci.ResponseCommit>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#initChain}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef InitChainCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseInitChain} [response] ResponseInitChain\n         */\n\n        /**\n         * Calls InitChain.\n         * @function initChain\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestInitChain} request RequestInitChain message or plain object\n         * @param {tendermint.abci.ABCIApplication.InitChainCallback} callback Node-style callback called with the error, if any, and ResponseInitChain\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.initChain = function initChain(request, callback) {\n          return this.rpcCall(initChain, $root.tendermint.abci.RequestInitChain, $root.tendermint.abci.ResponseInitChain, request, callback);\n        }, \"name\", {\n          value: \"InitChain\"\n        });\n        /**\n         * Calls InitChain.\n         * @function initChain\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestInitChain} request RequestInitChain message or plain object\n         * @returns {Promise<tendermint.abci.ResponseInitChain>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#beginBlock}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef BeginBlockCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseBeginBlock} [response] ResponseBeginBlock\n         */\n\n        /**\n         * Calls BeginBlock.\n         * @function beginBlock\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestBeginBlock} request RequestBeginBlock message or plain object\n         * @param {tendermint.abci.ABCIApplication.BeginBlockCallback} callback Node-style callback called with the error, if any, and ResponseBeginBlock\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.beginBlock = function beginBlock(request, callback) {\n          return this.rpcCall(beginBlock, $root.tendermint.abci.RequestBeginBlock, $root.tendermint.abci.ResponseBeginBlock, request, callback);\n        }, \"name\", {\n          value: \"BeginBlock\"\n        });\n        /**\n         * Calls BeginBlock.\n         * @function beginBlock\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestBeginBlock} request RequestBeginBlock message or plain object\n         * @returns {Promise<tendermint.abci.ResponseBeginBlock>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#endBlock}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef EndBlockCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseEndBlock} [response] ResponseEndBlock\n         */\n\n        /**\n         * Calls EndBlock.\n         * @function endBlock\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestEndBlock} request RequestEndBlock message or plain object\n         * @param {tendermint.abci.ABCIApplication.EndBlockCallback} callback Node-style callback called with the error, if any, and ResponseEndBlock\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.endBlock = function endBlock(request, callback) {\n          return this.rpcCall(endBlock, $root.tendermint.abci.RequestEndBlock, $root.tendermint.abci.ResponseEndBlock, request, callback);\n        }, \"name\", {\n          value: \"EndBlock\"\n        });\n        /**\n         * Calls EndBlock.\n         * @function endBlock\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestEndBlock} request RequestEndBlock message or plain object\n         * @returns {Promise<tendermint.abci.ResponseEndBlock>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#listSnapshots}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef ListSnapshotsCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseListSnapshots} [response] ResponseListSnapshots\n         */\n\n        /**\n         * Calls ListSnapshots.\n         * @function listSnapshots\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestListSnapshots} request RequestListSnapshots message or plain object\n         * @param {tendermint.abci.ABCIApplication.ListSnapshotsCallback} callback Node-style callback called with the error, if any, and ResponseListSnapshots\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.listSnapshots = function listSnapshots(request, callback) {\n          return this.rpcCall(listSnapshots, $root.tendermint.abci.RequestListSnapshots, $root.tendermint.abci.ResponseListSnapshots, request, callback);\n        }, \"name\", {\n          value: \"ListSnapshots\"\n        });\n        /**\n         * Calls ListSnapshots.\n         * @function listSnapshots\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestListSnapshots} request RequestListSnapshots message or plain object\n         * @returns {Promise<tendermint.abci.ResponseListSnapshots>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#offerSnapshot}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef OfferSnapshotCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseOfferSnapshot} [response] ResponseOfferSnapshot\n         */\n\n        /**\n         * Calls OfferSnapshot.\n         * @function offerSnapshot\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestOfferSnapshot} request RequestOfferSnapshot message or plain object\n         * @param {tendermint.abci.ABCIApplication.OfferSnapshotCallback} callback Node-style callback called with the error, if any, and ResponseOfferSnapshot\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.offerSnapshot = function offerSnapshot(request, callback) {\n          return this.rpcCall(offerSnapshot, $root.tendermint.abci.RequestOfferSnapshot, $root.tendermint.abci.ResponseOfferSnapshot, request, callback);\n        }, \"name\", {\n          value: \"OfferSnapshot\"\n        });\n        /**\n         * Calls OfferSnapshot.\n         * @function offerSnapshot\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestOfferSnapshot} request RequestOfferSnapshot message or plain object\n         * @returns {Promise<tendermint.abci.ResponseOfferSnapshot>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#loadSnapshotChunk}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef LoadSnapshotChunkCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseLoadSnapshotChunk} [response] ResponseLoadSnapshotChunk\n         */\n\n        /**\n         * Calls LoadSnapshotChunk.\n         * @function loadSnapshotChunk\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestLoadSnapshotChunk} request RequestLoadSnapshotChunk message or plain object\n         * @param {tendermint.abci.ABCIApplication.LoadSnapshotChunkCallback} callback Node-style callback called with the error, if any, and ResponseLoadSnapshotChunk\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.loadSnapshotChunk = function loadSnapshotChunk(request, callback) {\n          return this.rpcCall(loadSnapshotChunk, $root.tendermint.abci.RequestLoadSnapshotChunk, $root.tendermint.abci.ResponseLoadSnapshotChunk, request, callback);\n        }, \"name\", {\n          value: \"LoadSnapshotChunk\"\n        });\n        /**\n         * Calls LoadSnapshotChunk.\n         * @function loadSnapshotChunk\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestLoadSnapshotChunk} request RequestLoadSnapshotChunk message or plain object\n         * @returns {Promise<tendermint.abci.ResponseLoadSnapshotChunk>} Promise\n         * @variation 2\n         */\n\n        /**\n         * Callback as used by {@link tendermint.abci.ABCIApplication#applySnapshotChunk}.\n         * @memberof tendermint.abci.ABCIApplication\n         * @typedef ApplySnapshotChunkCallback\n         * @type {function}\n         * @param {Error|null} error Error, if any\n         * @param {tendermint.abci.ResponseApplySnapshotChunk} [response] ResponseApplySnapshotChunk\n         */\n\n        /**\n         * Calls ApplySnapshotChunk.\n         * @function applySnapshotChunk\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestApplySnapshotChunk} request RequestApplySnapshotChunk message or plain object\n         * @param {tendermint.abci.ABCIApplication.ApplySnapshotChunkCallback} callback Node-style callback called with the error, if any, and ResponseApplySnapshotChunk\n         * @returns {undefined}\n         * @variation 1\n         */\n\n        Object.defineProperty(ABCIApplication.prototype.applySnapshotChunk = function applySnapshotChunk(request, callback) {\n          return this.rpcCall(applySnapshotChunk, $root.tendermint.abci.RequestApplySnapshotChunk, $root.tendermint.abci.ResponseApplySnapshotChunk, request, callback);\n        }, \"name\", {\n          value: \"ApplySnapshotChunk\"\n        });\n        /**\n         * Calls ApplySnapshotChunk.\n         * @function applySnapshotChunk\n         * @memberof tendermint.abci.ABCIApplication\n         * @instance\n         * @param {tendermint.abci.IRequestApplySnapshotChunk} request RequestApplySnapshotChunk message or plain object\n         * @returns {Promise<tendermint.abci.ResponseApplySnapshotChunk>} Promise\n         * @variation 2\n         */\n\n        return ABCIApplication;\n      }();\n\n      return abci;\n    }();\n\n    tendermint.types = function () {\n      /**\n       * Namespace types.\n       * @memberof tendermint\n       * @namespace\n       */\n      var types = {};\n\n      types.Block = function () {\n        /**\n         * Properties of a Block.\n         * @memberof tendermint.types\n         * @interface IBlock\n         * @property {tendermint.types.IHeader|null} [header] Block header\n         * @property {tendermint.types.IData|null} [data] Block data\n         * @property {tendermint.types.IEvidenceList|null} [evidence] Block evidence\n         * @property {tendermint.types.ICommit|null} [lastCommit] Block lastCommit\n         */\n\n        /**\n         * Constructs a new Block.\n         * @memberof tendermint.types\n         * @classdesc Represents a Block.\n         * @implements IBlock\n         * @constructor\n         * @param {tendermint.types.IBlock=} [properties] Properties to set\n         */\n        function Block(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Block header.\n         * @member {tendermint.types.IHeader|null|undefined} header\n         * @memberof tendermint.types.Block\n         * @instance\n         */\n\n\n        Block.prototype.header = null;\n        /**\n         * Block data.\n         * @member {tendermint.types.IData|null|undefined} data\n         * @memberof tendermint.types.Block\n         * @instance\n         */\n\n        Block.prototype.data = null;\n        /**\n         * Block evidence.\n         * @member {tendermint.types.IEvidenceList|null|undefined} evidence\n         * @memberof tendermint.types.Block\n         * @instance\n         */\n\n        Block.prototype.evidence = null;\n        /**\n         * Block lastCommit.\n         * @member {tendermint.types.ICommit|null|undefined} lastCommit\n         * @memberof tendermint.types.Block\n         * @instance\n         */\n\n        Block.prototype.lastCommit = null;\n        /**\n         * Creates a new Block instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.Block\n         * @static\n         * @param {tendermint.types.IBlock=} [properties] Properties to set\n         * @returns {tendermint.types.Block} Block instance\n         */\n\n        Block.create = function create(properties) {\n          return new Block(properties);\n        };\n        /**\n         * Encodes the specified Block message. Does not implicitly {@link tendermint.types.Block.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.Block\n         * @static\n         * @param {tendermint.types.IBlock} message Block message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Block.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.header != null && Object.hasOwnProperty.call(message, \"header\")) $root.tendermint.types.Header.encode(message.header, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\")) $root.tendermint.types.Data.encode(message.data, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          if (message.evidence != null && Object.hasOwnProperty.call(message, \"evidence\")) $root.tendermint.types.EvidenceList.encode(message.evidence, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          if (message.lastCommit != null && Object.hasOwnProperty.call(message, \"lastCommit\")) $root.tendermint.types.Commit.encode(message.lastCommit, writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified Block message, length delimited. Does not implicitly {@link tendermint.types.Block.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.Block\n         * @static\n         * @param {tendermint.types.IBlock} message Block message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Block.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Block message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.Block\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.Block} Block\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Block.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.Block();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.header = $root.tendermint.types.Header.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.data = $root.tendermint.types.Data.decode(reader, reader.uint32());\n                break;\n\n              case 3:\n                message.evidence = $root.tendermint.types.EvidenceList.decode(reader, reader.uint32());\n                break;\n\n              case 4:\n                message.lastCommit = $root.tendermint.types.Commit.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Block message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.Block\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.Block} Block\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Block.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Block message.\n         * @function verify\n         * @memberof tendermint.types.Block\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Block.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.header != null && message.hasOwnProperty(\"header\")) {\n            var error = $root.tendermint.types.Header.verify(message.header);\n            if (error) return \"header.\" + error;\n          }\n\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            var error = $root.tendermint.types.Data.verify(message.data);\n            if (error) return \"data.\" + error;\n          }\n\n          if (message.evidence != null && message.hasOwnProperty(\"evidence\")) {\n            var error = $root.tendermint.types.EvidenceList.verify(message.evidence);\n            if (error) return \"evidence.\" + error;\n          }\n\n          if (message.lastCommit != null && message.hasOwnProperty(\"lastCommit\")) {\n            var error = $root.tendermint.types.Commit.verify(message.lastCommit);\n            if (error) return \"lastCommit.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a Block message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.Block\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.Block} Block\n         */\n\n\n        Block.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.Block) return object;\n          var message = new $root.tendermint.types.Block();\n\n          if (object.header != null) {\n            if (typeof object.header !== \"object\") throw TypeError(\".tendermint.types.Block.header: object expected\");\n            message.header = $root.tendermint.types.Header.fromObject(object.header);\n          }\n\n          if (object.data != null) {\n            if (typeof object.data !== \"object\") throw TypeError(\".tendermint.types.Block.data: object expected\");\n            message.data = $root.tendermint.types.Data.fromObject(object.data);\n          }\n\n          if (object.evidence != null) {\n            if (typeof object.evidence !== \"object\") throw TypeError(\".tendermint.types.Block.evidence: object expected\");\n            message.evidence = $root.tendermint.types.EvidenceList.fromObject(object.evidence);\n          }\n\n          if (object.lastCommit != null) {\n            if (typeof object.lastCommit !== \"object\") throw TypeError(\".tendermint.types.Block.lastCommit: object expected\");\n            message.lastCommit = $root.tendermint.types.Commit.fromObject(object.lastCommit);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a Block message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.Block\n         * @static\n         * @param {tendermint.types.Block} message Block\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Block.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.header = null;\n            object.data = null;\n            object.evidence = null;\n            object.lastCommit = null;\n          }\n\n          if (message.header != null && message.hasOwnProperty(\"header\")) object.header = $root.tendermint.types.Header.toObject(message.header, options);\n          if (message.data != null && message.hasOwnProperty(\"data\")) object.data = $root.tendermint.types.Data.toObject(message.data, options);\n          if (message.evidence != null && message.hasOwnProperty(\"evidence\")) object.evidence = $root.tendermint.types.EvidenceList.toObject(message.evidence, options);\n          if (message.lastCommit != null && message.hasOwnProperty(\"lastCommit\")) object.lastCommit = $root.tendermint.types.Commit.toObject(message.lastCommit, options);\n          return object;\n        };\n        /**\n         * Converts this Block to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.Block\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Block.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Block;\n      }();\n\n      types.Evidence = function () {\n        /**\n         * Properties of an Evidence.\n         * @memberof tendermint.types\n         * @interface IEvidence\n         * @property {tendermint.types.IDuplicateVoteEvidence|null} [duplicateVoteEvidence] Evidence duplicateVoteEvidence\n         * @property {tendermint.types.ILightClientAttackEvidence|null} [lightClientAttackEvidence] Evidence lightClientAttackEvidence\n         */\n\n        /**\n         * Constructs a new Evidence.\n         * @memberof tendermint.types\n         * @classdesc Represents an Evidence.\n         * @implements IEvidence\n         * @constructor\n         * @param {tendermint.types.IEvidence=} [properties] Properties to set\n         */\n        function Evidence(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Evidence duplicateVoteEvidence.\n         * @member {tendermint.types.IDuplicateVoteEvidence|null|undefined} duplicateVoteEvidence\n         * @memberof tendermint.types.Evidence\n         * @instance\n         */\n\n\n        Evidence.prototype.duplicateVoteEvidence = null;\n        /**\n         * Evidence lightClientAttackEvidence.\n         * @member {tendermint.types.ILightClientAttackEvidence|null|undefined} lightClientAttackEvidence\n         * @memberof tendermint.types.Evidence\n         * @instance\n         */\n\n        Evidence.prototype.lightClientAttackEvidence = null; // OneOf field names bound to virtual getters and setters\n\n        var $oneOfFields;\n        /**\n         * Evidence sum.\n         * @member {\"duplicateVoteEvidence\"|\"lightClientAttackEvidence\"|undefined} sum\n         * @memberof tendermint.types.Evidence\n         * @instance\n         */\n\n        Object.defineProperty(Evidence.prototype, \"sum\", {\n          get: $util.oneOfGetter($oneOfFields = [\"duplicateVoteEvidence\", \"lightClientAttackEvidence\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        /**\n         * Creates a new Evidence instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.Evidence\n         * @static\n         * @param {tendermint.types.IEvidence=} [properties] Properties to set\n         * @returns {tendermint.types.Evidence} Evidence instance\n         */\n\n        Evidence.create = function create(properties) {\n          return new Evidence(properties);\n        };\n        /**\n         * Encodes the specified Evidence message. Does not implicitly {@link tendermint.types.Evidence.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.Evidence\n         * @static\n         * @param {tendermint.types.IEvidence} message Evidence message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Evidence.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.duplicateVoteEvidence != null && Object.hasOwnProperty.call(message, \"duplicateVoteEvidence\")) $root.tendermint.types.DuplicateVoteEvidence.encode(message.duplicateVoteEvidence, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.lightClientAttackEvidence != null && Object.hasOwnProperty.call(message, \"lightClientAttackEvidence\")) $root.tendermint.types.LightClientAttackEvidence.encode(message.lightClientAttackEvidence, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified Evidence message, length delimited. Does not implicitly {@link tendermint.types.Evidence.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.Evidence\n         * @static\n         * @param {tendermint.types.IEvidence} message Evidence message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Evidence.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an Evidence message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.Evidence\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.Evidence} Evidence\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Evidence.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.Evidence();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.duplicateVoteEvidence = $root.tendermint.types.DuplicateVoteEvidence.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.lightClientAttackEvidence = $root.tendermint.types.LightClientAttackEvidence.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an Evidence message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.Evidence\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.Evidence} Evidence\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Evidence.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an Evidence message.\n         * @function verify\n         * @memberof tendermint.types.Evidence\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Evidence.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          var properties = {};\n\n          if (message.duplicateVoteEvidence != null && message.hasOwnProperty(\"duplicateVoteEvidence\")) {\n            properties.sum = 1;\n            {\n              var error = $root.tendermint.types.DuplicateVoteEvidence.verify(message.duplicateVoteEvidence);\n              if (error) return \"duplicateVoteEvidence.\" + error;\n            }\n          }\n\n          if (message.lightClientAttackEvidence != null && message.hasOwnProperty(\"lightClientAttackEvidence\")) {\n            if (properties.sum === 1) return \"sum: multiple values\";\n            properties.sum = 1;\n            {\n              var error = $root.tendermint.types.LightClientAttackEvidence.verify(message.lightClientAttackEvidence);\n              if (error) return \"lightClientAttackEvidence.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates an Evidence message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.Evidence\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.Evidence} Evidence\n         */\n\n\n        Evidence.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.Evidence) return object;\n          var message = new $root.tendermint.types.Evidence();\n\n          if (object.duplicateVoteEvidence != null) {\n            if (typeof object.duplicateVoteEvidence !== \"object\") throw TypeError(\".tendermint.types.Evidence.duplicateVoteEvidence: object expected\");\n            message.duplicateVoteEvidence = $root.tendermint.types.DuplicateVoteEvidence.fromObject(object.duplicateVoteEvidence);\n          }\n\n          if (object.lightClientAttackEvidence != null) {\n            if (typeof object.lightClientAttackEvidence !== \"object\") throw TypeError(\".tendermint.types.Evidence.lightClientAttackEvidence: object expected\");\n            message.lightClientAttackEvidence = $root.tendermint.types.LightClientAttackEvidence.fromObject(object.lightClientAttackEvidence);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from an Evidence message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.Evidence\n         * @static\n         * @param {tendermint.types.Evidence} message Evidence\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Evidence.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (message.duplicateVoteEvidence != null && message.hasOwnProperty(\"duplicateVoteEvidence\")) {\n            object.duplicateVoteEvidence = $root.tendermint.types.DuplicateVoteEvidence.toObject(message.duplicateVoteEvidence, options);\n            if (options.oneofs) object.sum = \"duplicateVoteEvidence\";\n          }\n\n          if (message.lightClientAttackEvidence != null && message.hasOwnProperty(\"lightClientAttackEvidence\")) {\n            object.lightClientAttackEvidence = $root.tendermint.types.LightClientAttackEvidence.toObject(message.lightClientAttackEvidence, options);\n            if (options.oneofs) object.sum = \"lightClientAttackEvidence\";\n          }\n\n          return object;\n        };\n        /**\n         * Converts this Evidence to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.Evidence\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Evidence.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Evidence;\n      }();\n\n      types.DuplicateVoteEvidence = function () {\n        /**\n         * Properties of a DuplicateVoteEvidence.\n         * @memberof tendermint.types\n         * @interface IDuplicateVoteEvidence\n         * @property {tendermint.types.IVote|null} [voteA] DuplicateVoteEvidence voteA\n         * @property {tendermint.types.IVote|null} [voteB] DuplicateVoteEvidence voteB\n         * @property {number|Long|null} [totalVotingPower] DuplicateVoteEvidence totalVotingPower\n         * @property {number|Long|null} [validatorPower] DuplicateVoteEvidence validatorPower\n         * @property {google.protobuf.ITimestamp|null} [timestamp] DuplicateVoteEvidence timestamp\n         */\n\n        /**\n         * Constructs a new DuplicateVoteEvidence.\n         * @memberof tendermint.types\n         * @classdesc Represents a DuplicateVoteEvidence.\n         * @implements IDuplicateVoteEvidence\n         * @constructor\n         * @param {tendermint.types.IDuplicateVoteEvidence=} [properties] Properties to set\n         */\n        function DuplicateVoteEvidence(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * DuplicateVoteEvidence voteA.\n         * @member {tendermint.types.IVote|null|undefined} voteA\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @instance\n         */\n\n\n        DuplicateVoteEvidence.prototype.voteA = null;\n        /**\n         * DuplicateVoteEvidence voteB.\n         * @member {tendermint.types.IVote|null|undefined} voteB\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @instance\n         */\n\n        DuplicateVoteEvidence.prototype.voteB = null;\n        /**\n         * DuplicateVoteEvidence totalVotingPower.\n         * @member {number|Long} totalVotingPower\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @instance\n         */\n\n        DuplicateVoteEvidence.prototype.totalVotingPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * DuplicateVoteEvidence validatorPower.\n         * @member {number|Long} validatorPower\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @instance\n         */\n\n        DuplicateVoteEvidence.prototype.validatorPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * DuplicateVoteEvidence timestamp.\n         * @member {google.protobuf.ITimestamp|null|undefined} timestamp\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @instance\n         */\n\n        DuplicateVoteEvidence.prototype.timestamp = null;\n        /**\n         * Creates a new DuplicateVoteEvidence instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @static\n         * @param {tendermint.types.IDuplicateVoteEvidence=} [properties] Properties to set\n         * @returns {tendermint.types.DuplicateVoteEvidence} DuplicateVoteEvidence instance\n         */\n\n        DuplicateVoteEvidence.create = function create(properties) {\n          return new DuplicateVoteEvidence(properties);\n        };\n        /**\n         * Encodes the specified DuplicateVoteEvidence message. Does not implicitly {@link tendermint.types.DuplicateVoteEvidence.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @static\n         * @param {tendermint.types.IDuplicateVoteEvidence} message DuplicateVoteEvidence message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        DuplicateVoteEvidence.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.voteA != null && Object.hasOwnProperty.call(message, \"voteA\")) $root.tendermint.types.Vote.encode(message.voteA, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.voteB != null && Object.hasOwnProperty.call(message, \"voteB\")) $root.tendermint.types.Vote.encode(message.voteB, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          if (message.totalVotingPower != null && Object.hasOwnProperty.call(message, \"totalVotingPower\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int64(message.totalVotingPower);\n          if (message.validatorPower != null && Object.hasOwnProperty.call(message, \"validatorPower\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).int64(message.validatorPower);\n          if (message.timestamp != null && Object.hasOwnProperty.call(message, \"timestamp\")) $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(\n          /* id 5, wireType 2 =*/\n          42).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified DuplicateVoteEvidence message, length delimited. Does not implicitly {@link tendermint.types.DuplicateVoteEvidence.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @static\n         * @param {tendermint.types.IDuplicateVoteEvidence} message DuplicateVoteEvidence message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        DuplicateVoteEvidence.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a DuplicateVoteEvidence message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.DuplicateVoteEvidence} DuplicateVoteEvidence\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        DuplicateVoteEvidence.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.DuplicateVoteEvidence();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.voteA = $root.tendermint.types.Vote.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.voteB = $root.tendermint.types.Vote.decode(reader, reader.uint32());\n                break;\n\n              case 3:\n                message.totalVotingPower = reader.int64();\n                break;\n\n              case 4:\n                message.validatorPower = reader.int64();\n                break;\n\n              case 5:\n                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a DuplicateVoteEvidence message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.DuplicateVoteEvidence} DuplicateVoteEvidence\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        DuplicateVoteEvidence.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a DuplicateVoteEvidence message.\n         * @function verify\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        DuplicateVoteEvidence.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.voteA != null && message.hasOwnProperty(\"voteA\")) {\n            var error = $root.tendermint.types.Vote.verify(message.voteA);\n            if (error) return \"voteA.\" + error;\n          }\n\n          if (message.voteB != null && message.hasOwnProperty(\"voteB\")) {\n            var error = $root.tendermint.types.Vote.verify(message.voteB);\n            if (error) return \"voteB.\" + error;\n          }\n\n          if (message.totalVotingPower != null && message.hasOwnProperty(\"totalVotingPower\")) if (!$util.isInteger(message.totalVotingPower) && !(message.totalVotingPower && $util.isInteger(message.totalVotingPower.low) && $util.isInteger(message.totalVotingPower.high))) return \"totalVotingPower: integer|Long expected\";\n          if (message.validatorPower != null && message.hasOwnProperty(\"validatorPower\")) if (!$util.isInteger(message.validatorPower) && !(message.validatorPower && $util.isInteger(message.validatorPower.low) && $util.isInteger(message.validatorPower.high))) return \"validatorPower: integer|Long expected\";\n\n          if (message.timestamp != null && message.hasOwnProperty(\"timestamp\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);\n            if (error) return \"timestamp.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a DuplicateVoteEvidence message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.DuplicateVoteEvidence} DuplicateVoteEvidence\n         */\n\n\n        DuplicateVoteEvidence.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.DuplicateVoteEvidence) return object;\n          var message = new $root.tendermint.types.DuplicateVoteEvidence();\n\n          if (object.voteA != null) {\n            if (typeof object.voteA !== \"object\") throw TypeError(\".tendermint.types.DuplicateVoteEvidence.voteA: object expected\");\n            message.voteA = $root.tendermint.types.Vote.fromObject(object.voteA);\n          }\n\n          if (object.voteB != null) {\n            if (typeof object.voteB !== \"object\") throw TypeError(\".tendermint.types.DuplicateVoteEvidence.voteB: object expected\");\n            message.voteB = $root.tendermint.types.Vote.fromObject(object.voteB);\n          }\n\n          if (object.totalVotingPower != null) if ($util.Long) (message.totalVotingPower = $util.Long.fromValue(object.totalVotingPower)).unsigned = false;else if (typeof object.totalVotingPower === \"string\") message.totalVotingPower = parseInt(object.totalVotingPower, 10);else if (typeof object.totalVotingPower === \"number\") message.totalVotingPower = object.totalVotingPower;else if (typeof object.totalVotingPower === \"object\") message.totalVotingPower = new $util.LongBits(object.totalVotingPower.low >>> 0, object.totalVotingPower.high >>> 0).toNumber();\n          if (object.validatorPower != null) if ($util.Long) (message.validatorPower = $util.Long.fromValue(object.validatorPower)).unsigned = false;else if (typeof object.validatorPower === \"string\") message.validatorPower = parseInt(object.validatorPower, 10);else if (typeof object.validatorPower === \"number\") message.validatorPower = object.validatorPower;else if (typeof object.validatorPower === \"object\") message.validatorPower = new $util.LongBits(object.validatorPower.low >>> 0, object.validatorPower.high >>> 0).toNumber();\n\n          if (object.timestamp != null) {\n            if (typeof object.timestamp !== \"object\") throw TypeError(\".tendermint.types.DuplicateVoteEvidence.timestamp: object expected\");\n            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a DuplicateVoteEvidence message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @static\n         * @param {tendermint.types.DuplicateVoteEvidence} message DuplicateVoteEvidence\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        DuplicateVoteEvidence.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.voteA = null;\n            object.voteB = null;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.totalVotingPower = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.totalVotingPower = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.validatorPower = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.validatorPower = options.longs === String ? \"0\" : 0;\n\n            object.timestamp = null;\n          }\n\n          if (message.voteA != null && message.hasOwnProperty(\"voteA\")) object.voteA = $root.tendermint.types.Vote.toObject(message.voteA, options);\n          if (message.voteB != null && message.hasOwnProperty(\"voteB\")) object.voteB = $root.tendermint.types.Vote.toObject(message.voteB, options);\n          if (message.totalVotingPower != null && message.hasOwnProperty(\"totalVotingPower\")) if (typeof message.totalVotingPower === \"number\") object.totalVotingPower = options.longs === String ? String(message.totalVotingPower) : message.totalVotingPower;else object.totalVotingPower = options.longs === String ? $util.Long.prototype.toString.call(message.totalVotingPower) : options.longs === Number ? new $util.LongBits(message.totalVotingPower.low >>> 0, message.totalVotingPower.high >>> 0).toNumber() : message.totalVotingPower;\n          if (message.validatorPower != null && message.hasOwnProperty(\"validatorPower\")) if (typeof message.validatorPower === \"number\") object.validatorPower = options.longs === String ? String(message.validatorPower) : message.validatorPower;else object.validatorPower = options.longs === String ? $util.Long.prototype.toString.call(message.validatorPower) : options.longs === Number ? new $util.LongBits(message.validatorPower.low >>> 0, message.validatorPower.high >>> 0).toNumber() : message.validatorPower;\n          if (message.timestamp != null && message.hasOwnProperty(\"timestamp\")) object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);\n          return object;\n        };\n        /**\n         * Converts this DuplicateVoteEvidence to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.DuplicateVoteEvidence\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        DuplicateVoteEvidence.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return DuplicateVoteEvidence;\n      }();\n\n      types.LightClientAttackEvidence = function () {\n        /**\n         * Properties of a LightClientAttackEvidence.\n         * @memberof tendermint.types\n         * @interface ILightClientAttackEvidence\n         * @property {tendermint.types.ILightBlock|null} [conflictingBlock] LightClientAttackEvidence conflictingBlock\n         * @property {number|Long|null} [commonHeight] LightClientAttackEvidence commonHeight\n         * @property {Array.<tendermint.types.IValidator>|null} [byzantineValidators] LightClientAttackEvidence byzantineValidators\n         * @property {number|Long|null} [totalVotingPower] LightClientAttackEvidence totalVotingPower\n         * @property {google.protobuf.ITimestamp|null} [timestamp] LightClientAttackEvidence timestamp\n         */\n\n        /**\n         * Constructs a new LightClientAttackEvidence.\n         * @memberof tendermint.types\n         * @classdesc Represents a LightClientAttackEvidence.\n         * @implements ILightClientAttackEvidence\n         * @constructor\n         * @param {tendermint.types.ILightClientAttackEvidence=} [properties] Properties to set\n         */\n        function LightClientAttackEvidence(properties) {\n          this.byzantineValidators = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * LightClientAttackEvidence conflictingBlock.\n         * @member {tendermint.types.ILightBlock|null|undefined} conflictingBlock\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @instance\n         */\n\n\n        LightClientAttackEvidence.prototype.conflictingBlock = null;\n        /**\n         * LightClientAttackEvidence commonHeight.\n         * @member {number|Long} commonHeight\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @instance\n         */\n\n        LightClientAttackEvidence.prototype.commonHeight = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * LightClientAttackEvidence byzantineValidators.\n         * @member {Array.<tendermint.types.IValidator>} byzantineValidators\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @instance\n         */\n\n        LightClientAttackEvidence.prototype.byzantineValidators = $util.emptyArray;\n        /**\n         * LightClientAttackEvidence totalVotingPower.\n         * @member {number|Long} totalVotingPower\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @instance\n         */\n\n        LightClientAttackEvidence.prototype.totalVotingPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * LightClientAttackEvidence timestamp.\n         * @member {google.protobuf.ITimestamp|null|undefined} timestamp\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @instance\n         */\n\n        LightClientAttackEvidence.prototype.timestamp = null;\n        /**\n         * Creates a new LightClientAttackEvidence instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @static\n         * @param {tendermint.types.ILightClientAttackEvidence=} [properties] Properties to set\n         * @returns {tendermint.types.LightClientAttackEvidence} LightClientAttackEvidence instance\n         */\n\n        LightClientAttackEvidence.create = function create(properties) {\n          return new LightClientAttackEvidence(properties);\n        };\n        /**\n         * Encodes the specified LightClientAttackEvidence message. Does not implicitly {@link tendermint.types.LightClientAttackEvidence.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @static\n         * @param {tendermint.types.ILightClientAttackEvidence} message LightClientAttackEvidence message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        LightClientAttackEvidence.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.conflictingBlock != null && Object.hasOwnProperty.call(message, \"conflictingBlock\")) $root.tendermint.types.LightBlock.encode(message.conflictingBlock, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.commonHeight != null && Object.hasOwnProperty.call(message, \"commonHeight\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int64(message.commonHeight);\n          if (message.byzantineValidators != null && message.byzantineValidators.length) for (var i = 0; i < message.byzantineValidators.length; ++i) {\n            $root.tendermint.types.Validator.encode(message.byzantineValidators[i], writer.uint32(\n            /* id 3, wireType 2 =*/\n            26).fork()).ldelim();\n          }\n          if (message.totalVotingPower != null && Object.hasOwnProperty.call(message, \"totalVotingPower\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).int64(message.totalVotingPower);\n          if (message.timestamp != null && Object.hasOwnProperty.call(message, \"timestamp\")) $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(\n          /* id 5, wireType 2 =*/\n          42).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified LightClientAttackEvidence message, length delimited. Does not implicitly {@link tendermint.types.LightClientAttackEvidence.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @static\n         * @param {tendermint.types.ILightClientAttackEvidence} message LightClientAttackEvidence message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        LightClientAttackEvidence.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a LightClientAttackEvidence message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.LightClientAttackEvidence} LightClientAttackEvidence\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        LightClientAttackEvidence.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.LightClientAttackEvidence();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.conflictingBlock = $root.tendermint.types.LightBlock.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.commonHeight = reader.int64();\n                break;\n\n              case 3:\n                if (!(message.byzantineValidators && message.byzantineValidators.length)) message.byzantineValidators = [];\n                message.byzantineValidators.push($root.tendermint.types.Validator.decode(reader, reader.uint32()));\n                break;\n\n              case 4:\n                message.totalVotingPower = reader.int64();\n                break;\n\n              case 5:\n                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a LightClientAttackEvidence message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.LightClientAttackEvidence} LightClientAttackEvidence\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        LightClientAttackEvidence.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a LightClientAttackEvidence message.\n         * @function verify\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        LightClientAttackEvidence.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.conflictingBlock != null && message.hasOwnProperty(\"conflictingBlock\")) {\n            var error = $root.tendermint.types.LightBlock.verify(message.conflictingBlock);\n            if (error) return \"conflictingBlock.\" + error;\n          }\n\n          if (message.commonHeight != null && message.hasOwnProperty(\"commonHeight\")) if (!$util.isInteger(message.commonHeight) && !(message.commonHeight && $util.isInteger(message.commonHeight.low) && $util.isInteger(message.commonHeight.high))) return \"commonHeight: integer|Long expected\";\n\n          if (message.byzantineValidators != null && message.hasOwnProperty(\"byzantineValidators\")) {\n            if (!Array.isArray(message.byzantineValidators)) return \"byzantineValidators: array expected\";\n\n            for (var i = 0; i < message.byzantineValidators.length; ++i) {\n              var error = $root.tendermint.types.Validator.verify(message.byzantineValidators[i]);\n              if (error) return \"byzantineValidators.\" + error;\n            }\n          }\n\n          if (message.totalVotingPower != null && message.hasOwnProperty(\"totalVotingPower\")) if (!$util.isInteger(message.totalVotingPower) && !(message.totalVotingPower && $util.isInteger(message.totalVotingPower.low) && $util.isInteger(message.totalVotingPower.high))) return \"totalVotingPower: integer|Long expected\";\n\n          if (message.timestamp != null && message.hasOwnProperty(\"timestamp\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);\n            if (error) return \"timestamp.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a LightClientAttackEvidence message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.LightClientAttackEvidence} LightClientAttackEvidence\n         */\n\n\n        LightClientAttackEvidence.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.LightClientAttackEvidence) return object;\n          var message = new $root.tendermint.types.LightClientAttackEvidence();\n\n          if (object.conflictingBlock != null) {\n            if (typeof object.conflictingBlock !== \"object\") throw TypeError(\".tendermint.types.LightClientAttackEvidence.conflictingBlock: object expected\");\n            message.conflictingBlock = $root.tendermint.types.LightBlock.fromObject(object.conflictingBlock);\n          }\n\n          if (object.commonHeight != null) if ($util.Long) (message.commonHeight = $util.Long.fromValue(object.commonHeight)).unsigned = false;else if (typeof object.commonHeight === \"string\") message.commonHeight = parseInt(object.commonHeight, 10);else if (typeof object.commonHeight === \"number\") message.commonHeight = object.commonHeight;else if (typeof object.commonHeight === \"object\") message.commonHeight = new $util.LongBits(object.commonHeight.low >>> 0, object.commonHeight.high >>> 0).toNumber();\n\n          if (object.byzantineValidators) {\n            if (!Array.isArray(object.byzantineValidators)) throw TypeError(\".tendermint.types.LightClientAttackEvidence.byzantineValidators: array expected\");\n            message.byzantineValidators = [];\n\n            for (var i = 0; i < object.byzantineValidators.length; ++i) {\n              if (typeof object.byzantineValidators[i] !== \"object\") throw TypeError(\".tendermint.types.LightClientAttackEvidence.byzantineValidators: object expected\");\n              message.byzantineValidators[i] = $root.tendermint.types.Validator.fromObject(object.byzantineValidators[i]);\n            }\n          }\n\n          if (object.totalVotingPower != null) if ($util.Long) (message.totalVotingPower = $util.Long.fromValue(object.totalVotingPower)).unsigned = false;else if (typeof object.totalVotingPower === \"string\") message.totalVotingPower = parseInt(object.totalVotingPower, 10);else if (typeof object.totalVotingPower === \"number\") message.totalVotingPower = object.totalVotingPower;else if (typeof object.totalVotingPower === \"object\") message.totalVotingPower = new $util.LongBits(object.totalVotingPower.low >>> 0, object.totalVotingPower.high >>> 0).toNumber();\n\n          if (object.timestamp != null) {\n            if (typeof object.timestamp !== \"object\") throw TypeError(\".tendermint.types.LightClientAttackEvidence.timestamp: object expected\");\n            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a LightClientAttackEvidence message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @static\n         * @param {tendermint.types.LightClientAttackEvidence} message LightClientAttackEvidence\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        LightClientAttackEvidence.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.byzantineValidators = [];\n\n          if (options.defaults) {\n            object.conflictingBlock = null;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.commonHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.commonHeight = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.totalVotingPower = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.totalVotingPower = options.longs === String ? \"0\" : 0;\n\n            object.timestamp = null;\n          }\n\n          if (message.conflictingBlock != null && message.hasOwnProperty(\"conflictingBlock\")) object.conflictingBlock = $root.tendermint.types.LightBlock.toObject(message.conflictingBlock, options);\n          if (message.commonHeight != null && message.hasOwnProperty(\"commonHeight\")) if (typeof message.commonHeight === \"number\") object.commonHeight = options.longs === String ? String(message.commonHeight) : message.commonHeight;else object.commonHeight = options.longs === String ? $util.Long.prototype.toString.call(message.commonHeight) : options.longs === Number ? new $util.LongBits(message.commonHeight.low >>> 0, message.commonHeight.high >>> 0).toNumber() : message.commonHeight;\n\n          if (message.byzantineValidators && message.byzantineValidators.length) {\n            object.byzantineValidators = [];\n\n            for (var j = 0; j < message.byzantineValidators.length; ++j) {\n              object.byzantineValidators[j] = $root.tendermint.types.Validator.toObject(message.byzantineValidators[j], options);\n            }\n          }\n\n          if (message.totalVotingPower != null && message.hasOwnProperty(\"totalVotingPower\")) if (typeof message.totalVotingPower === \"number\") object.totalVotingPower = options.longs === String ? String(message.totalVotingPower) : message.totalVotingPower;else object.totalVotingPower = options.longs === String ? $util.Long.prototype.toString.call(message.totalVotingPower) : options.longs === Number ? new $util.LongBits(message.totalVotingPower.low >>> 0, message.totalVotingPower.high >>> 0).toNumber() : message.totalVotingPower;\n          if (message.timestamp != null && message.hasOwnProperty(\"timestamp\")) object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);\n          return object;\n        };\n        /**\n         * Converts this LightClientAttackEvidence to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.LightClientAttackEvidence\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        LightClientAttackEvidence.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LightClientAttackEvidence;\n      }();\n\n      types.EvidenceList = function () {\n        /**\n         * Properties of an EvidenceList.\n         * @memberof tendermint.types\n         * @interface IEvidenceList\n         * @property {Array.<tendermint.types.IEvidence>|null} [evidence] EvidenceList evidence\n         */\n\n        /**\n         * Constructs a new EvidenceList.\n         * @memberof tendermint.types\n         * @classdesc Represents an EvidenceList.\n         * @implements IEvidenceList\n         * @constructor\n         * @param {tendermint.types.IEvidenceList=} [properties] Properties to set\n         */\n        function EvidenceList(properties) {\n          this.evidence = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * EvidenceList evidence.\n         * @member {Array.<tendermint.types.IEvidence>} evidence\n         * @memberof tendermint.types.EvidenceList\n         * @instance\n         */\n\n\n        EvidenceList.prototype.evidence = $util.emptyArray;\n        /**\n         * Creates a new EvidenceList instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.EvidenceList\n         * @static\n         * @param {tendermint.types.IEvidenceList=} [properties] Properties to set\n         * @returns {tendermint.types.EvidenceList} EvidenceList instance\n         */\n\n        EvidenceList.create = function create(properties) {\n          return new EvidenceList(properties);\n        };\n        /**\n         * Encodes the specified EvidenceList message. Does not implicitly {@link tendermint.types.EvidenceList.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.EvidenceList\n         * @static\n         * @param {tendermint.types.IEvidenceList} message EvidenceList message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EvidenceList.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.evidence != null && message.evidence.length) for (var i = 0; i < message.evidence.length; ++i) {\n            $root.tendermint.types.Evidence.encode(message.evidence[i], writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified EvidenceList message, length delimited. Does not implicitly {@link tendermint.types.EvidenceList.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.EvidenceList\n         * @static\n         * @param {tendermint.types.IEvidenceList} message EvidenceList message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EvidenceList.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an EvidenceList message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.EvidenceList\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.EvidenceList} EvidenceList\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EvidenceList.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.EvidenceList();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.evidence && message.evidence.length)) message.evidence = [];\n                message.evidence.push($root.tendermint.types.Evidence.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an EvidenceList message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.EvidenceList\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.EvidenceList} EvidenceList\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EvidenceList.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an EvidenceList message.\n         * @function verify\n         * @memberof tendermint.types.EvidenceList\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        EvidenceList.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.evidence != null && message.hasOwnProperty(\"evidence\")) {\n            if (!Array.isArray(message.evidence)) return \"evidence: array expected\";\n\n            for (var i = 0; i < message.evidence.length; ++i) {\n              var error = $root.tendermint.types.Evidence.verify(message.evidence[i]);\n              if (error) return \"evidence.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates an EvidenceList message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.EvidenceList\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.EvidenceList} EvidenceList\n         */\n\n\n        EvidenceList.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.EvidenceList) return object;\n          var message = new $root.tendermint.types.EvidenceList();\n\n          if (object.evidence) {\n            if (!Array.isArray(object.evidence)) throw TypeError(\".tendermint.types.EvidenceList.evidence: array expected\");\n            message.evidence = [];\n\n            for (var i = 0; i < object.evidence.length; ++i) {\n              if (typeof object.evidence[i] !== \"object\") throw TypeError(\".tendermint.types.EvidenceList.evidence: object expected\");\n              message.evidence[i] = $root.tendermint.types.Evidence.fromObject(object.evidence[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from an EvidenceList message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.EvidenceList\n         * @static\n         * @param {tendermint.types.EvidenceList} message EvidenceList\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        EvidenceList.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.evidence = [];\n\n          if (message.evidence && message.evidence.length) {\n            object.evidence = [];\n\n            for (var j = 0; j < message.evidence.length; ++j) {\n              object.evidence[j] = $root.tendermint.types.Evidence.toObject(message.evidence[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this EvidenceList to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.EvidenceList\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        EvidenceList.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return EvidenceList;\n      }();\n\n      types.ConsensusParams = function () {\n        /**\n         * Properties of a ConsensusParams.\n         * @memberof tendermint.types\n         * @interface IConsensusParams\n         * @property {tendermint.types.IBlockParams|null} [block] ConsensusParams block\n         * @property {tendermint.types.IEvidenceParams|null} [evidence] ConsensusParams evidence\n         * @property {tendermint.types.IValidatorParams|null} [validator] ConsensusParams validator\n         * @property {tendermint.types.IVersionParams|null} [version] ConsensusParams version\n         */\n\n        /**\n         * Constructs a new ConsensusParams.\n         * @memberof tendermint.types\n         * @classdesc Represents a ConsensusParams.\n         * @implements IConsensusParams\n         * @constructor\n         * @param {tendermint.types.IConsensusParams=} [properties] Properties to set\n         */\n        function ConsensusParams(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ConsensusParams block.\n         * @member {tendermint.types.IBlockParams|null|undefined} block\n         * @memberof tendermint.types.ConsensusParams\n         * @instance\n         */\n\n\n        ConsensusParams.prototype.block = null;\n        /**\n         * ConsensusParams evidence.\n         * @member {tendermint.types.IEvidenceParams|null|undefined} evidence\n         * @memberof tendermint.types.ConsensusParams\n         * @instance\n         */\n\n        ConsensusParams.prototype.evidence = null;\n        /**\n         * ConsensusParams validator.\n         * @member {tendermint.types.IValidatorParams|null|undefined} validator\n         * @memberof tendermint.types.ConsensusParams\n         * @instance\n         */\n\n        ConsensusParams.prototype.validator = null;\n        /**\n         * ConsensusParams version.\n         * @member {tendermint.types.IVersionParams|null|undefined} version\n         * @memberof tendermint.types.ConsensusParams\n         * @instance\n         */\n\n        ConsensusParams.prototype.version = null;\n        /**\n         * Creates a new ConsensusParams instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.ConsensusParams\n         * @static\n         * @param {tendermint.types.IConsensusParams=} [properties] Properties to set\n         * @returns {tendermint.types.ConsensusParams} ConsensusParams instance\n         */\n\n        ConsensusParams.create = function create(properties) {\n          return new ConsensusParams(properties);\n        };\n        /**\n         * Encodes the specified ConsensusParams message. Does not implicitly {@link tendermint.types.ConsensusParams.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.ConsensusParams\n         * @static\n         * @param {tendermint.types.IConsensusParams} message ConsensusParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ConsensusParams.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.block != null && Object.hasOwnProperty.call(message, \"block\")) $root.tendermint.types.BlockParams.encode(message.block, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.evidence != null && Object.hasOwnProperty.call(message, \"evidence\")) $root.tendermint.types.EvidenceParams.encode(message.evidence, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          if (message.validator != null && Object.hasOwnProperty.call(message, \"validator\")) $root.tendermint.types.ValidatorParams.encode(message.validator, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          if (message.version != null && Object.hasOwnProperty.call(message, \"version\")) $root.tendermint.types.VersionParams.encode(message.version, writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified ConsensusParams message, length delimited. Does not implicitly {@link tendermint.types.ConsensusParams.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.ConsensusParams\n         * @static\n         * @param {tendermint.types.IConsensusParams} message ConsensusParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ConsensusParams.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ConsensusParams message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.ConsensusParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.ConsensusParams} ConsensusParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ConsensusParams.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.ConsensusParams();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.block = $root.tendermint.types.BlockParams.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.evidence = $root.tendermint.types.EvidenceParams.decode(reader, reader.uint32());\n                break;\n\n              case 3:\n                message.validator = $root.tendermint.types.ValidatorParams.decode(reader, reader.uint32());\n                break;\n\n              case 4:\n                message.version = $root.tendermint.types.VersionParams.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ConsensusParams message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.ConsensusParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.ConsensusParams} ConsensusParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ConsensusParams.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ConsensusParams message.\n         * @function verify\n         * @memberof tendermint.types.ConsensusParams\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ConsensusParams.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.block != null && message.hasOwnProperty(\"block\")) {\n            var error = $root.tendermint.types.BlockParams.verify(message.block);\n            if (error) return \"block.\" + error;\n          }\n\n          if (message.evidence != null && message.hasOwnProperty(\"evidence\")) {\n            var error = $root.tendermint.types.EvidenceParams.verify(message.evidence);\n            if (error) return \"evidence.\" + error;\n          }\n\n          if (message.validator != null && message.hasOwnProperty(\"validator\")) {\n            var error = $root.tendermint.types.ValidatorParams.verify(message.validator);\n            if (error) return \"validator.\" + error;\n          }\n\n          if (message.version != null && message.hasOwnProperty(\"version\")) {\n            var error = $root.tendermint.types.VersionParams.verify(message.version);\n            if (error) return \"version.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a ConsensusParams message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.ConsensusParams\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.ConsensusParams} ConsensusParams\n         */\n\n\n        ConsensusParams.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.ConsensusParams) return object;\n          var message = new $root.tendermint.types.ConsensusParams();\n\n          if (object.block != null) {\n            if (typeof object.block !== \"object\") throw TypeError(\".tendermint.types.ConsensusParams.block: object expected\");\n            message.block = $root.tendermint.types.BlockParams.fromObject(object.block);\n          }\n\n          if (object.evidence != null) {\n            if (typeof object.evidence !== \"object\") throw TypeError(\".tendermint.types.ConsensusParams.evidence: object expected\");\n            message.evidence = $root.tendermint.types.EvidenceParams.fromObject(object.evidence);\n          }\n\n          if (object.validator != null) {\n            if (typeof object.validator !== \"object\") throw TypeError(\".tendermint.types.ConsensusParams.validator: object expected\");\n            message.validator = $root.tendermint.types.ValidatorParams.fromObject(object.validator);\n          }\n\n          if (object.version != null) {\n            if (typeof object.version !== \"object\") throw TypeError(\".tendermint.types.ConsensusParams.version: object expected\");\n            message.version = $root.tendermint.types.VersionParams.fromObject(object.version);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a ConsensusParams message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.ConsensusParams\n         * @static\n         * @param {tendermint.types.ConsensusParams} message ConsensusParams\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ConsensusParams.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.block = null;\n            object.evidence = null;\n            object.validator = null;\n            object.version = null;\n          }\n\n          if (message.block != null && message.hasOwnProperty(\"block\")) object.block = $root.tendermint.types.BlockParams.toObject(message.block, options);\n          if (message.evidence != null && message.hasOwnProperty(\"evidence\")) object.evidence = $root.tendermint.types.EvidenceParams.toObject(message.evidence, options);\n          if (message.validator != null && message.hasOwnProperty(\"validator\")) object.validator = $root.tendermint.types.ValidatorParams.toObject(message.validator, options);\n          if (message.version != null && message.hasOwnProperty(\"version\")) object.version = $root.tendermint.types.VersionParams.toObject(message.version, options);\n          return object;\n        };\n        /**\n         * Converts this ConsensusParams to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.ConsensusParams\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ConsensusParams.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ConsensusParams;\n      }();\n\n      types.BlockParams = function () {\n        /**\n         * Properties of a BlockParams.\n         * @memberof tendermint.types\n         * @interface IBlockParams\n         * @property {number|Long|null} [maxBytes] BlockParams maxBytes\n         * @property {number|Long|null} [maxGas] BlockParams maxGas\n         * @property {number|Long|null} [timeIotaMs] BlockParams timeIotaMs\n         */\n\n        /**\n         * Constructs a new BlockParams.\n         * @memberof tendermint.types\n         * @classdesc Represents a BlockParams.\n         * @implements IBlockParams\n         * @constructor\n         * @param {tendermint.types.IBlockParams=} [properties] Properties to set\n         */\n        function BlockParams(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * BlockParams maxBytes.\n         * @member {number|Long} maxBytes\n         * @memberof tendermint.types.BlockParams\n         * @instance\n         */\n\n\n        BlockParams.prototype.maxBytes = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * BlockParams maxGas.\n         * @member {number|Long} maxGas\n         * @memberof tendermint.types.BlockParams\n         * @instance\n         */\n\n        BlockParams.prototype.maxGas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * BlockParams timeIotaMs.\n         * @member {number|Long} timeIotaMs\n         * @memberof tendermint.types.BlockParams\n         * @instance\n         */\n\n        BlockParams.prototype.timeIotaMs = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new BlockParams instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.BlockParams\n         * @static\n         * @param {tendermint.types.IBlockParams=} [properties] Properties to set\n         * @returns {tendermint.types.BlockParams} BlockParams instance\n         */\n\n        BlockParams.create = function create(properties) {\n          return new BlockParams(properties);\n        };\n        /**\n         * Encodes the specified BlockParams message. Does not implicitly {@link tendermint.types.BlockParams.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.BlockParams\n         * @static\n         * @param {tendermint.types.IBlockParams} message BlockParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        BlockParams.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.maxBytes != null && Object.hasOwnProperty.call(message, \"maxBytes\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int64(message.maxBytes);\n          if (message.maxGas != null && Object.hasOwnProperty.call(message, \"maxGas\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int64(message.maxGas);\n          if (message.timeIotaMs != null && Object.hasOwnProperty.call(message, \"timeIotaMs\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int64(message.timeIotaMs);\n          return writer;\n        };\n        /**\n         * Encodes the specified BlockParams message, length delimited. Does not implicitly {@link tendermint.types.BlockParams.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.BlockParams\n         * @static\n         * @param {tendermint.types.IBlockParams} message BlockParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        BlockParams.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a BlockParams message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.BlockParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.BlockParams} BlockParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        BlockParams.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.BlockParams();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.maxBytes = reader.int64();\n                break;\n\n              case 2:\n                message.maxGas = reader.int64();\n                break;\n\n              case 3:\n                message.timeIotaMs = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a BlockParams message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.BlockParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.BlockParams} BlockParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        BlockParams.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a BlockParams message.\n         * @function verify\n         * @memberof tendermint.types.BlockParams\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        BlockParams.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.maxBytes != null && message.hasOwnProperty(\"maxBytes\")) if (!$util.isInteger(message.maxBytes) && !(message.maxBytes && $util.isInteger(message.maxBytes.low) && $util.isInteger(message.maxBytes.high))) return \"maxBytes: integer|Long expected\";\n          if (message.maxGas != null && message.hasOwnProperty(\"maxGas\")) if (!$util.isInteger(message.maxGas) && !(message.maxGas && $util.isInteger(message.maxGas.low) && $util.isInteger(message.maxGas.high))) return \"maxGas: integer|Long expected\";\n          if (message.timeIotaMs != null && message.hasOwnProperty(\"timeIotaMs\")) if (!$util.isInteger(message.timeIotaMs) && !(message.timeIotaMs && $util.isInteger(message.timeIotaMs.low) && $util.isInteger(message.timeIotaMs.high))) return \"timeIotaMs: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a BlockParams message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.BlockParams\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.BlockParams} BlockParams\n         */\n\n\n        BlockParams.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.BlockParams) return object;\n          var message = new $root.tendermint.types.BlockParams();\n          if (object.maxBytes != null) if ($util.Long) (message.maxBytes = $util.Long.fromValue(object.maxBytes)).unsigned = false;else if (typeof object.maxBytes === \"string\") message.maxBytes = parseInt(object.maxBytes, 10);else if (typeof object.maxBytes === \"number\") message.maxBytes = object.maxBytes;else if (typeof object.maxBytes === \"object\") message.maxBytes = new $util.LongBits(object.maxBytes.low >>> 0, object.maxBytes.high >>> 0).toNumber();\n          if (object.maxGas != null) if ($util.Long) (message.maxGas = $util.Long.fromValue(object.maxGas)).unsigned = false;else if (typeof object.maxGas === \"string\") message.maxGas = parseInt(object.maxGas, 10);else if (typeof object.maxGas === \"number\") message.maxGas = object.maxGas;else if (typeof object.maxGas === \"object\") message.maxGas = new $util.LongBits(object.maxGas.low >>> 0, object.maxGas.high >>> 0).toNumber();\n          if (object.timeIotaMs != null) if ($util.Long) (message.timeIotaMs = $util.Long.fromValue(object.timeIotaMs)).unsigned = false;else if (typeof object.timeIotaMs === \"string\") message.timeIotaMs = parseInt(object.timeIotaMs, 10);else if (typeof object.timeIotaMs === \"number\") message.timeIotaMs = object.timeIotaMs;else if (typeof object.timeIotaMs === \"object\") message.timeIotaMs = new $util.LongBits(object.timeIotaMs.low >>> 0, object.timeIotaMs.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a BlockParams message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.BlockParams\n         * @static\n         * @param {tendermint.types.BlockParams} message BlockParams\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        BlockParams.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.maxBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.maxBytes = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.maxGas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.maxGas = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.timeIotaMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.timeIotaMs = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.maxBytes != null && message.hasOwnProperty(\"maxBytes\")) if (typeof message.maxBytes === \"number\") object.maxBytes = options.longs === String ? String(message.maxBytes) : message.maxBytes;else object.maxBytes = options.longs === String ? $util.Long.prototype.toString.call(message.maxBytes) : options.longs === Number ? new $util.LongBits(message.maxBytes.low >>> 0, message.maxBytes.high >>> 0).toNumber() : message.maxBytes;\n          if (message.maxGas != null && message.hasOwnProperty(\"maxGas\")) if (typeof message.maxGas === \"number\") object.maxGas = options.longs === String ? String(message.maxGas) : message.maxGas;else object.maxGas = options.longs === String ? $util.Long.prototype.toString.call(message.maxGas) : options.longs === Number ? new $util.LongBits(message.maxGas.low >>> 0, message.maxGas.high >>> 0).toNumber() : message.maxGas;\n          if (message.timeIotaMs != null && message.hasOwnProperty(\"timeIotaMs\")) if (typeof message.timeIotaMs === \"number\") object.timeIotaMs = options.longs === String ? String(message.timeIotaMs) : message.timeIotaMs;else object.timeIotaMs = options.longs === String ? $util.Long.prototype.toString.call(message.timeIotaMs) : options.longs === Number ? new $util.LongBits(message.timeIotaMs.low >>> 0, message.timeIotaMs.high >>> 0).toNumber() : message.timeIotaMs;\n          return object;\n        };\n        /**\n         * Converts this BlockParams to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.BlockParams\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        BlockParams.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BlockParams;\n      }();\n\n      types.EvidenceParams = function () {\n        /**\n         * Properties of an EvidenceParams.\n         * @memberof tendermint.types\n         * @interface IEvidenceParams\n         * @property {number|Long|null} [maxAgeNumBlocks] EvidenceParams maxAgeNumBlocks\n         * @property {google.protobuf.IDuration|null} [maxAgeDuration] EvidenceParams maxAgeDuration\n         * @property {number|Long|null} [maxBytes] EvidenceParams maxBytes\n         */\n\n        /**\n         * Constructs a new EvidenceParams.\n         * @memberof tendermint.types\n         * @classdesc Represents an EvidenceParams.\n         * @implements IEvidenceParams\n         * @constructor\n         * @param {tendermint.types.IEvidenceParams=} [properties] Properties to set\n         */\n        function EvidenceParams(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * EvidenceParams maxAgeNumBlocks.\n         * @member {number|Long} maxAgeNumBlocks\n         * @memberof tendermint.types.EvidenceParams\n         * @instance\n         */\n\n\n        EvidenceParams.prototype.maxAgeNumBlocks = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * EvidenceParams maxAgeDuration.\n         * @member {google.protobuf.IDuration|null|undefined} maxAgeDuration\n         * @memberof tendermint.types.EvidenceParams\n         * @instance\n         */\n\n        EvidenceParams.prototype.maxAgeDuration = null;\n        /**\n         * EvidenceParams maxBytes.\n         * @member {number|Long} maxBytes\n         * @memberof tendermint.types.EvidenceParams\n         * @instance\n         */\n\n        EvidenceParams.prototype.maxBytes = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new EvidenceParams instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.EvidenceParams\n         * @static\n         * @param {tendermint.types.IEvidenceParams=} [properties] Properties to set\n         * @returns {tendermint.types.EvidenceParams} EvidenceParams instance\n         */\n\n        EvidenceParams.create = function create(properties) {\n          return new EvidenceParams(properties);\n        };\n        /**\n         * Encodes the specified EvidenceParams message. Does not implicitly {@link tendermint.types.EvidenceParams.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.EvidenceParams\n         * @static\n         * @param {tendermint.types.IEvidenceParams} message EvidenceParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EvidenceParams.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.maxAgeNumBlocks != null && Object.hasOwnProperty.call(message, \"maxAgeNumBlocks\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int64(message.maxAgeNumBlocks);\n          if (message.maxAgeDuration != null && Object.hasOwnProperty.call(message, \"maxAgeDuration\")) $root.google.protobuf.Duration.encode(message.maxAgeDuration, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          if (message.maxBytes != null && Object.hasOwnProperty.call(message, \"maxBytes\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int64(message.maxBytes);\n          return writer;\n        };\n        /**\n         * Encodes the specified EvidenceParams message, length delimited. Does not implicitly {@link tendermint.types.EvidenceParams.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.EvidenceParams\n         * @static\n         * @param {tendermint.types.IEvidenceParams} message EvidenceParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EvidenceParams.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an EvidenceParams message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.EvidenceParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.EvidenceParams} EvidenceParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EvidenceParams.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.EvidenceParams();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.maxAgeNumBlocks = reader.int64();\n                break;\n\n              case 2:\n                message.maxAgeDuration = $root.google.protobuf.Duration.decode(reader, reader.uint32());\n                break;\n\n              case 3:\n                message.maxBytes = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an EvidenceParams message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.EvidenceParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.EvidenceParams} EvidenceParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EvidenceParams.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an EvidenceParams message.\n         * @function verify\n         * @memberof tendermint.types.EvidenceParams\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        EvidenceParams.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.maxAgeNumBlocks != null && message.hasOwnProperty(\"maxAgeNumBlocks\")) if (!$util.isInteger(message.maxAgeNumBlocks) && !(message.maxAgeNumBlocks && $util.isInteger(message.maxAgeNumBlocks.low) && $util.isInteger(message.maxAgeNumBlocks.high))) return \"maxAgeNumBlocks: integer|Long expected\";\n\n          if (message.maxAgeDuration != null && message.hasOwnProperty(\"maxAgeDuration\")) {\n            var error = $root.google.protobuf.Duration.verify(message.maxAgeDuration);\n            if (error) return \"maxAgeDuration.\" + error;\n          }\n\n          if (message.maxBytes != null && message.hasOwnProperty(\"maxBytes\")) if (!$util.isInteger(message.maxBytes) && !(message.maxBytes && $util.isInteger(message.maxBytes.low) && $util.isInteger(message.maxBytes.high))) return \"maxBytes: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates an EvidenceParams message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.EvidenceParams\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.EvidenceParams} EvidenceParams\n         */\n\n\n        EvidenceParams.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.EvidenceParams) return object;\n          var message = new $root.tendermint.types.EvidenceParams();\n          if (object.maxAgeNumBlocks != null) if ($util.Long) (message.maxAgeNumBlocks = $util.Long.fromValue(object.maxAgeNumBlocks)).unsigned = false;else if (typeof object.maxAgeNumBlocks === \"string\") message.maxAgeNumBlocks = parseInt(object.maxAgeNumBlocks, 10);else if (typeof object.maxAgeNumBlocks === \"number\") message.maxAgeNumBlocks = object.maxAgeNumBlocks;else if (typeof object.maxAgeNumBlocks === \"object\") message.maxAgeNumBlocks = new $util.LongBits(object.maxAgeNumBlocks.low >>> 0, object.maxAgeNumBlocks.high >>> 0).toNumber();\n\n          if (object.maxAgeDuration != null) {\n            if (typeof object.maxAgeDuration !== \"object\") throw TypeError(\".tendermint.types.EvidenceParams.maxAgeDuration: object expected\");\n            message.maxAgeDuration = $root.google.protobuf.Duration.fromObject(object.maxAgeDuration);\n          }\n\n          if (object.maxBytes != null) if ($util.Long) (message.maxBytes = $util.Long.fromValue(object.maxBytes)).unsigned = false;else if (typeof object.maxBytes === \"string\") message.maxBytes = parseInt(object.maxBytes, 10);else if (typeof object.maxBytes === \"number\") message.maxBytes = object.maxBytes;else if (typeof object.maxBytes === \"object\") message.maxBytes = new $util.LongBits(object.maxBytes.low >>> 0, object.maxBytes.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from an EvidenceParams message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.EvidenceParams\n         * @static\n         * @param {tendermint.types.EvidenceParams} message EvidenceParams\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        EvidenceParams.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.maxAgeNumBlocks = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.maxAgeNumBlocks = options.longs === String ? \"0\" : 0;\n\n            object.maxAgeDuration = null;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.maxBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.maxBytes = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.maxAgeNumBlocks != null && message.hasOwnProperty(\"maxAgeNumBlocks\")) if (typeof message.maxAgeNumBlocks === \"number\") object.maxAgeNumBlocks = options.longs === String ? String(message.maxAgeNumBlocks) : message.maxAgeNumBlocks;else object.maxAgeNumBlocks = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNumBlocks) : options.longs === Number ? new $util.LongBits(message.maxAgeNumBlocks.low >>> 0, message.maxAgeNumBlocks.high >>> 0).toNumber() : message.maxAgeNumBlocks;\n          if (message.maxAgeDuration != null && message.hasOwnProperty(\"maxAgeDuration\")) object.maxAgeDuration = $root.google.protobuf.Duration.toObject(message.maxAgeDuration, options);\n          if (message.maxBytes != null && message.hasOwnProperty(\"maxBytes\")) if (typeof message.maxBytes === \"number\") object.maxBytes = options.longs === String ? String(message.maxBytes) : message.maxBytes;else object.maxBytes = options.longs === String ? $util.Long.prototype.toString.call(message.maxBytes) : options.longs === Number ? new $util.LongBits(message.maxBytes.low >>> 0, message.maxBytes.high >>> 0).toNumber() : message.maxBytes;\n          return object;\n        };\n        /**\n         * Converts this EvidenceParams to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.EvidenceParams\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        EvidenceParams.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return EvidenceParams;\n      }();\n\n      types.ValidatorParams = function () {\n        /**\n         * Properties of a ValidatorParams.\n         * @memberof tendermint.types\n         * @interface IValidatorParams\n         * @property {Array.<string>|null} [pubKeyTypes] ValidatorParams pubKeyTypes\n         */\n\n        /**\n         * Constructs a new ValidatorParams.\n         * @memberof tendermint.types\n         * @classdesc Represents a ValidatorParams.\n         * @implements IValidatorParams\n         * @constructor\n         * @param {tendermint.types.IValidatorParams=} [properties] Properties to set\n         */\n        function ValidatorParams(properties) {\n          this.pubKeyTypes = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ValidatorParams pubKeyTypes.\n         * @member {Array.<string>} pubKeyTypes\n         * @memberof tendermint.types.ValidatorParams\n         * @instance\n         */\n\n\n        ValidatorParams.prototype.pubKeyTypes = $util.emptyArray;\n        /**\n         * Creates a new ValidatorParams instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.ValidatorParams\n         * @static\n         * @param {tendermint.types.IValidatorParams=} [properties] Properties to set\n         * @returns {tendermint.types.ValidatorParams} ValidatorParams instance\n         */\n\n        ValidatorParams.create = function create(properties) {\n          return new ValidatorParams(properties);\n        };\n        /**\n         * Encodes the specified ValidatorParams message. Does not implicitly {@link tendermint.types.ValidatorParams.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.ValidatorParams\n         * @static\n         * @param {tendermint.types.IValidatorParams} message ValidatorParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ValidatorParams.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.pubKeyTypes != null && message.pubKeyTypes.length) for (var i = 0; i < message.pubKeyTypes.length; ++i) {\n            writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).string(message.pubKeyTypes[i]);\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified ValidatorParams message, length delimited. Does not implicitly {@link tendermint.types.ValidatorParams.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.ValidatorParams\n         * @static\n         * @param {tendermint.types.IValidatorParams} message ValidatorParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ValidatorParams.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ValidatorParams message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.ValidatorParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.ValidatorParams} ValidatorParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ValidatorParams.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.ValidatorParams();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.pubKeyTypes && message.pubKeyTypes.length)) message.pubKeyTypes = [];\n                message.pubKeyTypes.push(reader.string());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ValidatorParams message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.ValidatorParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.ValidatorParams} ValidatorParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ValidatorParams.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ValidatorParams message.\n         * @function verify\n         * @memberof tendermint.types.ValidatorParams\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ValidatorParams.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.pubKeyTypes != null && message.hasOwnProperty(\"pubKeyTypes\")) {\n            if (!Array.isArray(message.pubKeyTypes)) return \"pubKeyTypes: array expected\";\n\n            for (var i = 0; i < message.pubKeyTypes.length; ++i) {\n              if (!$util.isString(message.pubKeyTypes[i])) return \"pubKeyTypes: string[] expected\";\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a ValidatorParams message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.ValidatorParams\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.ValidatorParams} ValidatorParams\n         */\n\n\n        ValidatorParams.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.ValidatorParams) return object;\n          var message = new $root.tendermint.types.ValidatorParams();\n\n          if (object.pubKeyTypes) {\n            if (!Array.isArray(object.pubKeyTypes)) throw TypeError(\".tendermint.types.ValidatorParams.pubKeyTypes: array expected\");\n            message.pubKeyTypes = [];\n\n            for (var i = 0; i < object.pubKeyTypes.length; ++i) {\n              message.pubKeyTypes[i] = String(object.pubKeyTypes[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a ValidatorParams message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.ValidatorParams\n         * @static\n         * @param {tendermint.types.ValidatorParams} message ValidatorParams\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ValidatorParams.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.pubKeyTypes = [];\n\n          if (message.pubKeyTypes && message.pubKeyTypes.length) {\n            object.pubKeyTypes = [];\n\n            for (var j = 0; j < message.pubKeyTypes.length; ++j) {\n              object.pubKeyTypes[j] = message.pubKeyTypes[j];\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this ValidatorParams to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.ValidatorParams\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ValidatorParams.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ValidatorParams;\n      }();\n\n      types.VersionParams = function () {\n        /**\n         * Properties of a VersionParams.\n         * @memberof tendermint.types\n         * @interface IVersionParams\n         * @property {number|Long|null} [appVersion] VersionParams appVersion\n         */\n\n        /**\n         * Constructs a new VersionParams.\n         * @memberof tendermint.types\n         * @classdesc Represents a VersionParams.\n         * @implements IVersionParams\n         * @constructor\n         * @param {tendermint.types.IVersionParams=} [properties] Properties to set\n         */\n        function VersionParams(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * VersionParams appVersion.\n         * @member {number|Long} appVersion\n         * @memberof tendermint.types.VersionParams\n         * @instance\n         */\n\n\n        VersionParams.prototype.appVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        /**\n         * Creates a new VersionParams instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.VersionParams\n         * @static\n         * @param {tendermint.types.IVersionParams=} [properties] Properties to set\n         * @returns {tendermint.types.VersionParams} VersionParams instance\n         */\n\n        VersionParams.create = function create(properties) {\n          return new VersionParams(properties);\n        };\n        /**\n         * Encodes the specified VersionParams message. Does not implicitly {@link tendermint.types.VersionParams.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.VersionParams\n         * @static\n         * @param {tendermint.types.IVersionParams} message VersionParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        VersionParams.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.appVersion != null && Object.hasOwnProperty.call(message, \"appVersion\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).uint64(message.appVersion);\n          return writer;\n        };\n        /**\n         * Encodes the specified VersionParams message, length delimited. Does not implicitly {@link tendermint.types.VersionParams.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.VersionParams\n         * @static\n         * @param {tendermint.types.IVersionParams} message VersionParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        VersionParams.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a VersionParams message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.VersionParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.VersionParams} VersionParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        VersionParams.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.VersionParams();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.appVersion = reader.uint64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a VersionParams message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.VersionParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.VersionParams} VersionParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        VersionParams.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a VersionParams message.\n         * @function verify\n         * @memberof tendermint.types.VersionParams\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        VersionParams.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.appVersion != null && message.hasOwnProperty(\"appVersion\")) if (!$util.isInteger(message.appVersion) && !(message.appVersion && $util.isInteger(message.appVersion.low) && $util.isInteger(message.appVersion.high))) return \"appVersion: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a VersionParams message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.VersionParams\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.VersionParams} VersionParams\n         */\n\n\n        VersionParams.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.VersionParams) return object;\n          var message = new $root.tendermint.types.VersionParams();\n          if (object.appVersion != null) if ($util.Long) (message.appVersion = $util.Long.fromValue(object.appVersion)).unsigned = true;else if (typeof object.appVersion === \"string\") message.appVersion = parseInt(object.appVersion, 10);else if (typeof object.appVersion === \"number\") message.appVersion = object.appVersion;else if (typeof object.appVersion === \"object\") message.appVersion = new $util.LongBits(object.appVersion.low >>> 0, object.appVersion.high >>> 0).toNumber(true);\n          return message;\n        };\n        /**\n         * Creates a plain object from a VersionParams message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.VersionParams\n         * @static\n         * @param {tendermint.types.VersionParams} message VersionParams\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        VersionParams.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.defaults) if ($util.Long) {\n            var long = new $util.Long(0, 0, true);\n            object.appVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n          } else object.appVersion = options.longs === String ? \"0\" : 0;\n          if (message.appVersion != null && message.hasOwnProperty(\"appVersion\")) if (typeof message.appVersion === \"number\") object.appVersion = options.longs === String ? String(message.appVersion) : message.appVersion;else object.appVersion = options.longs === String ? $util.Long.prototype.toString.call(message.appVersion) : options.longs === Number ? new $util.LongBits(message.appVersion.low >>> 0, message.appVersion.high >>> 0).toNumber(true) : message.appVersion;\n          return object;\n        };\n        /**\n         * Converts this VersionParams to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.VersionParams\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        VersionParams.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return VersionParams;\n      }();\n\n      types.HashedParams = function () {\n        /**\n         * Properties of a HashedParams.\n         * @memberof tendermint.types\n         * @interface IHashedParams\n         * @property {number|Long|null} [blockMaxBytes] HashedParams blockMaxBytes\n         * @property {number|Long|null} [blockMaxGas] HashedParams blockMaxGas\n         */\n\n        /**\n         * Constructs a new HashedParams.\n         * @memberof tendermint.types\n         * @classdesc Represents a HashedParams.\n         * @implements IHashedParams\n         * @constructor\n         * @param {tendermint.types.IHashedParams=} [properties] Properties to set\n         */\n        function HashedParams(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * HashedParams blockMaxBytes.\n         * @member {number|Long} blockMaxBytes\n         * @memberof tendermint.types.HashedParams\n         * @instance\n         */\n\n\n        HashedParams.prototype.blockMaxBytes = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * HashedParams blockMaxGas.\n         * @member {number|Long} blockMaxGas\n         * @memberof tendermint.types.HashedParams\n         * @instance\n         */\n\n        HashedParams.prototype.blockMaxGas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new HashedParams instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.HashedParams\n         * @static\n         * @param {tendermint.types.IHashedParams=} [properties] Properties to set\n         * @returns {tendermint.types.HashedParams} HashedParams instance\n         */\n\n        HashedParams.create = function create(properties) {\n          return new HashedParams(properties);\n        };\n        /**\n         * Encodes the specified HashedParams message. Does not implicitly {@link tendermint.types.HashedParams.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.HashedParams\n         * @static\n         * @param {tendermint.types.IHashedParams} message HashedParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        HashedParams.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.blockMaxBytes != null && Object.hasOwnProperty.call(message, \"blockMaxBytes\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int64(message.blockMaxBytes);\n          if (message.blockMaxGas != null && Object.hasOwnProperty.call(message, \"blockMaxGas\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int64(message.blockMaxGas);\n          return writer;\n        };\n        /**\n         * Encodes the specified HashedParams message, length delimited. Does not implicitly {@link tendermint.types.HashedParams.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.HashedParams\n         * @static\n         * @param {tendermint.types.IHashedParams} message HashedParams message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        HashedParams.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a HashedParams message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.HashedParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.HashedParams} HashedParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        HashedParams.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.HashedParams();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.blockMaxBytes = reader.int64();\n                break;\n\n              case 2:\n                message.blockMaxGas = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a HashedParams message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.HashedParams\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.HashedParams} HashedParams\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        HashedParams.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a HashedParams message.\n         * @function verify\n         * @memberof tendermint.types.HashedParams\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        HashedParams.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.blockMaxBytes != null && message.hasOwnProperty(\"blockMaxBytes\")) if (!$util.isInteger(message.blockMaxBytes) && !(message.blockMaxBytes && $util.isInteger(message.blockMaxBytes.low) && $util.isInteger(message.blockMaxBytes.high))) return \"blockMaxBytes: integer|Long expected\";\n          if (message.blockMaxGas != null && message.hasOwnProperty(\"blockMaxGas\")) if (!$util.isInteger(message.blockMaxGas) && !(message.blockMaxGas && $util.isInteger(message.blockMaxGas.low) && $util.isInteger(message.blockMaxGas.high))) return \"blockMaxGas: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a HashedParams message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.HashedParams\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.HashedParams} HashedParams\n         */\n\n\n        HashedParams.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.HashedParams) return object;\n          var message = new $root.tendermint.types.HashedParams();\n          if (object.blockMaxBytes != null) if ($util.Long) (message.blockMaxBytes = $util.Long.fromValue(object.blockMaxBytes)).unsigned = false;else if (typeof object.blockMaxBytes === \"string\") message.blockMaxBytes = parseInt(object.blockMaxBytes, 10);else if (typeof object.blockMaxBytes === \"number\") message.blockMaxBytes = object.blockMaxBytes;else if (typeof object.blockMaxBytes === \"object\") message.blockMaxBytes = new $util.LongBits(object.blockMaxBytes.low >>> 0, object.blockMaxBytes.high >>> 0).toNumber();\n          if (object.blockMaxGas != null) if ($util.Long) (message.blockMaxGas = $util.Long.fromValue(object.blockMaxGas)).unsigned = false;else if (typeof object.blockMaxGas === \"string\") message.blockMaxGas = parseInt(object.blockMaxGas, 10);else if (typeof object.blockMaxGas === \"number\") message.blockMaxGas = object.blockMaxGas;else if (typeof object.blockMaxGas === \"object\") message.blockMaxGas = new $util.LongBits(object.blockMaxGas.low >>> 0, object.blockMaxGas.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a HashedParams message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.HashedParams\n         * @static\n         * @param {tendermint.types.HashedParams} message HashedParams\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        HashedParams.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.blockMaxBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.blockMaxBytes = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.blockMaxGas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.blockMaxGas = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.blockMaxBytes != null && message.hasOwnProperty(\"blockMaxBytes\")) if (typeof message.blockMaxBytes === \"number\") object.blockMaxBytes = options.longs === String ? String(message.blockMaxBytes) : message.blockMaxBytes;else object.blockMaxBytes = options.longs === String ? $util.Long.prototype.toString.call(message.blockMaxBytes) : options.longs === Number ? new $util.LongBits(message.blockMaxBytes.low >>> 0, message.blockMaxBytes.high >>> 0).toNumber() : message.blockMaxBytes;\n          if (message.blockMaxGas != null && message.hasOwnProperty(\"blockMaxGas\")) if (typeof message.blockMaxGas === \"number\") object.blockMaxGas = options.longs === String ? String(message.blockMaxGas) : message.blockMaxGas;else object.blockMaxGas = options.longs === String ? $util.Long.prototype.toString.call(message.blockMaxGas) : options.longs === Number ? new $util.LongBits(message.blockMaxGas.low >>> 0, message.blockMaxGas.high >>> 0).toNumber() : message.blockMaxGas;\n          return object;\n        };\n        /**\n         * Converts this HashedParams to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.HashedParams\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        HashedParams.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return HashedParams;\n      }();\n      /**\n       * BlockIDFlag enum.\n       * @name tendermint.types.BlockIDFlag\n       * @enum {number}\n       * @property {number} BLOCK_ID_FLAG_UNKNOWN=0 BLOCK_ID_FLAG_UNKNOWN value\n       * @property {number} BLOCK_ID_FLAG_ABSENT=1 BLOCK_ID_FLAG_ABSENT value\n       * @property {number} BLOCK_ID_FLAG_COMMIT=2 BLOCK_ID_FLAG_COMMIT value\n       * @property {number} BLOCK_ID_FLAG_NIL=3 BLOCK_ID_FLAG_NIL value\n       */\n\n\n      types.BlockIDFlag = function () {\n        var valuesById = {},\n            values = Object.create(valuesById);\n        values[valuesById[0] = \"BLOCK_ID_FLAG_UNKNOWN\"] = 0;\n        values[valuesById[1] = \"BLOCK_ID_FLAG_ABSENT\"] = 1;\n        values[valuesById[2] = \"BLOCK_ID_FLAG_COMMIT\"] = 2;\n        values[valuesById[3] = \"BLOCK_ID_FLAG_NIL\"] = 3;\n        return values;\n      }();\n      /**\n       * SignedMsgType enum.\n       * @name tendermint.types.SignedMsgType\n       * @enum {number}\n       * @property {number} SIGNED_MSG_TYPE_UNKNOWN=0 SIGNED_MSG_TYPE_UNKNOWN value\n       * @property {number} SIGNED_MSG_TYPE_PREVOTE=1 SIGNED_MSG_TYPE_PREVOTE value\n       * @property {number} SIGNED_MSG_TYPE_PRECOMMIT=2 SIGNED_MSG_TYPE_PRECOMMIT value\n       * @property {number} SIGNED_MSG_TYPE_PROPOSAL=32 SIGNED_MSG_TYPE_PROPOSAL value\n       */\n\n\n      types.SignedMsgType = function () {\n        var valuesById = {},\n            values = Object.create(valuesById);\n        values[valuesById[0] = \"SIGNED_MSG_TYPE_UNKNOWN\"] = 0;\n        values[valuesById[1] = \"SIGNED_MSG_TYPE_PREVOTE\"] = 1;\n        values[valuesById[2] = \"SIGNED_MSG_TYPE_PRECOMMIT\"] = 2;\n        values[valuesById[32] = \"SIGNED_MSG_TYPE_PROPOSAL\"] = 32;\n        return values;\n      }();\n\n      types.PartSetHeader = function () {\n        /**\n         * Properties of a PartSetHeader.\n         * @memberof tendermint.types\n         * @interface IPartSetHeader\n         * @property {number|null} [total] PartSetHeader total\n         * @property {Uint8Array|null} [hash] PartSetHeader hash\n         */\n\n        /**\n         * Constructs a new PartSetHeader.\n         * @memberof tendermint.types\n         * @classdesc Represents a PartSetHeader.\n         * @implements IPartSetHeader\n         * @constructor\n         * @param {tendermint.types.IPartSetHeader=} [properties] Properties to set\n         */\n        function PartSetHeader(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * PartSetHeader total.\n         * @member {number} total\n         * @memberof tendermint.types.PartSetHeader\n         * @instance\n         */\n\n\n        PartSetHeader.prototype.total = 0;\n        /**\n         * PartSetHeader hash.\n         * @member {Uint8Array} hash\n         * @memberof tendermint.types.PartSetHeader\n         * @instance\n         */\n\n        PartSetHeader.prototype.hash = $util.newBuffer([]);\n        /**\n         * Creates a new PartSetHeader instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.PartSetHeader\n         * @static\n         * @param {tendermint.types.IPartSetHeader=} [properties] Properties to set\n         * @returns {tendermint.types.PartSetHeader} PartSetHeader instance\n         */\n\n        PartSetHeader.create = function create(properties) {\n          return new PartSetHeader(properties);\n        };\n        /**\n         * Encodes the specified PartSetHeader message. Does not implicitly {@link tendermint.types.PartSetHeader.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.PartSetHeader\n         * @static\n         * @param {tendermint.types.IPartSetHeader} message PartSetHeader message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        PartSetHeader.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.total != null && Object.hasOwnProperty.call(message, \"total\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).uint32(message.total);\n          if (message.hash != null && Object.hasOwnProperty.call(message, \"hash\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.hash);\n          return writer;\n        };\n        /**\n         * Encodes the specified PartSetHeader message, length delimited. Does not implicitly {@link tendermint.types.PartSetHeader.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.PartSetHeader\n         * @static\n         * @param {tendermint.types.IPartSetHeader} message PartSetHeader message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        PartSetHeader.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a PartSetHeader message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.PartSetHeader\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.PartSetHeader} PartSetHeader\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        PartSetHeader.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.PartSetHeader();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.total = reader.uint32();\n                break;\n\n              case 2:\n                message.hash = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a PartSetHeader message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.PartSetHeader\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.PartSetHeader} PartSetHeader\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        PartSetHeader.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a PartSetHeader message.\n         * @function verify\n         * @memberof tendermint.types.PartSetHeader\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        PartSetHeader.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.total != null && message.hasOwnProperty(\"total\")) if (!$util.isInteger(message.total)) return \"total: integer expected\";\n          if (message.hash != null && message.hasOwnProperty(\"hash\")) if (!(message.hash && typeof message.hash.length === \"number\" || $util.isString(message.hash))) return \"hash: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates a PartSetHeader message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.PartSetHeader\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.PartSetHeader} PartSetHeader\n         */\n\n\n        PartSetHeader.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.PartSetHeader) return object;\n          var message = new $root.tendermint.types.PartSetHeader();\n          if (object.total != null) message.total = object.total >>> 0;\n          if (object.hash != null) if (typeof object.hash === \"string\") $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);else if (object.hash.length) message.hash = object.hash;\n          return message;\n        };\n        /**\n         * Creates a plain object from a PartSetHeader message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.PartSetHeader\n         * @static\n         * @param {tendermint.types.PartSetHeader} message PartSetHeader\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        PartSetHeader.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.total = 0;\n            if (options.bytes === String) object.hash = \"\";else {\n              object.hash = [];\n              if (options.bytes !== Array) object.hash = $util.newBuffer(object.hash);\n            }\n          }\n\n          if (message.total != null && message.hasOwnProperty(\"total\")) object.total = message.total;\n          if (message.hash != null && message.hasOwnProperty(\"hash\")) object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;\n          return object;\n        };\n        /**\n         * Converts this PartSetHeader to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.PartSetHeader\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        PartSetHeader.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return PartSetHeader;\n      }();\n\n      types.Part = function () {\n        /**\n         * Properties of a Part.\n         * @memberof tendermint.types\n         * @interface IPart\n         * @property {number|null} [index] Part index\n         * @property {Uint8Array|null} [bytes] Part bytes\n         * @property {tendermint.crypto.IProof|null} [proof] Part proof\n         */\n\n        /**\n         * Constructs a new Part.\n         * @memberof tendermint.types\n         * @classdesc Represents a Part.\n         * @implements IPart\n         * @constructor\n         * @param {tendermint.types.IPart=} [properties] Properties to set\n         */\n        function Part(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Part index.\n         * @member {number} index\n         * @memberof tendermint.types.Part\n         * @instance\n         */\n\n\n        Part.prototype.index = 0;\n        /**\n         * Part bytes.\n         * @member {Uint8Array} bytes\n         * @memberof tendermint.types.Part\n         * @instance\n         */\n\n        Part.prototype.bytes = $util.newBuffer([]);\n        /**\n         * Part proof.\n         * @member {tendermint.crypto.IProof|null|undefined} proof\n         * @memberof tendermint.types.Part\n         * @instance\n         */\n\n        Part.prototype.proof = null;\n        /**\n         * Creates a new Part instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.Part\n         * @static\n         * @param {tendermint.types.IPart=} [properties] Properties to set\n         * @returns {tendermint.types.Part} Part instance\n         */\n\n        Part.create = function create(properties) {\n          return new Part(properties);\n        };\n        /**\n         * Encodes the specified Part message. Does not implicitly {@link tendermint.types.Part.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.Part\n         * @static\n         * @param {tendermint.types.IPart} message Part message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Part.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.index != null && Object.hasOwnProperty.call(message, \"index\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).uint32(message.index);\n          if (message.bytes != null && Object.hasOwnProperty.call(message, \"bytes\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.bytes);\n          if (message.proof != null && Object.hasOwnProperty.call(message, \"proof\")) $root.tendermint.crypto.Proof.encode(message.proof, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified Part message, length delimited. Does not implicitly {@link tendermint.types.Part.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.Part\n         * @static\n         * @param {tendermint.types.IPart} message Part message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Part.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Part message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.Part\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.Part} Part\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Part.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.Part();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.index = reader.uint32();\n                break;\n\n              case 2:\n                message.bytes = reader.bytes();\n                break;\n\n              case 3:\n                message.proof = $root.tendermint.crypto.Proof.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Part message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.Part\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.Part} Part\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Part.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Part message.\n         * @function verify\n         * @memberof tendermint.types.Part\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Part.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.index != null && message.hasOwnProperty(\"index\")) if (!$util.isInteger(message.index)) return \"index: integer expected\";\n          if (message.bytes != null && message.hasOwnProperty(\"bytes\")) if (!(message.bytes && typeof message.bytes.length === \"number\" || $util.isString(message.bytes))) return \"bytes: buffer expected\";\n\n          if (message.proof != null && message.hasOwnProperty(\"proof\")) {\n            var error = $root.tendermint.crypto.Proof.verify(message.proof);\n            if (error) return \"proof.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a Part message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.Part\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.Part} Part\n         */\n\n\n        Part.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.Part) return object;\n          var message = new $root.tendermint.types.Part();\n          if (object.index != null) message.index = object.index >>> 0;\n          if (object.bytes != null) if (typeof object.bytes === \"string\") $util.base64.decode(object.bytes, message.bytes = $util.newBuffer($util.base64.length(object.bytes)), 0);else if (object.bytes.length) message.bytes = object.bytes;\n\n          if (object.proof != null) {\n            if (typeof object.proof !== \"object\") throw TypeError(\".tendermint.types.Part.proof: object expected\");\n            message.proof = $root.tendermint.crypto.Proof.fromObject(object.proof);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a Part message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.Part\n         * @static\n         * @param {tendermint.types.Part} message Part\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Part.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.index = 0;\n            if (options.bytes === String) object.bytes = \"\";else {\n              object.bytes = [];\n              if (options.bytes !== Array) object.bytes = $util.newBuffer(object.bytes);\n            }\n            object.proof = null;\n          }\n\n          if (message.index != null && message.hasOwnProperty(\"index\")) object.index = message.index;\n          if (message.bytes != null && message.hasOwnProperty(\"bytes\")) object.bytes = options.bytes === String ? $util.base64.encode(message.bytes, 0, message.bytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytes) : message.bytes;\n          if (message.proof != null && message.hasOwnProperty(\"proof\")) object.proof = $root.tendermint.crypto.Proof.toObject(message.proof, options);\n          return object;\n        };\n        /**\n         * Converts this Part to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.Part\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Part.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Part;\n      }();\n\n      types.BlockID = function () {\n        /**\n         * Properties of a BlockID.\n         * @memberof tendermint.types\n         * @interface IBlockID\n         * @property {Uint8Array|null} [hash] BlockID hash\n         * @property {tendermint.types.IPartSetHeader|null} [partSetHeader] BlockID partSetHeader\n         */\n\n        /**\n         * Constructs a new BlockID.\n         * @memberof tendermint.types\n         * @classdesc Represents a BlockID.\n         * @implements IBlockID\n         * @constructor\n         * @param {tendermint.types.IBlockID=} [properties] Properties to set\n         */\n        function BlockID(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * BlockID hash.\n         * @member {Uint8Array} hash\n         * @memberof tendermint.types.BlockID\n         * @instance\n         */\n\n\n        BlockID.prototype.hash = $util.newBuffer([]);\n        /**\n         * BlockID partSetHeader.\n         * @member {tendermint.types.IPartSetHeader|null|undefined} partSetHeader\n         * @memberof tendermint.types.BlockID\n         * @instance\n         */\n\n        BlockID.prototype.partSetHeader = null;\n        /**\n         * Creates a new BlockID instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.BlockID\n         * @static\n         * @param {tendermint.types.IBlockID=} [properties] Properties to set\n         * @returns {tendermint.types.BlockID} BlockID instance\n         */\n\n        BlockID.create = function create(properties) {\n          return new BlockID(properties);\n        };\n        /**\n         * Encodes the specified BlockID message. Does not implicitly {@link tendermint.types.BlockID.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.BlockID\n         * @static\n         * @param {tendermint.types.IBlockID} message BlockID message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        BlockID.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.hash != null && Object.hasOwnProperty.call(message, \"hash\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).bytes(message.hash);\n          if (message.partSetHeader != null && Object.hasOwnProperty.call(message, \"partSetHeader\")) $root.tendermint.types.PartSetHeader.encode(message.partSetHeader, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified BlockID message, length delimited. Does not implicitly {@link tendermint.types.BlockID.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.BlockID\n         * @static\n         * @param {tendermint.types.IBlockID} message BlockID message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        BlockID.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a BlockID message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.BlockID\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.BlockID} BlockID\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        BlockID.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.BlockID();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.hash = reader.bytes();\n                break;\n\n              case 2:\n                message.partSetHeader = $root.tendermint.types.PartSetHeader.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a BlockID message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.BlockID\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.BlockID} BlockID\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        BlockID.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a BlockID message.\n         * @function verify\n         * @memberof tendermint.types.BlockID\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        BlockID.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.hash != null && message.hasOwnProperty(\"hash\")) if (!(message.hash && typeof message.hash.length === \"number\" || $util.isString(message.hash))) return \"hash: buffer expected\";\n\n          if (message.partSetHeader != null && message.hasOwnProperty(\"partSetHeader\")) {\n            var error = $root.tendermint.types.PartSetHeader.verify(message.partSetHeader);\n            if (error) return \"partSetHeader.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a BlockID message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.BlockID\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.BlockID} BlockID\n         */\n\n\n        BlockID.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.BlockID) return object;\n          var message = new $root.tendermint.types.BlockID();\n          if (object.hash != null) if (typeof object.hash === \"string\") $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);else if (object.hash.length) message.hash = object.hash;\n\n          if (object.partSetHeader != null) {\n            if (typeof object.partSetHeader !== \"object\") throw TypeError(\".tendermint.types.BlockID.partSetHeader: object expected\");\n            message.partSetHeader = $root.tendermint.types.PartSetHeader.fromObject(object.partSetHeader);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a BlockID message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.BlockID\n         * @static\n         * @param {tendermint.types.BlockID} message BlockID\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        BlockID.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if (options.bytes === String) object.hash = \"\";else {\n              object.hash = [];\n              if (options.bytes !== Array) object.hash = $util.newBuffer(object.hash);\n            }\n            object.partSetHeader = null;\n          }\n\n          if (message.hash != null && message.hasOwnProperty(\"hash\")) object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;\n          if (message.partSetHeader != null && message.hasOwnProperty(\"partSetHeader\")) object.partSetHeader = $root.tendermint.types.PartSetHeader.toObject(message.partSetHeader, options);\n          return object;\n        };\n        /**\n         * Converts this BlockID to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.BlockID\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        BlockID.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BlockID;\n      }();\n\n      types.Header = function () {\n        /**\n         * Properties of a Header.\n         * @memberof tendermint.types\n         * @interface IHeader\n         * @property {tendermint.version.IConsensus|null} [version] Header version\n         * @property {string|null} [chainId] Header chainId\n         * @property {number|Long|null} [height] Header height\n         * @property {google.protobuf.ITimestamp|null} [time] Header time\n         * @property {tendermint.types.IBlockID|null} [lastBlockId] Header lastBlockId\n         * @property {Uint8Array|null} [lastCommitHash] Header lastCommitHash\n         * @property {Uint8Array|null} [dataHash] Header dataHash\n         * @property {Uint8Array|null} [validatorsHash] Header validatorsHash\n         * @property {Uint8Array|null} [nextValidatorsHash] Header nextValidatorsHash\n         * @property {Uint8Array|null} [consensusHash] Header consensusHash\n         * @property {Uint8Array|null} [appHash] Header appHash\n         * @property {Uint8Array|null} [lastResultsHash] Header lastResultsHash\n         * @property {Uint8Array|null} [evidenceHash] Header evidenceHash\n         * @property {Uint8Array|null} [proposerAddress] Header proposerAddress\n         */\n\n        /**\n         * Constructs a new Header.\n         * @memberof tendermint.types\n         * @classdesc Represents a Header.\n         * @implements IHeader\n         * @constructor\n         * @param {tendermint.types.IHeader=} [properties] Properties to set\n         */\n        function Header(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Header version.\n         * @member {tendermint.version.IConsensus|null|undefined} version\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n\n        Header.prototype.version = null;\n        /**\n         * Header chainId.\n         * @member {string} chainId\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.chainId = \"\";\n        /**\n         * Header height.\n         * @member {number|Long} height\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Header time.\n         * @member {google.protobuf.ITimestamp|null|undefined} time\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.time = null;\n        /**\n         * Header lastBlockId.\n         * @member {tendermint.types.IBlockID|null|undefined} lastBlockId\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.lastBlockId = null;\n        /**\n         * Header lastCommitHash.\n         * @member {Uint8Array} lastCommitHash\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.lastCommitHash = $util.newBuffer([]);\n        /**\n         * Header dataHash.\n         * @member {Uint8Array} dataHash\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.dataHash = $util.newBuffer([]);\n        /**\n         * Header validatorsHash.\n         * @member {Uint8Array} validatorsHash\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.validatorsHash = $util.newBuffer([]);\n        /**\n         * Header nextValidatorsHash.\n         * @member {Uint8Array} nextValidatorsHash\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.nextValidatorsHash = $util.newBuffer([]);\n        /**\n         * Header consensusHash.\n         * @member {Uint8Array} consensusHash\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.consensusHash = $util.newBuffer([]);\n        /**\n         * Header appHash.\n         * @member {Uint8Array} appHash\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.appHash = $util.newBuffer([]);\n        /**\n         * Header lastResultsHash.\n         * @member {Uint8Array} lastResultsHash\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.lastResultsHash = $util.newBuffer([]);\n        /**\n         * Header evidenceHash.\n         * @member {Uint8Array} evidenceHash\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.evidenceHash = $util.newBuffer([]);\n        /**\n         * Header proposerAddress.\n         * @member {Uint8Array} proposerAddress\n         * @memberof tendermint.types.Header\n         * @instance\n         */\n\n        Header.prototype.proposerAddress = $util.newBuffer([]);\n        /**\n         * Creates a new Header instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.Header\n         * @static\n         * @param {tendermint.types.IHeader=} [properties] Properties to set\n         * @returns {tendermint.types.Header} Header instance\n         */\n\n        Header.create = function create(properties) {\n          return new Header(properties);\n        };\n        /**\n         * Encodes the specified Header message. Does not implicitly {@link tendermint.types.Header.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.Header\n         * @static\n         * @param {tendermint.types.IHeader} message Header message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Header.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.version != null && Object.hasOwnProperty.call(message, \"version\")) $root.tendermint.version.Consensus.encode(message.version, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.chainId != null && Object.hasOwnProperty.call(message, \"chainId\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).string(message.chainId);\n          if (message.height != null && Object.hasOwnProperty.call(message, \"height\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int64(message.height);\n          if (message.time != null && Object.hasOwnProperty.call(message, \"time\")) $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).fork()).ldelim();\n          if (message.lastBlockId != null && Object.hasOwnProperty.call(message, \"lastBlockId\")) $root.tendermint.types.BlockID.encode(message.lastBlockId, writer.uint32(\n          /* id 5, wireType 2 =*/\n          42).fork()).ldelim();\n          if (message.lastCommitHash != null && Object.hasOwnProperty.call(message, \"lastCommitHash\")) writer.uint32(\n          /* id 6, wireType 2 =*/\n          50).bytes(message.lastCommitHash);\n          if (message.dataHash != null && Object.hasOwnProperty.call(message, \"dataHash\")) writer.uint32(\n          /* id 7, wireType 2 =*/\n          58).bytes(message.dataHash);\n          if (message.validatorsHash != null && Object.hasOwnProperty.call(message, \"validatorsHash\")) writer.uint32(\n          /* id 8, wireType 2 =*/\n          66).bytes(message.validatorsHash);\n          if (message.nextValidatorsHash != null && Object.hasOwnProperty.call(message, \"nextValidatorsHash\")) writer.uint32(\n          /* id 9, wireType 2 =*/\n          74).bytes(message.nextValidatorsHash);\n          if (message.consensusHash != null && Object.hasOwnProperty.call(message, \"consensusHash\")) writer.uint32(\n          /* id 10, wireType 2 =*/\n          82).bytes(message.consensusHash);\n          if (message.appHash != null && Object.hasOwnProperty.call(message, \"appHash\")) writer.uint32(\n          /* id 11, wireType 2 =*/\n          90).bytes(message.appHash);\n          if (message.lastResultsHash != null && Object.hasOwnProperty.call(message, \"lastResultsHash\")) writer.uint32(\n          /* id 12, wireType 2 =*/\n          98).bytes(message.lastResultsHash);\n          if (message.evidenceHash != null && Object.hasOwnProperty.call(message, \"evidenceHash\")) writer.uint32(\n          /* id 13, wireType 2 =*/\n          106).bytes(message.evidenceHash);\n          if (message.proposerAddress != null && Object.hasOwnProperty.call(message, \"proposerAddress\")) writer.uint32(\n          /* id 14, wireType 2 =*/\n          114).bytes(message.proposerAddress);\n          return writer;\n        };\n        /**\n         * Encodes the specified Header message, length delimited. Does not implicitly {@link tendermint.types.Header.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.Header\n         * @static\n         * @param {tendermint.types.IHeader} message Header message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Header.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Header message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.Header\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.Header} Header\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Header.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.Header();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.version = $root.tendermint.version.Consensus.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.chainId = reader.string();\n                break;\n\n              case 3:\n                message.height = reader.int64();\n                break;\n\n              case 4:\n                message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n\n              case 5:\n                message.lastBlockId = $root.tendermint.types.BlockID.decode(reader, reader.uint32());\n                break;\n\n              case 6:\n                message.lastCommitHash = reader.bytes();\n                break;\n\n              case 7:\n                message.dataHash = reader.bytes();\n                break;\n\n              case 8:\n                message.validatorsHash = reader.bytes();\n                break;\n\n              case 9:\n                message.nextValidatorsHash = reader.bytes();\n                break;\n\n              case 10:\n                message.consensusHash = reader.bytes();\n                break;\n\n              case 11:\n                message.appHash = reader.bytes();\n                break;\n\n              case 12:\n                message.lastResultsHash = reader.bytes();\n                break;\n\n              case 13:\n                message.evidenceHash = reader.bytes();\n                break;\n\n              case 14:\n                message.proposerAddress = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Header message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.Header\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.Header} Header\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Header.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Header message.\n         * @function verify\n         * @memberof tendermint.types.Header\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Header.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.version != null && message.hasOwnProperty(\"version\")) {\n            var error = $root.tendermint.version.Consensus.verify(message.version);\n            if (error) return \"version.\" + error;\n          }\n\n          if (message.chainId != null && message.hasOwnProperty(\"chainId\")) if (!$util.isString(message.chainId)) return \"chainId: string expected\";\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))) return \"height: integer|Long expected\";\n\n          if (message.time != null && message.hasOwnProperty(\"time\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.time);\n            if (error) return \"time.\" + error;\n          }\n\n          if (message.lastBlockId != null && message.hasOwnProperty(\"lastBlockId\")) {\n            var error = $root.tendermint.types.BlockID.verify(message.lastBlockId);\n            if (error) return \"lastBlockId.\" + error;\n          }\n\n          if (message.lastCommitHash != null && message.hasOwnProperty(\"lastCommitHash\")) if (!(message.lastCommitHash && typeof message.lastCommitHash.length === \"number\" || $util.isString(message.lastCommitHash))) return \"lastCommitHash: buffer expected\";\n          if (message.dataHash != null && message.hasOwnProperty(\"dataHash\")) if (!(message.dataHash && typeof message.dataHash.length === \"number\" || $util.isString(message.dataHash))) return \"dataHash: buffer expected\";\n          if (message.validatorsHash != null && message.hasOwnProperty(\"validatorsHash\")) if (!(message.validatorsHash && typeof message.validatorsHash.length === \"number\" || $util.isString(message.validatorsHash))) return \"validatorsHash: buffer expected\";\n          if (message.nextValidatorsHash != null && message.hasOwnProperty(\"nextValidatorsHash\")) if (!(message.nextValidatorsHash && typeof message.nextValidatorsHash.length === \"number\" || $util.isString(message.nextValidatorsHash))) return \"nextValidatorsHash: buffer expected\";\n          if (message.consensusHash != null && message.hasOwnProperty(\"consensusHash\")) if (!(message.consensusHash && typeof message.consensusHash.length === \"number\" || $util.isString(message.consensusHash))) return \"consensusHash: buffer expected\";\n          if (message.appHash != null && message.hasOwnProperty(\"appHash\")) if (!(message.appHash && typeof message.appHash.length === \"number\" || $util.isString(message.appHash))) return \"appHash: buffer expected\";\n          if (message.lastResultsHash != null && message.hasOwnProperty(\"lastResultsHash\")) if (!(message.lastResultsHash && typeof message.lastResultsHash.length === \"number\" || $util.isString(message.lastResultsHash))) return \"lastResultsHash: buffer expected\";\n          if (message.evidenceHash != null && message.hasOwnProperty(\"evidenceHash\")) if (!(message.evidenceHash && typeof message.evidenceHash.length === \"number\" || $util.isString(message.evidenceHash))) return \"evidenceHash: buffer expected\";\n          if (message.proposerAddress != null && message.hasOwnProperty(\"proposerAddress\")) if (!(message.proposerAddress && typeof message.proposerAddress.length === \"number\" || $util.isString(message.proposerAddress))) return \"proposerAddress: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates a Header message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.Header\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.Header} Header\n         */\n\n\n        Header.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.Header) return object;\n          var message = new $root.tendermint.types.Header();\n\n          if (object.version != null) {\n            if (typeof object.version !== \"object\") throw TypeError(\".tendermint.types.Header.version: object expected\");\n            message.version = $root.tendermint.version.Consensus.fromObject(object.version);\n          }\n\n          if (object.chainId != null) message.chainId = String(object.chainId);\n          if (object.height != null) if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;else if (typeof object.height === \"string\") message.height = parseInt(object.height, 10);else if (typeof object.height === \"number\") message.height = object.height;else if (typeof object.height === \"object\") message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();\n\n          if (object.time != null) {\n            if (typeof object.time !== \"object\") throw TypeError(\".tendermint.types.Header.time: object expected\");\n            message.time = $root.google.protobuf.Timestamp.fromObject(object.time);\n          }\n\n          if (object.lastBlockId != null) {\n            if (typeof object.lastBlockId !== \"object\") throw TypeError(\".tendermint.types.Header.lastBlockId: object expected\");\n            message.lastBlockId = $root.tendermint.types.BlockID.fromObject(object.lastBlockId);\n          }\n\n          if (object.lastCommitHash != null) if (typeof object.lastCommitHash === \"string\") $util.base64.decode(object.lastCommitHash, message.lastCommitHash = $util.newBuffer($util.base64.length(object.lastCommitHash)), 0);else if (object.lastCommitHash.length) message.lastCommitHash = object.lastCommitHash;\n          if (object.dataHash != null) if (typeof object.dataHash === \"string\") $util.base64.decode(object.dataHash, message.dataHash = $util.newBuffer($util.base64.length(object.dataHash)), 0);else if (object.dataHash.length) message.dataHash = object.dataHash;\n          if (object.validatorsHash != null) if (typeof object.validatorsHash === \"string\") $util.base64.decode(object.validatorsHash, message.validatorsHash = $util.newBuffer($util.base64.length(object.validatorsHash)), 0);else if (object.validatorsHash.length) message.validatorsHash = object.validatorsHash;\n          if (object.nextValidatorsHash != null) if (typeof object.nextValidatorsHash === \"string\") $util.base64.decode(object.nextValidatorsHash, message.nextValidatorsHash = $util.newBuffer($util.base64.length(object.nextValidatorsHash)), 0);else if (object.nextValidatorsHash.length) message.nextValidatorsHash = object.nextValidatorsHash;\n          if (object.consensusHash != null) if (typeof object.consensusHash === \"string\") $util.base64.decode(object.consensusHash, message.consensusHash = $util.newBuffer($util.base64.length(object.consensusHash)), 0);else if (object.consensusHash.length) message.consensusHash = object.consensusHash;\n          if (object.appHash != null) if (typeof object.appHash === \"string\") $util.base64.decode(object.appHash, message.appHash = $util.newBuffer($util.base64.length(object.appHash)), 0);else if (object.appHash.length) message.appHash = object.appHash;\n          if (object.lastResultsHash != null) if (typeof object.lastResultsHash === \"string\") $util.base64.decode(object.lastResultsHash, message.lastResultsHash = $util.newBuffer($util.base64.length(object.lastResultsHash)), 0);else if (object.lastResultsHash.length) message.lastResultsHash = object.lastResultsHash;\n          if (object.evidenceHash != null) if (typeof object.evidenceHash === \"string\") $util.base64.decode(object.evidenceHash, message.evidenceHash = $util.newBuffer($util.base64.length(object.evidenceHash)), 0);else if (object.evidenceHash.length) message.evidenceHash = object.evidenceHash;\n          if (object.proposerAddress != null) if (typeof object.proposerAddress === \"string\") $util.base64.decode(object.proposerAddress, message.proposerAddress = $util.newBuffer($util.base64.length(object.proposerAddress)), 0);else if (object.proposerAddress.length) message.proposerAddress = object.proposerAddress;\n          return message;\n        };\n        /**\n         * Creates a plain object from a Header message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.Header\n         * @static\n         * @param {tendermint.types.Header} message Header\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Header.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.version = null;\n            object.chainId = \"\";\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.height = options.longs === String ? \"0\" : 0;\n\n            object.time = null;\n            object.lastBlockId = null;\n            if (options.bytes === String) object.lastCommitHash = \"\";else {\n              object.lastCommitHash = [];\n              if (options.bytes !== Array) object.lastCommitHash = $util.newBuffer(object.lastCommitHash);\n            }\n            if (options.bytes === String) object.dataHash = \"\";else {\n              object.dataHash = [];\n              if (options.bytes !== Array) object.dataHash = $util.newBuffer(object.dataHash);\n            }\n            if (options.bytes === String) object.validatorsHash = \"\";else {\n              object.validatorsHash = [];\n              if (options.bytes !== Array) object.validatorsHash = $util.newBuffer(object.validatorsHash);\n            }\n            if (options.bytes === String) object.nextValidatorsHash = \"\";else {\n              object.nextValidatorsHash = [];\n              if (options.bytes !== Array) object.nextValidatorsHash = $util.newBuffer(object.nextValidatorsHash);\n            }\n            if (options.bytes === String) object.consensusHash = \"\";else {\n              object.consensusHash = [];\n              if (options.bytes !== Array) object.consensusHash = $util.newBuffer(object.consensusHash);\n            }\n            if (options.bytes === String) object.appHash = \"\";else {\n              object.appHash = [];\n              if (options.bytes !== Array) object.appHash = $util.newBuffer(object.appHash);\n            }\n            if (options.bytes === String) object.lastResultsHash = \"\";else {\n              object.lastResultsHash = [];\n              if (options.bytes !== Array) object.lastResultsHash = $util.newBuffer(object.lastResultsHash);\n            }\n            if (options.bytes === String) object.evidenceHash = \"\";else {\n              object.evidenceHash = [];\n              if (options.bytes !== Array) object.evidenceHash = $util.newBuffer(object.evidenceHash);\n            }\n            if (options.bytes === String) object.proposerAddress = \"\";else {\n              object.proposerAddress = [];\n              if (options.bytes !== Array) object.proposerAddress = $util.newBuffer(object.proposerAddress);\n            }\n          }\n\n          if (message.version != null && message.hasOwnProperty(\"version\")) object.version = $root.tendermint.version.Consensus.toObject(message.version, options);\n          if (message.chainId != null && message.hasOwnProperty(\"chainId\")) object.chainId = message.chainId;\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (typeof message.height === \"number\") object.height = options.longs === String ? String(message.height) : message.height;else object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;\n          if (message.time != null && message.hasOwnProperty(\"time\")) object.time = $root.google.protobuf.Timestamp.toObject(message.time, options);\n          if (message.lastBlockId != null && message.hasOwnProperty(\"lastBlockId\")) object.lastBlockId = $root.tendermint.types.BlockID.toObject(message.lastBlockId, options);\n          if (message.lastCommitHash != null && message.hasOwnProperty(\"lastCommitHash\")) object.lastCommitHash = options.bytes === String ? $util.base64.encode(message.lastCommitHash, 0, message.lastCommitHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.lastCommitHash) : message.lastCommitHash;\n          if (message.dataHash != null && message.hasOwnProperty(\"dataHash\")) object.dataHash = options.bytes === String ? $util.base64.encode(message.dataHash, 0, message.dataHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.dataHash) : message.dataHash;\n          if (message.validatorsHash != null && message.hasOwnProperty(\"validatorsHash\")) object.validatorsHash = options.bytes === String ? $util.base64.encode(message.validatorsHash, 0, message.validatorsHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.validatorsHash) : message.validatorsHash;\n          if (message.nextValidatorsHash != null && message.hasOwnProperty(\"nextValidatorsHash\")) object.nextValidatorsHash = options.bytes === String ? $util.base64.encode(message.nextValidatorsHash, 0, message.nextValidatorsHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.nextValidatorsHash) : message.nextValidatorsHash;\n          if (message.consensusHash != null && message.hasOwnProperty(\"consensusHash\")) object.consensusHash = options.bytes === String ? $util.base64.encode(message.consensusHash, 0, message.consensusHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.consensusHash) : message.consensusHash;\n          if (message.appHash != null && message.hasOwnProperty(\"appHash\")) object.appHash = options.bytes === String ? $util.base64.encode(message.appHash, 0, message.appHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.appHash) : message.appHash;\n          if (message.lastResultsHash != null && message.hasOwnProperty(\"lastResultsHash\")) object.lastResultsHash = options.bytes === String ? $util.base64.encode(message.lastResultsHash, 0, message.lastResultsHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.lastResultsHash) : message.lastResultsHash;\n          if (message.evidenceHash != null && message.hasOwnProperty(\"evidenceHash\")) object.evidenceHash = options.bytes === String ? $util.base64.encode(message.evidenceHash, 0, message.evidenceHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.evidenceHash) : message.evidenceHash;\n          if (message.proposerAddress != null && message.hasOwnProperty(\"proposerAddress\")) object.proposerAddress = options.bytes === String ? $util.base64.encode(message.proposerAddress, 0, message.proposerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposerAddress) : message.proposerAddress;\n          return object;\n        };\n        /**\n         * Converts this Header to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.Header\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Header.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Header;\n      }();\n\n      types.Data = function () {\n        /**\n         * Properties of a Data.\n         * @memberof tendermint.types\n         * @interface IData\n         * @property {Array.<Uint8Array>|null} [txs] Data txs\n         */\n\n        /**\n         * Constructs a new Data.\n         * @memberof tendermint.types\n         * @classdesc Represents a Data.\n         * @implements IData\n         * @constructor\n         * @param {tendermint.types.IData=} [properties] Properties to set\n         */\n        function Data(properties) {\n          this.txs = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Data txs.\n         * @member {Array.<Uint8Array>} txs\n         * @memberof tendermint.types.Data\n         * @instance\n         */\n\n\n        Data.prototype.txs = $util.emptyArray;\n        /**\n         * Creates a new Data instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.Data\n         * @static\n         * @param {tendermint.types.IData=} [properties] Properties to set\n         * @returns {tendermint.types.Data} Data instance\n         */\n\n        Data.create = function create(properties) {\n          return new Data(properties);\n        };\n        /**\n         * Encodes the specified Data message. Does not implicitly {@link tendermint.types.Data.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.Data\n         * @static\n         * @param {tendermint.types.IData} message Data message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Data.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.txs != null && message.txs.length) for (var i = 0; i < message.txs.length; ++i) {\n            writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).bytes(message.txs[i]);\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified Data message, length delimited. Does not implicitly {@link tendermint.types.Data.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.Data\n         * @static\n         * @param {tendermint.types.IData} message Data message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Data.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Data message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.Data\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.Data} Data\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Data.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.Data();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.txs && message.txs.length)) message.txs = [];\n                message.txs.push(reader.bytes());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Data message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.Data\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.Data} Data\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Data.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Data message.\n         * @function verify\n         * @memberof tendermint.types.Data\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Data.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.txs != null && message.hasOwnProperty(\"txs\")) {\n            if (!Array.isArray(message.txs)) return \"txs: array expected\";\n\n            for (var i = 0; i < message.txs.length; ++i) {\n              if (!(message.txs[i] && typeof message.txs[i].length === \"number\" || $util.isString(message.txs[i]))) return \"txs: buffer[] expected\";\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a Data message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.Data\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.Data} Data\n         */\n\n\n        Data.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.Data) return object;\n          var message = new $root.tendermint.types.Data();\n\n          if (object.txs) {\n            if (!Array.isArray(object.txs)) throw TypeError(\".tendermint.types.Data.txs: array expected\");\n            message.txs = [];\n\n            for (var i = 0; i < object.txs.length; ++i) {\n              if (typeof object.txs[i] === \"string\") $util.base64.decode(object.txs[i], message.txs[i] = $util.newBuffer($util.base64.length(object.txs[i])), 0);else if (object.txs[i].length) message.txs[i] = object.txs[i];\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a Data message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.Data\n         * @static\n         * @param {tendermint.types.Data} message Data\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Data.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.txs = [];\n\n          if (message.txs && message.txs.length) {\n            object.txs = [];\n\n            for (var j = 0; j < message.txs.length; ++j) {\n              object.txs[j] = options.bytes === String ? $util.base64.encode(message.txs[j], 0, message.txs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.txs[j]) : message.txs[j];\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this Data to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.Data\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Data.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Data;\n      }();\n\n      types.Vote = function () {\n        /**\n         * Properties of a Vote.\n         * @memberof tendermint.types\n         * @interface IVote\n         * @property {tendermint.types.SignedMsgType|null} [type] Vote type\n         * @property {number|Long|null} [height] Vote height\n         * @property {number|null} [round] Vote round\n         * @property {tendermint.types.IBlockID|null} [blockId] Vote blockId\n         * @property {google.protobuf.ITimestamp|null} [timestamp] Vote timestamp\n         * @property {Uint8Array|null} [validatorAddress] Vote validatorAddress\n         * @property {number|null} [validatorIndex] Vote validatorIndex\n         * @property {Uint8Array|null} [signature] Vote signature\n         */\n\n        /**\n         * Constructs a new Vote.\n         * @memberof tendermint.types\n         * @classdesc Represents a Vote.\n         * @implements IVote\n         * @constructor\n         * @param {tendermint.types.IVote=} [properties] Properties to set\n         */\n        function Vote(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Vote type.\n         * @member {tendermint.types.SignedMsgType} type\n         * @memberof tendermint.types.Vote\n         * @instance\n         */\n\n\n        Vote.prototype.type = 0;\n        /**\n         * Vote height.\n         * @member {number|Long} height\n         * @memberof tendermint.types.Vote\n         * @instance\n         */\n\n        Vote.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Vote round.\n         * @member {number} round\n         * @memberof tendermint.types.Vote\n         * @instance\n         */\n\n        Vote.prototype.round = 0;\n        /**\n         * Vote blockId.\n         * @member {tendermint.types.IBlockID|null|undefined} blockId\n         * @memberof tendermint.types.Vote\n         * @instance\n         */\n\n        Vote.prototype.blockId = null;\n        /**\n         * Vote timestamp.\n         * @member {google.protobuf.ITimestamp|null|undefined} timestamp\n         * @memberof tendermint.types.Vote\n         * @instance\n         */\n\n        Vote.prototype.timestamp = null;\n        /**\n         * Vote validatorAddress.\n         * @member {Uint8Array} validatorAddress\n         * @memberof tendermint.types.Vote\n         * @instance\n         */\n\n        Vote.prototype.validatorAddress = $util.newBuffer([]);\n        /**\n         * Vote validatorIndex.\n         * @member {number} validatorIndex\n         * @memberof tendermint.types.Vote\n         * @instance\n         */\n\n        Vote.prototype.validatorIndex = 0;\n        /**\n         * Vote signature.\n         * @member {Uint8Array} signature\n         * @memberof tendermint.types.Vote\n         * @instance\n         */\n\n        Vote.prototype.signature = $util.newBuffer([]);\n        /**\n         * Creates a new Vote instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.Vote\n         * @static\n         * @param {tendermint.types.IVote=} [properties] Properties to set\n         * @returns {tendermint.types.Vote} Vote instance\n         */\n\n        Vote.create = function create(properties) {\n          return new Vote(properties);\n        };\n        /**\n         * Encodes the specified Vote message. Does not implicitly {@link tendermint.types.Vote.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.Vote\n         * @static\n         * @param {tendermint.types.IVote} message Vote message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Vote.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int32(message.type);\n          if (message.height != null && Object.hasOwnProperty.call(message, \"height\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int64(message.height);\n          if (message.round != null && Object.hasOwnProperty.call(message, \"round\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int32(message.round);\n          if (message.blockId != null && Object.hasOwnProperty.call(message, \"blockId\")) $root.tendermint.types.BlockID.encode(message.blockId, writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).fork()).ldelim();\n          if (message.timestamp != null && Object.hasOwnProperty.call(message, \"timestamp\")) $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(\n          /* id 5, wireType 2 =*/\n          42).fork()).ldelim();\n          if (message.validatorAddress != null && Object.hasOwnProperty.call(message, \"validatorAddress\")) writer.uint32(\n          /* id 6, wireType 2 =*/\n          50).bytes(message.validatorAddress);\n          if (message.validatorIndex != null && Object.hasOwnProperty.call(message, \"validatorIndex\")) writer.uint32(\n          /* id 7, wireType 0 =*/\n          56).int32(message.validatorIndex);\n          if (message.signature != null && Object.hasOwnProperty.call(message, \"signature\")) writer.uint32(\n          /* id 8, wireType 2 =*/\n          66).bytes(message.signature);\n          return writer;\n        };\n        /**\n         * Encodes the specified Vote message, length delimited. Does not implicitly {@link tendermint.types.Vote.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.Vote\n         * @static\n         * @param {tendermint.types.IVote} message Vote message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Vote.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Vote message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.Vote\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.Vote} Vote\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Vote.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.Vote();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.type = reader.int32();\n                break;\n\n              case 2:\n                message.height = reader.int64();\n                break;\n\n              case 3:\n                message.round = reader.int32();\n                break;\n\n              case 4:\n                message.blockId = $root.tendermint.types.BlockID.decode(reader, reader.uint32());\n                break;\n\n              case 5:\n                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n\n              case 6:\n                message.validatorAddress = reader.bytes();\n                break;\n\n              case 7:\n                message.validatorIndex = reader.int32();\n                break;\n\n              case 8:\n                message.signature = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Vote message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.Vote\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.Vote} Vote\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Vote.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Vote message.\n         * @function verify\n         * @memberof tendermint.types.Vote\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Vote.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.type != null && message.hasOwnProperty(\"type\")) switch (message.type) {\n            default:\n              return \"type: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 32:\n              break;\n          }\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))) return \"height: integer|Long expected\";\n          if (message.round != null && message.hasOwnProperty(\"round\")) if (!$util.isInteger(message.round)) return \"round: integer expected\";\n\n          if (message.blockId != null && message.hasOwnProperty(\"blockId\")) {\n            var error = $root.tendermint.types.BlockID.verify(message.blockId);\n            if (error) return \"blockId.\" + error;\n          }\n\n          if (message.timestamp != null && message.hasOwnProperty(\"timestamp\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);\n            if (error) return \"timestamp.\" + error;\n          }\n\n          if (message.validatorAddress != null && message.hasOwnProperty(\"validatorAddress\")) if (!(message.validatorAddress && typeof message.validatorAddress.length === \"number\" || $util.isString(message.validatorAddress))) return \"validatorAddress: buffer expected\";\n          if (message.validatorIndex != null && message.hasOwnProperty(\"validatorIndex\")) if (!$util.isInteger(message.validatorIndex)) return \"validatorIndex: integer expected\";\n          if (message.signature != null && message.hasOwnProperty(\"signature\")) if (!(message.signature && typeof message.signature.length === \"number\" || $util.isString(message.signature))) return \"signature: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates a Vote message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.Vote\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.Vote} Vote\n         */\n\n\n        Vote.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.Vote) return object;\n          var message = new $root.tendermint.types.Vote();\n\n          switch (object.type) {\n            case \"SIGNED_MSG_TYPE_UNKNOWN\":\n            case 0:\n              message.type = 0;\n              break;\n\n            case \"SIGNED_MSG_TYPE_PREVOTE\":\n            case 1:\n              message.type = 1;\n              break;\n\n            case \"SIGNED_MSG_TYPE_PRECOMMIT\":\n            case 2:\n              message.type = 2;\n              break;\n\n            case \"SIGNED_MSG_TYPE_PROPOSAL\":\n            case 32:\n              message.type = 32;\n              break;\n          }\n\n          if (object.height != null) if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;else if (typeof object.height === \"string\") message.height = parseInt(object.height, 10);else if (typeof object.height === \"number\") message.height = object.height;else if (typeof object.height === \"object\") message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();\n          if (object.round != null) message.round = object.round | 0;\n\n          if (object.blockId != null) {\n            if (typeof object.blockId !== \"object\") throw TypeError(\".tendermint.types.Vote.blockId: object expected\");\n            message.blockId = $root.tendermint.types.BlockID.fromObject(object.blockId);\n          }\n\n          if (object.timestamp != null) {\n            if (typeof object.timestamp !== \"object\") throw TypeError(\".tendermint.types.Vote.timestamp: object expected\");\n            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);\n          }\n\n          if (object.validatorAddress != null) if (typeof object.validatorAddress === \"string\") $util.base64.decode(object.validatorAddress, message.validatorAddress = $util.newBuffer($util.base64.length(object.validatorAddress)), 0);else if (object.validatorAddress.length) message.validatorAddress = object.validatorAddress;\n          if (object.validatorIndex != null) message.validatorIndex = object.validatorIndex | 0;\n          if (object.signature != null) if (typeof object.signature === \"string\") $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);else if (object.signature.length) message.signature = object.signature;\n          return message;\n        };\n        /**\n         * Creates a plain object from a Vote message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.Vote\n         * @static\n         * @param {tendermint.types.Vote} message Vote\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Vote.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.type = options.enums === String ? \"SIGNED_MSG_TYPE_UNKNOWN\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.height = options.longs === String ? \"0\" : 0;\n\n            object.round = 0;\n            object.blockId = null;\n            object.timestamp = null;\n            if (options.bytes === String) object.validatorAddress = \"\";else {\n              object.validatorAddress = [];\n              if (options.bytes !== Array) object.validatorAddress = $util.newBuffer(object.validatorAddress);\n            }\n            object.validatorIndex = 0;\n            if (options.bytes === String) object.signature = \"\";else {\n              object.signature = [];\n              if (options.bytes !== Array) object.signature = $util.newBuffer(object.signature);\n            }\n          }\n\n          if (message.type != null && message.hasOwnProperty(\"type\")) object.type = options.enums === String ? $root.tendermint.types.SignedMsgType[message.type] : message.type;\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (typeof message.height === \"number\") object.height = options.longs === String ? String(message.height) : message.height;else object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;\n          if (message.round != null && message.hasOwnProperty(\"round\")) object.round = message.round;\n          if (message.blockId != null && message.hasOwnProperty(\"blockId\")) object.blockId = $root.tendermint.types.BlockID.toObject(message.blockId, options);\n          if (message.timestamp != null && message.hasOwnProperty(\"timestamp\")) object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);\n          if (message.validatorAddress != null && message.hasOwnProperty(\"validatorAddress\")) object.validatorAddress = options.bytes === String ? $util.base64.encode(message.validatorAddress, 0, message.validatorAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.validatorAddress) : message.validatorAddress;\n          if (message.validatorIndex != null && message.hasOwnProperty(\"validatorIndex\")) object.validatorIndex = message.validatorIndex;\n          if (message.signature != null && message.hasOwnProperty(\"signature\")) object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;\n          return object;\n        };\n        /**\n         * Converts this Vote to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.Vote\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Vote.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Vote;\n      }();\n\n      types.Commit = function () {\n        /**\n         * Properties of a Commit.\n         * @memberof tendermint.types\n         * @interface ICommit\n         * @property {number|Long|null} [height] Commit height\n         * @property {number|null} [round] Commit round\n         * @property {tendermint.types.IBlockID|null} [blockId] Commit blockId\n         * @property {Array.<tendermint.types.ICommitSig>|null} [signatures] Commit signatures\n         */\n\n        /**\n         * Constructs a new Commit.\n         * @memberof tendermint.types\n         * @classdesc Represents a Commit.\n         * @implements ICommit\n         * @constructor\n         * @param {tendermint.types.ICommit=} [properties] Properties to set\n         */\n        function Commit(properties) {\n          this.signatures = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Commit height.\n         * @member {number|Long} height\n         * @memberof tendermint.types.Commit\n         * @instance\n         */\n\n\n        Commit.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Commit round.\n         * @member {number} round\n         * @memberof tendermint.types.Commit\n         * @instance\n         */\n\n        Commit.prototype.round = 0;\n        /**\n         * Commit blockId.\n         * @member {tendermint.types.IBlockID|null|undefined} blockId\n         * @memberof tendermint.types.Commit\n         * @instance\n         */\n\n        Commit.prototype.blockId = null;\n        /**\n         * Commit signatures.\n         * @member {Array.<tendermint.types.ICommitSig>} signatures\n         * @memberof tendermint.types.Commit\n         * @instance\n         */\n\n        Commit.prototype.signatures = $util.emptyArray;\n        /**\n         * Creates a new Commit instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.Commit\n         * @static\n         * @param {tendermint.types.ICommit=} [properties] Properties to set\n         * @returns {tendermint.types.Commit} Commit instance\n         */\n\n        Commit.create = function create(properties) {\n          return new Commit(properties);\n        };\n        /**\n         * Encodes the specified Commit message. Does not implicitly {@link tendermint.types.Commit.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.Commit\n         * @static\n         * @param {tendermint.types.ICommit} message Commit message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Commit.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.height != null && Object.hasOwnProperty.call(message, \"height\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int64(message.height);\n          if (message.round != null && Object.hasOwnProperty.call(message, \"round\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.round);\n          if (message.blockId != null && Object.hasOwnProperty.call(message, \"blockId\")) $root.tendermint.types.BlockID.encode(message.blockId, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          if (message.signatures != null && message.signatures.length) for (var i = 0; i < message.signatures.length; ++i) {\n            $root.tendermint.types.CommitSig.encode(message.signatures[i], writer.uint32(\n            /* id 4, wireType 2 =*/\n            34).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified Commit message, length delimited. Does not implicitly {@link tendermint.types.Commit.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.Commit\n         * @static\n         * @param {tendermint.types.ICommit} message Commit message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Commit.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Commit message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.Commit\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.Commit} Commit\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Commit.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.Commit();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.height = reader.int64();\n                break;\n\n              case 2:\n                message.round = reader.int32();\n                break;\n\n              case 3:\n                message.blockId = $root.tendermint.types.BlockID.decode(reader, reader.uint32());\n                break;\n\n              case 4:\n                if (!(message.signatures && message.signatures.length)) message.signatures = [];\n                message.signatures.push($root.tendermint.types.CommitSig.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Commit message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.Commit\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.Commit} Commit\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Commit.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Commit message.\n         * @function verify\n         * @memberof tendermint.types.Commit\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Commit.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))) return \"height: integer|Long expected\";\n          if (message.round != null && message.hasOwnProperty(\"round\")) if (!$util.isInteger(message.round)) return \"round: integer expected\";\n\n          if (message.blockId != null && message.hasOwnProperty(\"blockId\")) {\n            var error = $root.tendermint.types.BlockID.verify(message.blockId);\n            if (error) return \"blockId.\" + error;\n          }\n\n          if (message.signatures != null && message.hasOwnProperty(\"signatures\")) {\n            if (!Array.isArray(message.signatures)) return \"signatures: array expected\";\n\n            for (var i = 0; i < message.signatures.length; ++i) {\n              var error = $root.tendermint.types.CommitSig.verify(message.signatures[i]);\n              if (error) return \"signatures.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a Commit message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.Commit\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.Commit} Commit\n         */\n\n\n        Commit.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.Commit) return object;\n          var message = new $root.tendermint.types.Commit();\n          if (object.height != null) if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;else if (typeof object.height === \"string\") message.height = parseInt(object.height, 10);else if (typeof object.height === \"number\") message.height = object.height;else if (typeof object.height === \"object\") message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();\n          if (object.round != null) message.round = object.round | 0;\n\n          if (object.blockId != null) {\n            if (typeof object.blockId !== \"object\") throw TypeError(\".tendermint.types.Commit.blockId: object expected\");\n            message.blockId = $root.tendermint.types.BlockID.fromObject(object.blockId);\n          }\n\n          if (object.signatures) {\n            if (!Array.isArray(object.signatures)) throw TypeError(\".tendermint.types.Commit.signatures: array expected\");\n            message.signatures = [];\n\n            for (var i = 0; i < object.signatures.length; ++i) {\n              if (typeof object.signatures[i] !== \"object\") throw TypeError(\".tendermint.types.Commit.signatures: object expected\");\n              message.signatures[i] = $root.tendermint.types.CommitSig.fromObject(object.signatures[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a Commit message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.Commit\n         * @static\n         * @param {tendermint.types.Commit} message Commit\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Commit.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.signatures = [];\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.height = options.longs === String ? \"0\" : 0;\n\n            object.round = 0;\n            object.blockId = null;\n          }\n\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (typeof message.height === \"number\") object.height = options.longs === String ? String(message.height) : message.height;else object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;\n          if (message.round != null && message.hasOwnProperty(\"round\")) object.round = message.round;\n          if (message.blockId != null && message.hasOwnProperty(\"blockId\")) object.blockId = $root.tendermint.types.BlockID.toObject(message.blockId, options);\n\n          if (message.signatures && message.signatures.length) {\n            object.signatures = [];\n\n            for (var j = 0; j < message.signatures.length; ++j) {\n              object.signatures[j] = $root.tendermint.types.CommitSig.toObject(message.signatures[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this Commit to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.Commit\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Commit.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Commit;\n      }();\n\n      types.CommitSig = function () {\n        /**\n         * Properties of a CommitSig.\n         * @memberof tendermint.types\n         * @interface ICommitSig\n         * @property {tendermint.types.BlockIDFlag|null} [blockIdFlag] CommitSig blockIdFlag\n         * @property {Uint8Array|null} [validatorAddress] CommitSig validatorAddress\n         * @property {google.protobuf.ITimestamp|null} [timestamp] CommitSig timestamp\n         * @property {Uint8Array|null} [signature] CommitSig signature\n         */\n\n        /**\n         * Constructs a new CommitSig.\n         * @memberof tendermint.types\n         * @classdesc Represents a CommitSig.\n         * @implements ICommitSig\n         * @constructor\n         * @param {tendermint.types.ICommitSig=} [properties] Properties to set\n         */\n        function CommitSig(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * CommitSig blockIdFlag.\n         * @member {tendermint.types.BlockIDFlag} blockIdFlag\n         * @memberof tendermint.types.CommitSig\n         * @instance\n         */\n\n\n        CommitSig.prototype.blockIdFlag = 0;\n        /**\n         * CommitSig validatorAddress.\n         * @member {Uint8Array} validatorAddress\n         * @memberof tendermint.types.CommitSig\n         * @instance\n         */\n\n        CommitSig.prototype.validatorAddress = $util.newBuffer([]);\n        /**\n         * CommitSig timestamp.\n         * @member {google.protobuf.ITimestamp|null|undefined} timestamp\n         * @memberof tendermint.types.CommitSig\n         * @instance\n         */\n\n        CommitSig.prototype.timestamp = null;\n        /**\n         * CommitSig signature.\n         * @member {Uint8Array} signature\n         * @memberof tendermint.types.CommitSig\n         * @instance\n         */\n\n        CommitSig.prototype.signature = $util.newBuffer([]);\n        /**\n         * Creates a new CommitSig instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.CommitSig\n         * @static\n         * @param {tendermint.types.ICommitSig=} [properties] Properties to set\n         * @returns {tendermint.types.CommitSig} CommitSig instance\n         */\n\n        CommitSig.create = function create(properties) {\n          return new CommitSig(properties);\n        };\n        /**\n         * Encodes the specified CommitSig message. Does not implicitly {@link tendermint.types.CommitSig.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.CommitSig\n         * @static\n         * @param {tendermint.types.ICommitSig} message CommitSig message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        CommitSig.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.blockIdFlag != null && Object.hasOwnProperty.call(message, \"blockIdFlag\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int32(message.blockIdFlag);\n          if (message.validatorAddress != null && Object.hasOwnProperty.call(message, \"validatorAddress\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.validatorAddress);\n          if (message.timestamp != null && Object.hasOwnProperty.call(message, \"timestamp\")) $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          if (message.signature != null && Object.hasOwnProperty.call(message, \"signature\")) writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).bytes(message.signature);\n          return writer;\n        };\n        /**\n         * Encodes the specified CommitSig message, length delimited. Does not implicitly {@link tendermint.types.CommitSig.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.CommitSig\n         * @static\n         * @param {tendermint.types.ICommitSig} message CommitSig message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        CommitSig.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a CommitSig message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.CommitSig\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.CommitSig} CommitSig\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        CommitSig.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.CommitSig();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.blockIdFlag = reader.int32();\n                break;\n\n              case 2:\n                message.validatorAddress = reader.bytes();\n                break;\n\n              case 3:\n                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n\n              case 4:\n                message.signature = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a CommitSig message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.CommitSig\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.CommitSig} CommitSig\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        CommitSig.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a CommitSig message.\n         * @function verify\n         * @memberof tendermint.types.CommitSig\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        CommitSig.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.blockIdFlag != null && message.hasOwnProperty(\"blockIdFlag\")) switch (message.blockIdFlag) {\n            default:\n              return \"blockIdFlag: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n              break;\n          }\n          if (message.validatorAddress != null && message.hasOwnProperty(\"validatorAddress\")) if (!(message.validatorAddress && typeof message.validatorAddress.length === \"number\" || $util.isString(message.validatorAddress))) return \"validatorAddress: buffer expected\";\n\n          if (message.timestamp != null && message.hasOwnProperty(\"timestamp\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);\n            if (error) return \"timestamp.\" + error;\n          }\n\n          if (message.signature != null && message.hasOwnProperty(\"signature\")) if (!(message.signature && typeof message.signature.length === \"number\" || $util.isString(message.signature))) return \"signature: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates a CommitSig message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.CommitSig\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.CommitSig} CommitSig\n         */\n\n\n        CommitSig.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.CommitSig) return object;\n          var message = new $root.tendermint.types.CommitSig();\n\n          switch (object.blockIdFlag) {\n            case \"BLOCK_ID_FLAG_UNKNOWN\":\n            case 0:\n              message.blockIdFlag = 0;\n              break;\n\n            case \"BLOCK_ID_FLAG_ABSENT\":\n            case 1:\n              message.blockIdFlag = 1;\n              break;\n\n            case \"BLOCK_ID_FLAG_COMMIT\":\n            case 2:\n              message.blockIdFlag = 2;\n              break;\n\n            case \"BLOCK_ID_FLAG_NIL\":\n            case 3:\n              message.blockIdFlag = 3;\n              break;\n          }\n\n          if (object.validatorAddress != null) if (typeof object.validatorAddress === \"string\") $util.base64.decode(object.validatorAddress, message.validatorAddress = $util.newBuffer($util.base64.length(object.validatorAddress)), 0);else if (object.validatorAddress.length) message.validatorAddress = object.validatorAddress;\n\n          if (object.timestamp != null) {\n            if (typeof object.timestamp !== \"object\") throw TypeError(\".tendermint.types.CommitSig.timestamp: object expected\");\n            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);\n          }\n\n          if (object.signature != null) if (typeof object.signature === \"string\") $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);else if (object.signature.length) message.signature = object.signature;\n          return message;\n        };\n        /**\n         * Creates a plain object from a CommitSig message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.CommitSig\n         * @static\n         * @param {tendermint.types.CommitSig} message CommitSig\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        CommitSig.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.blockIdFlag = options.enums === String ? \"BLOCK_ID_FLAG_UNKNOWN\" : 0;\n            if (options.bytes === String) object.validatorAddress = \"\";else {\n              object.validatorAddress = [];\n              if (options.bytes !== Array) object.validatorAddress = $util.newBuffer(object.validatorAddress);\n            }\n            object.timestamp = null;\n            if (options.bytes === String) object.signature = \"\";else {\n              object.signature = [];\n              if (options.bytes !== Array) object.signature = $util.newBuffer(object.signature);\n            }\n          }\n\n          if (message.blockIdFlag != null && message.hasOwnProperty(\"blockIdFlag\")) object.blockIdFlag = options.enums === String ? $root.tendermint.types.BlockIDFlag[message.blockIdFlag] : message.blockIdFlag;\n          if (message.validatorAddress != null && message.hasOwnProperty(\"validatorAddress\")) object.validatorAddress = options.bytes === String ? $util.base64.encode(message.validatorAddress, 0, message.validatorAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.validatorAddress) : message.validatorAddress;\n          if (message.timestamp != null && message.hasOwnProperty(\"timestamp\")) object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);\n          if (message.signature != null && message.hasOwnProperty(\"signature\")) object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;\n          return object;\n        };\n        /**\n         * Converts this CommitSig to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.CommitSig\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        CommitSig.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CommitSig;\n      }();\n\n      types.Proposal = function () {\n        /**\n         * Properties of a Proposal.\n         * @memberof tendermint.types\n         * @interface IProposal\n         * @property {tendermint.types.SignedMsgType|null} [type] Proposal type\n         * @property {number|Long|null} [height] Proposal height\n         * @property {number|null} [round] Proposal round\n         * @property {number|null} [polRound] Proposal polRound\n         * @property {tendermint.types.IBlockID|null} [blockId] Proposal blockId\n         * @property {google.protobuf.ITimestamp|null} [timestamp] Proposal timestamp\n         * @property {Uint8Array|null} [signature] Proposal signature\n         */\n\n        /**\n         * Constructs a new Proposal.\n         * @memberof tendermint.types\n         * @classdesc Represents a Proposal.\n         * @implements IProposal\n         * @constructor\n         * @param {tendermint.types.IProposal=} [properties] Properties to set\n         */\n        function Proposal(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Proposal type.\n         * @member {tendermint.types.SignedMsgType} type\n         * @memberof tendermint.types.Proposal\n         * @instance\n         */\n\n\n        Proposal.prototype.type = 0;\n        /**\n         * Proposal height.\n         * @member {number|Long} height\n         * @memberof tendermint.types.Proposal\n         * @instance\n         */\n\n        Proposal.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Proposal round.\n         * @member {number} round\n         * @memberof tendermint.types.Proposal\n         * @instance\n         */\n\n        Proposal.prototype.round = 0;\n        /**\n         * Proposal polRound.\n         * @member {number} polRound\n         * @memberof tendermint.types.Proposal\n         * @instance\n         */\n\n        Proposal.prototype.polRound = 0;\n        /**\n         * Proposal blockId.\n         * @member {tendermint.types.IBlockID|null|undefined} blockId\n         * @memberof tendermint.types.Proposal\n         * @instance\n         */\n\n        Proposal.prototype.blockId = null;\n        /**\n         * Proposal timestamp.\n         * @member {google.protobuf.ITimestamp|null|undefined} timestamp\n         * @memberof tendermint.types.Proposal\n         * @instance\n         */\n\n        Proposal.prototype.timestamp = null;\n        /**\n         * Proposal signature.\n         * @member {Uint8Array} signature\n         * @memberof tendermint.types.Proposal\n         * @instance\n         */\n\n        Proposal.prototype.signature = $util.newBuffer([]);\n        /**\n         * Creates a new Proposal instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.Proposal\n         * @static\n         * @param {tendermint.types.IProposal=} [properties] Properties to set\n         * @returns {tendermint.types.Proposal} Proposal instance\n         */\n\n        Proposal.create = function create(properties) {\n          return new Proposal(properties);\n        };\n        /**\n         * Encodes the specified Proposal message. Does not implicitly {@link tendermint.types.Proposal.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.Proposal\n         * @static\n         * @param {tendermint.types.IProposal} message Proposal message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Proposal.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int32(message.type);\n          if (message.height != null && Object.hasOwnProperty.call(message, \"height\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int64(message.height);\n          if (message.round != null && Object.hasOwnProperty.call(message, \"round\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int32(message.round);\n          if (message.polRound != null && Object.hasOwnProperty.call(message, \"polRound\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).int32(message.polRound);\n          if (message.blockId != null && Object.hasOwnProperty.call(message, \"blockId\")) $root.tendermint.types.BlockID.encode(message.blockId, writer.uint32(\n          /* id 5, wireType 2 =*/\n          42).fork()).ldelim();\n          if (message.timestamp != null && Object.hasOwnProperty.call(message, \"timestamp\")) $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(\n          /* id 6, wireType 2 =*/\n          50).fork()).ldelim();\n          if (message.signature != null && Object.hasOwnProperty.call(message, \"signature\")) writer.uint32(\n          /* id 7, wireType 2 =*/\n          58).bytes(message.signature);\n          return writer;\n        };\n        /**\n         * Encodes the specified Proposal message, length delimited. Does not implicitly {@link tendermint.types.Proposal.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.Proposal\n         * @static\n         * @param {tendermint.types.IProposal} message Proposal message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Proposal.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Proposal message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.Proposal\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.Proposal} Proposal\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Proposal.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.Proposal();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.type = reader.int32();\n                break;\n\n              case 2:\n                message.height = reader.int64();\n                break;\n\n              case 3:\n                message.round = reader.int32();\n                break;\n\n              case 4:\n                message.polRound = reader.int32();\n                break;\n\n              case 5:\n                message.blockId = $root.tendermint.types.BlockID.decode(reader, reader.uint32());\n                break;\n\n              case 6:\n                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n\n              case 7:\n                message.signature = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Proposal message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.Proposal\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.Proposal} Proposal\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Proposal.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Proposal message.\n         * @function verify\n         * @memberof tendermint.types.Proposal\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Proposal.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.type != null && message.hasOwnProperty(\"type\")) switch (message.type) {\n            default:\n              return \"type: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 32:\n              break;\n          }\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))) return \"height: integer|Long expected\";\n          if (message.round != null && message.hasOwnProperty(\"round\")) if (!$util.isInteger(message.round)) return \"round: integer expected\";\n          if (message.polRound != null && message.hasOwnProperty(\"polRound\")) if (!$util.isInteger(message.polRound)) return \"polRound: integer expected\";\n\n          if (message.blockId != null && message.hasOwnProperty(\"blockId\")) {\n            var error = $root.tendermint.types.BlockID.verify(message.blockId);\n            if (error) return \"blockId.\" + error;\n          }\n\n          if (message.timestamp != null && message.hasOwnProperty(\"timestamp\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.timestamp);\n            if (error) return \"timestamp.\" + error;\n          }\n\n          if (message.signature != null && message.hasOwnProperty(\"signature\")) if (!(message.signature && typeof message.signature.length === \"number\" || $util.isString(message.signature))) return \"signature: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates a Proposal message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.Proposal\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.Proposal} Proposal\n         */\n\n\n        Proposal.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.Proposal) return object;\n          var message = new $root.tendermint.types.Proposal();\n\n          switch (object.type) {\n            case \"SIGNED_MSG_TYPE_UNKNOWN\":\n            case 0:\n              message.type = 0;\n              break;\n\n            case \"SIGNED_MSG_TYPE_PREVOTE\":\n            case 1:\n              message.type = 1;\n              break;\n\n            case \"SIGNED_MSG_TYPE_PRECOMMIT\":\n            case 2:\n              message.type = 2;\n              break;\n\n            case \"SIGNED_MSG_TYPE_PROPOSAL\":\n            case 32:\n              message.type = 32;\n              break;\n          }\n\n          if (object.height != null) if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;else if (typeof object.height === \"string\") message.height = parseInt(object.height, 10);else if (typeof object.height === \"number\") message.height = object.height;else if (typeof object.height === \"object\") message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();\n          if (object.round != null) message.round = object.round | 0;\n          if (object.polRound != null) message.polRound = object.polRound | 0;\n\n          if (object.blockId != null) {\n            if (typeof object.blockId !== \"object\") throw TypeError(\".tendermint.types.Proposal.blockId: object expected\");\n            message.blockId = $root.tendermint.types.BlockID.fromObject(object.blockId);\n          }\n\n          if (object.timestamp != null) {\n            if (typeof object.timestamp !== \"object\") throw TypeError(\".tendermint.types.Proposal.timestamp: object expected\");\n            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);\n          }\n\n          if (object.signature != null) if (typeof object.signature === \"string\") $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);else if (object.signature.length) message.signature = object.signature;\n          return message;\n        };\n        /**\n         * Creates a plain object from a Proposal message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.Proposal\n         * @static\n         * @param {tendermint.types.Proposal} message Proposal\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Proposal.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.type = options.enums === String ? \"SIGNED_MSG_TYPE_UNKNOWN\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.height = options.longs === String ? \"0\" : 0;\n\n            object.round = 0;\n            object.polRound = 0;\n            object.blockId = null;\n            object.timestamp = null;\n            if (options.bytes === String) object.signature = \"\";else {\n              object.signature = [];\n              if (options.bytes !== Array) object.signature = $util.newBuffer(object.signature);\n            }\n          }\n\n          if (message.type != null && message.hasOwnProperty(\"type\")) object.type = options.enums === String ? $root.tendermint.types.SignedMsgType[message.type] : message.type;\n          if (message.height != null && message.hasOwnProperty(\"height\")) if (typeof message.height === \"number\") object.height = options.longs === String ? String(message.height) : message.height;else object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;\n          if (message.round != null && message.hasOwnProperty(\"round\")) object.round = message.round;\n          if (message.polRound != null && message.hasOwnProperty(\"polRound\")) object.polRound = message.polRound;\n          if (message.blockId != null && message.hasOwnProperty(\"blockId\")) object.blockId = $root.tendermint.types.BlockID.toObject(message.blockId, options);\n          if (message.timestamp != null && message.hasOwnProperty(\"timestamp\")) object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);\n          if (message.signature != null && message.hasOwnProperty(\"signature\")) object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;\n          return object;\n        };\n        /**\n         * Converts this Proposal to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.Proposal\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Proposal.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Proposal;\n      }();\n\n      types.SignedHeader = function () {\n        /**\n         * Properties of a SignedHeader.\n         * @memberof tendermint.types\n         * @interface ISignedHeader\n         * @property {tendermint.types.IHeader|null} [header] SignedHeader header\n         * @property {tendermint.types.ICommit|null} [commit] SignedHeader commit\n         */\n\n        /**\n         * Constructs a new SignedHeader.\n         * @memberof tendermint.types\n         * @classdesc Represents a SignedHeader.\n         * @implements ISignedHeader\n         * @constructor\n         * @param {tendermint.types.ISignedHeader=} [properties] Properties to set\n         */\n        function SignedHeader(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * SignedHeader header.\n         * @member {tendermint.types.IHeader|null|undefined} header\n         * @memberof tendermint.types.SignedHeader\n         * @instance\n         */\n\n\n        SignedHeader.prototype.header = null;\n        /**\n         * SignedHeader commit.\n         * @member {tendermint.types.ICommit|null|undefined} commit\n         * @memberof tendermint.types.SignedHeader\n         * @instance\n         */\n\n        SignedHeader.prototype.commit = null;\n        /**\n         * Creates a new SignedHeader instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.SignedHeader\n         * @static\n         * @param {tendermint.types.ISignedHeader=} [properties] Properties to set\n         * @returns {tendermint.types.SignedHeader} SignedHeader instance\n         */\n\n        SignedHeader.create = function create(properties) {\n          return new SignedHeader(properties);\n        };\n        /**\n         * Encodes the specified SignedHeader message. Does not implicitly {@link tendermint.types.SignedHeader.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.SignedHeader\n         * @static\n         * @param {tendermint.types.ISignedHeader} message SignedHeader message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SignedHeader.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.header != null && Object.hasOwnProperty.call(message, \"header\")) $root.tendermint.types.Header.encode(message.header, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.commit != null && Object.hasOwnProperty.call(message, \"commit\")) $root.tendermint.types.Commit.encode(message.commit, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified SignedHeader message, length delimited. Does not implicitly {@link tendermint.types.SignedHeader.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.SignedHeader\n         * @static\n         * @param {tendermint.types.ISignedHeader} message SignedHeader message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SignedHeader.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a SignedHeader message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.SignedHeader\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.SignedHeader} SignedHeader\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SignedHeader.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.SignedHeader();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.header = $root.tendermint.types.Header.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.commit = $root.tendermint.types.Commit.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a SignedHeader message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.SignedHeader\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.SignedHeader} SignedHeader\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SignedHeader.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a SignedHeader message.\n         * @function verify\n         * @memberof tendermint.types.SignedHeader\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        SignedHeader.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.header != null && message.hasOwnProperty(\"header\")) {\n            var error = $root.tendermint.types.Header.verify(message.header);\n            if (error) return \"header.\" + error;\n          }\n\n          if (message.commit != null && message.hasOwnProperty(\"commit\")) {\n            var error = $root.tendermint.types.Commit.verify(message.commit);\n            if (error) return \"commit.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a SignedHeader message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.SignedHeader\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.SignedHeader} SignedHeader\n         */\n\n\n        SignedHeader.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.SignedHeader) return object;\n          var message = new $root.tendermint.types.SignedHeader();\n\n          if (object.header != null) {\n            if (typeof object.header !== \"object\") throw TypeError(\".tendermint.types.SignedHeader.header: object expected\");\n            message.header = $root.tendermint.types.Header.fromObject(object.header);\n          }\n\n          if (object.commit != null) {\n            if (typeof object.commit !== \"object\") throw TypeError(\".tendermint.types.SignedHeader.commit: object expected\");\n            message.commit = $root.tendermint.types.Commit.fromObject(object.commit);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a SignedHeader message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.SignedHeader\n         * @static\n         * @param {tendermint.types.SignedHeader} message SignedHeader\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        SignedHeader.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.header = null;\n            object.commit = null;\n          }\n\n          if (message.header != null && message.hasOwnProperty(\"header\")) object.header = $root.tendermint.types.Header.toObject(message.header, options);\n          if (message.commit != null && message.hasOwnProperty(\"commit\")) object.commit = $root.tendermint.types.Commit.toObject(message.commit, options);\n          return object;\n        };\n        /**\n         * Converts this SignedHeader to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.SignedHeader\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        SignedHeader.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return SignedHeader;\n      }();\n\n      types.LightBlock = function () {\n        /**\n         * Properties of a LightBlock.\n         * @memberof tendermint.types\n         * @interface ILightBlock\n         * @property {tendermint.types.ISignedHeader|null} [signedHeader] LightBlock signedHeader\n         * @property {tendermint.types.IValidatorSet|null} [validatorSet] LightBlock validatorSet\n         */\n\n        /**\n         * Constructs a new LightBlock.\n         * @memberof tendermint.types\n         * @classdesc Represents a LightBlock.\n         * @implements ILightBlock\n         * @constructor\n         * @param {tendermint.types.ILightBlock=} [properties] Properties to set\n         */\n        function LightBlock(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * LightBlock signedHeader.\n         * @member {tendermint.types.ISignedHeader|null|undefined} signedHeader\n         * @memberof tendermint.types.LightBlock\n         * @instance\n         */\n\n\n        LightBlock.prototype.signedHeader = null;\n        /**\n         * LightBlock validatorSet.\n         * @member {tendermint.types.IValidatorSet|null|undefined} validatorSet\n         * @memberof tendermint.types.LightBlock\n         * @instance\n         */\n\n        LightBlock.prototype.validatorSet = null;\n        /**\n         * Creates a new LightBlock instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.LightBlock\n         * @static\n         * @param {tendermint.types.ILightBlock=} [properties] Properties to set\n         * @returns {tendermint.types.LightBlock} LightBlock instance\n         */\n\n        LightBlock.create = function create(properties) {\n          return new LightBlock(properties);\n        };\n        /**\n         * Encodes the specified LightBlock message. Does not implicitly {@link tendermint.types.LightBlock.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.LightBlock\n         * @static\n         * @param {tendermint.types.ILightBlock} message LightBlock message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        LightBlock.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.signedHeader != null && Object.hasOwnProperty.call(message, \"signedHeader\")) $root.tendermint.types.SignedHeader.encode(message.signedHeader, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.validatorSet != null && Object.hasOwnProperty.call(message, \"validatorSet\")) $root.tendermint.types.ValidatorSet.encode(message.validatorSet, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified LightBlock message, length delimited. Does not implicitly {@link tendermint.types.LightBlock.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.LightBlock\n         * @static\n         * @param {tendermint.types.ILightBlock} message LightBlock message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        LightBlock.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a LightBlock message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.LightBlock\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.LightBlock} LightBlock\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        LightBlock.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.LightBlock();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.signedHeader = $root.tendermint.types.SignedHeader.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.validatorSet = $root.tendermint.types.ValidatorSet.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a LightBlock message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.LightBlock\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.LightBlock} LightBlock\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        LightBlock.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a LightBlock message.\n         * @function verify\n         * @memberof tendermint.types.LightBlock\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        LightBlock.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.signedHeader != null && message.hasOwnProperty(\"signedHeader\")) {\n            var error = $root.tendermint.types.SignedHeader.verify(message.signedHeader);\n            if (error) return \"signedHeader.\" + error;\n          }\n\n          if (message.validatorSet != null && message.hasOwnProperty(\"validatorSet\")) {\n            var error = $root.tendermint.types.ValidatorSet.verify(message.validatorSet);\n            if (error) return \"validatorSet.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a LightBlock message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.LightBlock\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.LightBlock} LightBlock\n         */\n\n\n        LightBlock.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.LightBlock) return object;\n          var message = new $root.tendermint.types.LightBlock();\n\n          if (object.signedHeader != null) {\n            if (typeof object.signedHeader !== \"object\") throw TypeError(\".tendermint.types.LightBlock.signedHeader: object expected\");\n            message.signedHeader = $root.tendermint.types.SignedHeader.fromObject(object.signedHeader);\n          }\n\n          if (object.validatorSet != null) {\n            if (typeof object.validatorSet !== \"object\") throw TypeError(\".tendermint.types.LightBlock.validatorSet: object expected\");\n            message.validatorSet = $root.tendermint.types.ValidatorSet.fromObject(object.validatorSet);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a LightBlock message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.LightBlock\n         * @static\n         * @param {tendermint.types.LightBlock} message LightBlock\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        LightBlock.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.signedHeader = null;\n            object.validatorSet = null;\n          }\n\n          if (message.signedHeader != null && message.hasOwnProperty(\"signedHeader\")) object.signedHeader = $root.tendermint.types.SignedHeader.toObject(message.signedHeader, options);\n          if (message.validatorSet != null && message.hasOwnProperty(\"validatorSet\")) object.validatorSet = $root.tendermint.types.ValidatorSet.toObject(message.validatorSet, options);\n          return object;\n        };\n        /**\n         * Converts this LightBlock to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.LightBlock\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        LightBlock.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LightBlock;\n      }();\n\n      types.BlockMeta = function () {\n        /**\n         * Properties of a BlockMeta.\n         * @memberof tendermint.types\n         * @interface IBlockMeta\n         * @property {tendermint.types.IBlockID|null} [blockId] BlockMeta blockId\n         * @property {number|Long|null} [blockSize] BlockMeta blockSize\n         * @property {tendermint.types.IHeader|null} [header] BlockMeta header\n         * @property {number|Long|null} [numTxs] BlockMeta numTxs\n         */\n\n        /**\n         * Constructs a new BlockMeta.\n         * @memberof tendermint.types\n         * @classdesc Represents a BlockMeta.\n         * @implements IBlockMeta\n         * @constructor\n         * @param {tendermint.types.IBlockMeta=} [properties] Properties to set\n         */\n        function BlockMeta(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * BlockMeta blockId.\n         * @member {tendermint.types.IBlockID|null|undefined} blockId\n         * @memberof tendermint.types.BlockMeta\n         * @instance\n         */\n\n\n        BlockMeta.prototype.blockId = null;\n        /**\n         * BlockMeta blockSize.\n         * @member {number|Long} blockSize\n         * @memberof tendermint.types.BlockMeta\n         * @instance\n         */\n\n        BlockMeta.prototype.blockSize = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * BlockMeta header.\n         * @member {tendermint.types.IHeader|null|undefined} header\n         * @memberof tendermint.types.BlockMeta\n         * @instance\n         */\n\n        BlockMeta.prototype.header = null;\n        /**\n         * BlockMeta numTxs.\n         * @member {number|Long} numTxs\n         * @memberof tendermint.types.BlockMeta\n         * @instance\n         */\n\n        BlockMeta.prototype.numTxs = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new BlockMeta instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.BlockMeta\n         * @static\n         * @param {tendermint.types.IBlockMeta=} [properties] Properties to set\n         * @returns {tendermint.types.BlockMeta} BlockMeta instance\n         */\n\n        BlockMeta.create = function create(properties) {\n          return new BlockMeta(properties);\n        };\n        /**\n         * Encodes the specified BlockMeta message. Does not implicitly {@link tendermint.types.BlockMeta.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.BlockMeta\n         * @static\n         * @param {tendermint.types.IBlockMeta} message BlockMeta message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        BlockMeta.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.blockId != null && Object.hasOwnProperty.call(message, \"blockId\")) $root.tendermint.types.BlockID.encode(message.blockId, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.blockSize != null && Object.hasOwnProperty.call(message, \"blockSize\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int64(message.blockSize);\n          if (message.header != null && Object.hasOwnProperty.call(message, \"header\")) $root.tendermint.types.Header.encode(message.header, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          if (message.numTxs != null && Object.hasOwnProperty.call(message, \"numTxs\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).int64(message.numTxs);\n          return writer;\n        };\n        /**\n         * Encodes the specified BlockMeta message, length delimited. Does not implicitly {@link tendermint.types.BlockMeta.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.BlockMeta\n         * @static\n         * @param {tendermint.types.IBlockMeta} message BlockMeta message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        BlockMeta.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a BlockMeta message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.BlockMeta\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.BlockMeta} BlockMeta\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        BlockMeta.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.BlockMeta();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.blockId = $root.tendermint.types.BlockID.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.blockSize = reader.int64();\n                break;\n\n              case 3:\n                message.header = $root.tendermint.types.Header.decode(reader, reader.uint32());\n                break;\n\n              case 4:\n                message.numTxs = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a BlockMeta message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.BlockMeta\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.BlockMeta} BlockMeta\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        BlockMeta.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a BlockMeta message.\n         * @function verify\n         * @memberof tendermint.types.BlockMeta\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        BlockMeta.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.blockId != null && message.hasOwnProperty(\"blockId\")) {\n            var error = $root.tendermint.types.BlockID.verify(message.blockId);\n            if (error) return \"blockId.\" + error;\n          }\n\n          if (message.blockSize != null && message.hasOwnProperty(\"blockSize\")) if (!$util.isInteger(message.blockSize) && !(message.blockSize && $util.isInteger(message.blockSize.low) && $util.isInteger(message.blockSize.high))) return \"blockSize: integer|Long expected\";\n\n          if (message.header != null && message.hasOwnProperty(\"header\")) {\n            var error = $root.tendermint.types.Header.verify(message.header);\n            if (error) return \"header.\" + error;\n          }\n\n          if (message.numTxs != null && message.hasOwnProperty(\"numTxs\")) if (!$util.isInteger(message.numTxs) && !(message.numTxs && $util.isInteger(message.numTxs.low) && $util.isInteger(message.numTxs.high))) return \"numTxs: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a BlockMeta message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.BlockMeta\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.BlockMeta} BlockMeta\n         */\n\n\n        BlockMeta.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.BlockMeta) return object;\n          var message = new $root.tendermint.types.BlockMeta();\n\n          if (object.blockId != null) {\n            if (typeof object.blockId !== \"object\") throw TypeError(\".tendermint.types.BlockMeta.blockId: object expected\");\n            message.blockId = $root.tendermint.types.BlockID.fromObject(object.blockId);\n          }\n\n          if (object.blockSize != null) if ($util.Long) (message.blockSize = $util.Long.fromValue(object.blockSize)).unsigned = false;else if (typeof object.blockSize === \"string\") message.blockSize = parseInt(object.blockSize, 10);else if (typeof object.blockSize === \"number\") message.blockSize = object.blockSize;else if (typeof object.blockSize === \"object\") message.blockSize = new $util.LongBits(object.blockSize.low >>> 0, object.blockSize.high >>> 0).toNumber();\n\n          if (object.header != null) {\n            if (typeof object.header !== \"object\") throw TypeError(\".tendermint.types.BlockMeta.header: object expected\");\n            message.header = $root.tendermint.types.Header.fromObject(object.header);\n          }\n\n          if (object.numTxs != null) if ($util.Long) (message.numTxs = $util.Long.fromValue(object.numTxs)).unsigned = false;else if (typeof object.numTxs === \"string\") message.numTxs = parseInt(object.numTxs, 10);else if (typeof object.numTxs === \"number\") message.numTxs = object.numTxs;else if (typeof object.numTxs === \"object\") message.numTxs = new $util.LongBits(object.numTxs.low >>> 0, object.numTxs.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a BlockMeta message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.BlockMeta\n         * @static\n         * @param {tendermint.types.BlockMeta} message BlockMeta\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        BlockMeta.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.blockId = null;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.blockSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.blockSize = options.longs === String ? \"0\" : 0;\n\n            object.header = null;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.numTxs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.numTxs = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.blockId != null && message.hasOwnProperty(\"blockId\")) object.blockId = $root.tendermint.types.BlockID.toObject(message.blockId, options);\n          if (message.blockSize != null && message.hasOwnProperty(\"blockSize\")) if (typeof message.blockSize === \"number\") object.blockSize = options.longs === String ? String(message.blockSize) : message.blockSize;else object.blockSize = options.longs === String ? $util.Long.prototype.toString.call(message.blockSize) : options.longs === Number ? new $util.LongBits(message.blockSize.low >>> 0, message.blockSize.high >>> 0).toNumber() : message.blockSize;\n          if (message.header != null && message.hasOwnProperty(\"header\")) object.header = $root.tendermint.types.Header.toObject(message.header, options);\n          if (message.numTxs != null && message.hasOwnProperty(\"numTxs\")) if (typeof message.numTxs === \"number\") object.numTxs = options.longs === String ? String(message.numTxs) : message.numTxs;else object.numTxs = options.longs === String ? $util.Long.prototype.toString.call(message.numTxs) : options.longs === Number ? new $util.LongBits(message.numTxs.low >>> 0, message.numTxs.high >>> 0).toNumber() : message.numTxs;\n          return object;\n        };\n        /**\n         * Converts this BlockMeta to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.BlockMeta\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        BlockMeta.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BlockMeta;\n      }();\n\n      types.TxProof = function () {\n        /**\n         * Properties of a TxProof.\n         * @memberof tendermint.types\n         * @interface ITxProof\n         * @property {Uint8Array|null} [rootHash] TxProof rootHash\n         * @property {Uint8Array|null} [data] TxProof data\n         * @property {tendermint.crypto.IProof|null} [proof] TxProof proof\n         */\n\n        /**\n         * Constructs a new TxProof.\n         * @memberof tendermint.types\n         * @classdesc Represents a TxProof.\n         * @implements ITxProof\n         * @constructor\n         * @param {tendermint.types.ITxProof=} [properties] Properties to set\n         */\n        function TxProof(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * TxProof rootHash.\n         * @member {Uint8Array} rootHash\n         * @memberof tendermint.types.TxProof\n         * @instance\n         */\n\n\n        TxProof.prototype.rootHash = $util.newBuffer([]);\n        /**\n         * TxProof data.\n         * @member {Uint8Array} data\n         * @memberof tendermint.types.TxProof\n         * @instance\n         */\n\n        TxProof.prototype.data = $util.newBuffer([]);\n        /**\n         * TxProof proof.\n         * @member {tendermint.crypto.IProof|null|undefined} proof\n         * @memberof tendermint.types.TxProof\n         * @instance\n         */\n\n        TxProof.prototype.proof = null;\n        /**\n         * Creates a new TxProof instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.TxProof\n         * @static\n         * @param {tendermint.types.ITxProof=} [properties] Properties to set\n         * @returns {tendermint.types.TxProof} TxProof instance\n         */\n\n        TxProof.create = function create(properties) {\n          return new TxProof(properties);\n        };\n        /**\n         * Encodes the specified TxProof message. Does not implicitly {@link tendermint.types.TxProof.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.TxProof\n         * @static\n         * @param {tendermint.types.ITxProof} message TxProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        TxProof.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.rootHash != null && Object.hasOwnProperty.call(message, \"rootHash\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).bytes(message.rootHash);\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.data);\n          if (message.proof != null && Object.hasOwnProperty.call(message, \"proof\")) $root.tendermint.crypto.Proof.encode(message.proof, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified TxProof message, length delimited. Does not implicitly {@link tendermint.types.TxProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.TxProof\n         * @static\n         * @param {tendermint.types.ITxProof} message TxProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        TxProof.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a TxProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.TxProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.TxProof} TxProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        TxProof.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.TxProof();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.rootHash = reader.bytes();\n                break;\n\n              case 2:\n                message.data = reader.bytes();\n                break;\n\n              case 3:\n                message.proof = $root.tendermint.crypto.Proof.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a TxProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.TxProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.TxProof} TxProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        TxProof.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a TxProof message.\n         * @function verify\n         * @memberof tendermint.types.TxProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        TxProof.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.rootHash != null && message.hasOwnProperty(\"rootHash\")) if (!(message.rootHash && typeof message.rootHash.length === \"number\" || $util.isString(message.rootHash))) return \"rootHash: buffer expected\";\n          if (message.data != null && message.hasOwnProperty(\"data\")) if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data))) return \"data: buffer expected\";\n\n          if (message.proof != null && message.hasOwnProperty(\"proof\")) {\n            var error = $root.tendermint.crypto.Proof.verify(message.proof);\n            if (error) return \"proof.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a TxProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.TxProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.TxProof} TxProof\n         */\n\n\n        TxProof.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.TxProof) return object;\n          var message = new $root.tendermint.types.TxProof();\n          if (object.rootHash != null) if (typeof object.rootHash === \"string\") $util.base64.decode(object.rootHash, message.rootHash = $util.newBuffer($util.base64.length(object.rootHash)), 0);else if (object.rootHash.length) message.rootHash = object.rootHash;\n          if (object.data != null) if (typeof object.data === \"string\") $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;\n\n          if (object.proof != null) {\n            if (typeof object.proof !== \"object\") throw TypeError(\".tendermint.types.TxProof.proof: object expected\");\n            message.proof = $root.tendermint.crypto.Proof.fromObject(object.proof);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a TxProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.TxProof\n         * @static\n         * @param {tendermint.types.TxProof} message TxProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        TxProof.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if (options.bytes === String) object.rootHash = \"\";else {\n              object.rootHash = [];\n              if (options.bytes !== Array) object.rootHash = $util.newBuffer(object.rootHash);\n            }\n            if (options.bytes === String) object.data = \"\";else {\n              object.data = [];\n              if (options.bytes !== Array) object.data = $util.newBuffer(object.data);\n            }\n            object.proof = null;\n          }\n\n          if (message.rootHash != null && message.hasOwnProperty(\"rootHash\")) object.rootHash = options.bytes === String ? $util.base64.encode(message.rootHash, 0, message.rootHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.rootHash) : message.rootHash;\n          if (message.data != null && message.hasOwnProperty(\"data\")) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n          if (message.proof != null && message.hasOwnProperty(\"proof\")) object.proof = $root.tendermint.crypto.Proof.toObject(message.proof, options);\n          return object;\n        };\n        /**\n         * Converts this TxProof to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.TxProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        TxProof.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return TxProof;\n      }();\n\n      types.ValidatorSet = function () {\n        /**\n         * Properties of a ValidatorSet.\n         * @memberof tendermint.types\n         * @interface IValidatorSet\n         * @property {Array.<tendermint.types.IValidator>|null} [validators] ValidatorSet validators\n         * @property {tendermint.types.IValidator|null} [proposer] ValidatorSet proposer\n         * @property {number|Long|null} [totalVotingPower] ValidatorSet totalVotingPower\n         */\n\n        /**\n         * Constructs a new ValidatorSet.\n         * @memberof tendermint.types\n         * @classdesc Represents a ValidatorSet.\n         * @implements IValidatorSet\n         * @constructor\n         * @param {tendermint.types.IValidatorSet=} [properties] Properties to set\n         */\n        function ValidatorSet(properties) {\n          this.validators = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ValidatorSet validators.\n         * @member {Array.<tendermint.types.IValidator>} validators\n         * @memberof tendermint.types.ValidatorSet\n         * @instance\n         */\n\n\n        ValidatorSet.prototype.validators = $util.emptyArray;\n        /**\n         * ValidatorSet proposer.\n         * @member {tendermint.types.IValidator|null|undefined} proposer\n         * @memberof tendermint.types.ValidatorSet\n         * @instance\n         */\n\n        ValidatorSet.prototype.proposer = null;\n        /**\n         * ValidatorSet totalVotingPower.\n         * @member {number|Long} totalVotingPower\n         * @memberof tendermint.types.ValidatorSet\n         * @instance\n         */\n\n        ValidatorSet.prototype.totalVotingPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new ValidatorSet instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.ValidatorSet\n         * @static\n         * @param {tendermint.types.IValidatorSet=} [properties] Properties to set\n         * @returns {tendermint.types.ValidatorSet} ValidatorSet instance\n         */\n\n        ValidatorSet.create = function create(properties) {\n          return new ValidatorSet(properties);\n        };\n        /**\n         * Encodes the specified ValidatorSet message. Does not implicitly {@link tendermint.types.ValidatorSet.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.ValidatorSet\n         * @static\n         * @param {tendermint.types.IValidatorSet} message ValidatorSet message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ValidatorSet.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.validators != null && message.validators.length) for (var i = 0; i < message.validators.length; ++i) {\n            $root.tendermint.types.Validator.encode(message.validators[i], writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).fork()).ldelim();\n          }\n          if (message.proposer != null && Object.hasOwnProperty.call(message, \"proposer\")) $root.tendermint.types.Validator.encode(message.proposer, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          if (message.totalVotingPower != null && Object.hasOwnProperty.call(message, \"totalVotingPower\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int64(message.totalVotingPower);\n          return writer;\n        };\n        /**\n         * Encodes the specified ValidatorSet message, length delimited. Does not implicitly {@link tendermint.types.ValidatorSet.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.ValidatorSet\n         * @static\n         * @param {tendermint.types.IValidatorSet} message ValidatorSet message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ValidatorSet.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ValidatorSet message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.ValidatorSet\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.ValidatorSet} ValidatorSet\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ValidatorSet.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.ValidatorSet();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.validators && message.validators.length)) message.validators = [];\n                message.validators.push($root.tendermint.types.Validator.decode(reader, reader.uint32()));\n                break;\n\n              case 2:\n                message.proposer = $root.tendermint.types.Validator.decode(reader, reader.uint32());\n                break;\n\n              case 3:\n                message.totalVotingPower = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ValidatorSet message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.ValidatorSet\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.ValidatorSet} ValidatorSet\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ValidatorSet.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ValidatorSet message.\n         * @function verify\n         * @memberof tendermint.types.ValidatorSet\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ValidatorSet.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.validators != null && message.hasOwnProperty(\"validators\")) {\n            if (!Array.isArray(message.validators)) return \"validators: array expected\";\n\n            for (var i = 0; i < message.validators.length; ++i) {\n              var error = $root.tendermint.types.Validator.verify(message.validators[i]);\n              if (error) return \"validators.\" + error;\n            }\n          }\n\n          if (message.proposer != null && message.hasOwnProperty(\"proposer\")) {\n            var error = $root.tendermint.types.Validator.verify(message.proposer);\n            if (error) return \"proposer.\" + error;\n          }\n\n          if (message.totalVotingPower != null && message.hasOwnProperty(\"totalVotingPower\")) if (!$util.isInteger(message.totalVotingPower) && !(message.totalVotingPower && $util.isInteger(message.totalVotingPower.low) && $util.isInteger(message.totalVotingPower.high))) return \"totalVotingPower: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a ValidatorSet message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.ValidatorSet\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.ValidatorSet} ValidatorSet\n         */\n\n\n        ValidatorSet.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.ValidatorSet) return object;\n          var message = new $root.tendermint.types.ValidatorSet();\n\n          if (object.validators) {\n            if (!Array.isArray(object.validators)) throw TypeError(\".tendermint.types.ValidatorSet.validators: array expected\");\n            message.validators = [];\n\n            for (var i = 0; i < object.validators.length; ++i) {\n              if (typeof object.validators[i] !== \"object\") throw TypeError(\".tendermint.types.ValidatorSet.validators: object expected\");\n              message.validators[i] = $root.tendermint.types.Validator.fromObject(object.validators[i]);\n            }\n          }\n\n          if (object.proposer != null) {\n            if (typeof object.proposer !== \"object\") throw TypeError(\".tendermint.types.ValidatorSet.proposer: object expected\");\n            message.proposer = $root.tendermint.types.Validator.fromObject(object.proposer);\n          }\n\n          if (object.totalVotingPower != null) if ($util.Long) (message.totalVotingPower = $util.Long.fromValue(object.totalVotingPower)).unsigned = false;else if (typeof object.totalVotingPower === \"string\") message.totalVotingPower = parseInt(object.totalVotingPower, 10);else if (typeof object.totalVotingPower === \"number\") message.totalVotingPower = object.totalVotingPower;else if (typeof object.totalVotingPower === \"object\") message.totalVotingPower = new $util.LongBits(object.totalVotingPower.low >>> 0, object.totalVotingPower.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a ValidatorSet message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.ValidatorSet\n         * @static\n         * @param {tendermint.types.ValidatorSet} message ValidatorSet\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ValidatorSet.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.validators = [];\n\n          if (options.defaults) {\n            object.proposer = null;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.totalVotingPower = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.totalVotingPower = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.validators && message.validators.length) {\n            object.validators = [];\n\n            for (var j = 0; j < message.validators.length; ++j) {\n              object.validators[j] = $root.tendermint.types.Validator.toObject(message.validators[j], options);\n            }\n          }\n\n          if (message.proposer != null && message.hasOwnProperty(\"proposer\")) object.proposer = $root.tendermint.types.Validator.toObject(message.proposer, options);\n          if (message.totalVotingPower != null && message.hasOwnProperty(\"totalVotingPower\")) if (typeof message.totalVotingPower === \"number\") object.totalVotingPower = options.longs === String ? String(message.totalVotingPower) : message.totalVotingPower;else object.totalVotingPower = options.longs === String ? $util.Long.prototype.toString.call(message.totalVotingPower) : options.longs === Number ? new $util.LongBits(message.totalVotingPower.low >>> 0, message.totalVotingPower.high >>> 0).toNumber() : message.totalVotingPower;\n          return object;\n        };\n        /**\n         * Converts this ValidatorSet to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.ValidatorSet\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ValidatorSet.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ValidatorSet;\n      }();\n\n      types.Validator = function () {\n        /**\n         * Properties of a Validator.\n         * @memberof tendermint.types\n         * @interface IValidator\n         * @property {Uint8Array|null} [address] Validator address\n         * @property {tendermint.crypto.IPublicKey|null} [pubKey] Validator pubKey\n         * @property {number|Long|null} [votingPower] Validator votingPower\n         * @property {number|Long|null} [proposerPriority] Validator proposerPriority\n         */\n\n        /**\n         * Constructs a new Validator.\n         * @memberof tendermint.types\n         * @classdesc Represents a Validator.\n         * @implements IValidator\n         * @constructor\n         * @param {tendermint.types.IValidator=} [properties] Properties to set\n         */\n        function Validator(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Validator address.\n         * @member {Uint8Array} address\n         * @memberof tendermint.types.Validator\n         * @instance\n         */\n\n\n        Validator.prototype.address = $util.newBuffer([]);\n        /**\n         * Validator pubKey.\n         * @member {tendermint.crypto.IPublicKey|null|undefined} pubKey\n         * @memberof tendermint.types.Validator\n         * @instance\n         */\n\n        Validator.prototype.pubKey = null;\n        /**\n         * Validator votingPower.\n         * @member {number|Long} votingPower\n         * @memberof tendermint.types.Validator\n         * @instance\n         */\n\n        Validator.prototype.votingPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Validator proposerPriority.\n         * @member {number|Long} proposerPriority\n         * @memberof tendermint.types.Validator\n         * @instance\n         */\n\n        Validator.prototype.proposerPriority = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new Validator instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.Validator\n         * @static\n         * @param {tendermint.types.IValidator=} [properties] Properties to set\n         * @returns {tendermint.types.Validator} Validator instance\n         */\n\n        Validator.create = function create(properties) {\n          return new Validator(properties);\n        };\n        /**\n         * Encodes the specified Validator message. Does not implicitly {@link tendermint.types.Validator.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.Validator\n         * @static\n         * @param {tendermint.types.IValidator} message Validator message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Validator.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.address != null && Object.hasOwnProperty.call(message, \"address\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).bytes(message.address);\n          if (message.pubKey != null && Object.hasOwnProperty.call(message, \"pubKey\")) $root.tendermint.crypto.PublicKey.encode(message.pubKey, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          if (message.votingPower != null && Object.hasOwnProperty.call(message, \"votingPower\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int64(message.votingPower);\n          if (message.proposerPriority != null && Object.hasOwnProperty.call(message, \"proposerPriority\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).int64(message.proposerPriority);\n          return writer;\n        };\n        /**\n         * Encodes the specified Validator message, length delimited. Does not implicitly {@link tendermint.types.Validator.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.Validator\n         * @static\n         * @param {tendermint.types.IValidator} message Validator message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Validator.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Validator message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.Validator\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.Validator} Validator\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Validator.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.Validator();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.address = reader.bytes();\n                break;\n\n              case 2:\n                message.pubKey = $root.tendermint.crypto.PublicKey.decode(reader, reader.uint32());\n                break;\n\n              case 3:\n                message.votingPower = reader.int64();\n                break;\n\n              case 4:\n                message.proposerPriority = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Validator message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.Validator\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.Validator} Validator\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Validator.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Validator message.\n         * @function verify\n         * @memberof tendermint.types.Validator\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Validator.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.address != null && message.hasOwnProperty(\"address\")) if (!(message.address && typeof message.address.length === \"number\" || $util.isString(message.address))) return \"address: buffer expected\";\n\n          if (message.pubKey != null && message.hasOwnProperty(\"pubKey\")) {\n            var error = $root.tendermint.crypto.PublicKey.verify(message.pubKey);\n            if (error) return \"pubKey.\" + error;\n          }\n\n          if (message.votingPower != null && message.hasOwnProperty(\"votingPower\")) if (!$util.isInteger(message.votingPower) && !(message.votingPower && $util.isInteger(message.votingPower.low) && $util.isInteger(message.votingPower.high))) return \"votingPower: integer|Long expected\";\n          if (message.proposerPriority != null && message.hasOwnProperty(\"proposerPriority\")) if (!$util.isInteger(message.proposerPriority) && !(message.proposerPriority && $util.isInteger(message.proposerPriority.low) && $util.isInteger(message.proposerPriority.high))) return \"proposerPriority: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a Validator message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.Validator\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.Validator} Validator\n         */\n\n\n        Validator.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.Validator) return object;\n          var message = new $root.tendermint.types.Validator();\n          if (object.address != null) if (typeof object.address === \"string\") $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);else if (object.address.length) message.address = object.address;\n\n          if (object.pubKey != null) {\n            if (typeof object.pubKey !== \"object\") throw TypeError(\".tendermint.types.Validator.pubKey: object expected\");\n            message.pubKey = $root.tendermint.crypto.PublicKey.fromObject(object.pubKey);\n          }\n\n          if (object.votingPower != null) if ($util.Long) (message.votingPower = $util.Long.fromValue(object.votingPower)).unsigned = false;else if (typeof object.votingPower === \"string\") message.votingPower = parseInt(object.votingPower, 10);else if (typeof object.votingPower === \"number\") message.votingPower = object.votingPower;else if (typeof object.votingPower === \"object\") message.votingPower = new $util.LongBits(object.votingPower.low >>> 0, object.votingPower.high >>> 0).toNumber();\n          if (object.proposerPriority != null) if ($util.Long) (message.proposerPriority = $util.Long.fromValue(object.proposerPriority)).unsigned = false;else if (typeof object.proposerPriority === \"string\") message.proposerPriority = parseInt(object.proposerPriority, 10);else if (typeof object.proposerPriority === \"number\") message.proposerPriority = object.proposerPriority;else if (typeof object.proposerPriority === \"object\") message.proposerPriority = new $util.LongBits(object.proposerPriority.low >>> 0, object.proposerPriority.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a Validator message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.Validator\n         * @static\n         * @param {tendermint.types.Validator} message Validator\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Validator.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if (options.bytes === String) object.address = \"\";else {\n              object.address = [];\n              if (options.bytes !== Array) object.address = $util.newBuffer(object.address);\n            }\n            object.pubKey = null;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.votingPower = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.votingPower = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.proposerPriority = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.proposerPriority = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.address != null && message.hasOwnProperty(\"address\")) object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;\n          if (message.pubKey != null && message.hasOwnProperty(\"pubKey\")) object.pubKey = $root.tendermint.crypto.PublicKey.toObject(message.pubKey, options);\n          if (message.votingPower != null && message.hasOwnProperty(\"votingPower\")) if (typeof message.votingPower === \"number\") object.votingPower = options.longs === String ? String(message.votingPower) : message.votingPower;else object.votingPower = options.longs === String ? $util.Long.prototype.toString.call(message.votingPower) : options.longs === Number ? new $util.LongBits(message.votingPower.low >>> 0, message.votingPower.high >>> 0).toNumber() : message.votingPower;\n          if (message.proposerPriority != null && message.hasOwnProperty(\"proposerPriority\")) if (typeof message.proposerPriority === \"number\") object.proposerPriority = options.longs === String ? String(message.proposerPriority) : message.proposerPriority;else object.proposerPriority = options.longs === String ? $util.Long.prototype.toString.call(message.proposerPriority) : options.longs === Number ? new $util.LongBits(message.proposerPriority.low >>> 0, message.proposerPriority.high >>> 0).toNumber() : message.proposerPriority;\n          return object;\n        };\n        /**\n         * Converts this Validator to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.Validator\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Validator.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Validator;\n      }();\n\n      types.SimpleValidator = function () {\n        /**\n         * Properties of a SimpleValidator.\n         * @memberof tendermint.types\n         * @interface ISimpleValidator\n         * @property {tendermint.crypto.IPublicKey|null} [pubKey] SimpleValidator pubKey\n         * @property {number|Long|null} [votingPower] SimpleValidator votingPower\n         */\n\n        /**\n         * Constructs a new SimpleValidator.\n         * @memberof tendermint.types\n         * @classdesc Represents a SimpleValidator.\n         * @implements ISimpleValidator\n         * @constructor\n         * @param {tendermint.types.ISimpleValidator=} [properties] Properties to set\n         */\n        function SimpleValidator(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * SimpleValidator pubKey.\n         * @member {tendermint.crypto.IPublicKey|null|undefined} pubKey\n         * @memberof tendermint.types.SimpleValidator\n         * @instance\n         */\n\n\n        SimpleValidator.prototype.pubKey = null;\n        /**\n         * SimpleValidator votingPower.\n         * @member {number|Long} votingPower\n         * @memberof tendermint.types.SimpleValidator\n         * @instance\n         */\n\n        SimpleValidator.prototype.votingPower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Creates a new SimpleValidator instance using the specified properties.\n         * @function create\n         * @memberof tendermint.types.SimpleValidator\n         * @static\n         * @param {tendermint.types.ISimpleValidator=} [properties] Properties to set\n         * @returns {tendermint.types.SimpleValidator} SimpleValidator instance\n         */\n\n        SimpleValidator.create = function create(properties) {\n          return new SimpleValidator(properties);\n        };\n        /**\n         * Encodes the specified SimpleValidator message. Does not implicitly {@link tendermint.types.SimpleValidator.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.types.SimpleValidator\n         * @static\n         * @param {tendermint.types.ISimpleValidator} message SimpleValidator message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SimpleValidator.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.pubKey != null && Object.hasOwnProperty.call(message, \"pubKey\")) $root.tendermint.crypto.PublicKey.encode(message.pubKey, writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).fork()).ldelim();\n          if (message.votingPower != null && Object.hasOwnProperty.call(message, \"votingPower\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int64(message.votingPower);\n          return writer;\n        };\n        /**\n         * Encodes the specified SimpleValidator message, length delimited. Does not implicitly {@link tendermint.types.SimpleValidator.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.types.SimpleValidator\n         * @static\n         * @param {tendermint.types.ISimpleValidator} message SimpleValidator message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SimpleValidator.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a SimpleValidator message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.types.SimpleValidator\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.types.SimpleValidator} SimpleValidator\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SimpleValidator.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.types.SimpleValidator();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.pubKey = $root.tendermint.crypto.PublicKey.decode(reader, reader.uint32());\n                break;\n\n              case 2:\n                message.votingPower = reader.int64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a SimpleValidator message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.types.SimpleValidator\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.types.SimpleValidator} SimpleValidator\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SimpleValidator.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a SimpleValidator message.\n         * @function verify\n         * @memberof tendermint.types.SimpleValidator\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        SimpleValidator.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.pubKey != null && message.hasOwnProperty(\"pubKey\")) {\n            var error = $root.tendermint.crypto.PublicKey.verify(message.pubKey);\n            if (error) return \"pubKey.\" + error;\n          }\n\n          if (message.votingPower != null && message.hasOwnProperty(\"votingPower\")) if (!$util.isInteger(message.votingPower) && !(message.votingPower && $util.isInteger(message.votingPower.low) && $util.isInteger(message.votingPower.high))) return \"votingPower: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a SimpleValidator message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.types.SimpleValidator\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.types.SimpleValidator} SimpleValidator\n         */\n\n\n        SimpleValidator.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.types.SimpleValidator) return object;\n          var message = new $root.tendermint.types.SimpleValidator();\n\n          if (object.pubKey != null) {\n            if (typeof object.pubKey !== \"object\") throw TypeError(\".tendermint.types.SimpleValidator.pubKey: object expected\");\n            message.pubKey = $root.tendermint.crypto.PublicKey.fromObject(object.pubKey);\n          }\n\n          if (object.votingPower != null) if ($util.Long) (message.votingPower = $util.Long.fromValue(object.votingPower)).unsigned = false;else if (typeof object.votingPower === \"string\") message.votingPower = parseInt(object.votingPower, 10);else if (typeof object.votingPower === \"number\") message.votingPower = object.votingPower;else if (typeof object.votingPower === \"object\") message.votingPower = new $util.LongBits(object.votingPower.low >>> 0, object.votingPower.high >>> 0).toNumber();\n          return message;\n        };\n        /**\n         * Creates a plain object from a SimpleValidator message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.types.SimpleValidator\n         * @static\n         * @param {tendermint.types.SimpleValidator} message SimpleValidator\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        SimpleValidator.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.pubKey = null;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.votingPower = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.votingPower = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.pubKey != null && message.hasOwnProperty(\"pubKey\")) object.pubKey = $root.tendermint.crypto.PublicKey.toObject(message.pubKey, options);\n          if (message.votingPower != null && message.hasOwnProperty(\"votingPower\")) if (typeof message.votingPower === \"number\") object.votingPower = options.longs === String ? String(message.votingPower) : message.votingPower;else object.votingPower = options.longs === String ? $util.Long.prototype.toString.call(message.votingPower) : options.longs === Number ? new $util.LongBits(message.votingPower.low >>> 0, message.votingPower.high >>> 0).toNumber() : message.votingPower;\n          return object;\n        };\n        /**\n         * Converts this SimpleValidator to JSON.\n         * @function toJSON\n         * @memberof tendermint.types.SimpleValidator\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        SimpleValidator.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return SimpleValidator;\n      }();\n\n      return types;\n    }();\n\n    tendermint.crypto = function () {\n      /**\n       * Namespace crypto.\n       * @memberof tendermint\n       * @namespace\n       */\n      var crypto = {};\n\n      crypto.PublicKey = function () {\n        /**\n         * Properties of a PublicKey.\n         * @memberof tendermint.crypto\n         * @interface IPublicKey\n         * @property {Uint8Array|null} [ed25519] PublicKey ed25519\n         * @property {Uint8Array|null} [secp256k1] PublicKey secp256k1\n         */\n\n        /**\n         * Constructs a new PublicKey.\n         * @memberof tendermint.crypto\n         * @classdesc Represents a PublicKey.\n         * @implements IPublicKey\n         * @constructor\n         * @param {tendermint.crypto.IPublicKey=} [properties] Properties to set\n         */\n        function PublicKey(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * PublicKey ed25519.\n         * @member {Uint8Array|null|undefined} ed25519\n         * @memberof tendermint.crypto.PublicKey\n         * @instance\n         */\n\n\n        PublicKey.prototype.ed25519 = null;\n        /**\n         * PublicKey secp256k1.\n         * @member {Uint8Array|null|undefined} secp256k1\n         * @memberof tendermint.crypto.PublicKey\n         * @instance\n         */\n\n        PublicKey.prototype.secp256k1 = null; // OneOf field names bound to virtual getters and setters\n\n        var $oneOfFields;\n        /**\n         * PublicKey sum.\n         * @member {\"ed25519\"|\"secp256k1\"|undefined} sum\n         * @memberof tendermint.crypto.PublicKey\n         * @instance\n         */\n\n        Object.defineProperty(PublicKey.prototype, \"sum\", {\n          get: $util.oneOfGetter($oneOfFields = [\"ed25519\", \"secp256k1\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        /**\n         * Creates a new PublicKey instance using the specified properties.\n         * @function create\n         * @memberof tendermint.crypto.PublicKey\n         * @static\n         * @param {tendermint.crypto.IPublicKey=} [properties] Properties to set\n         * @returns {tendermint.crypto.PublicKey} PublicKey instance\n         */\n\n        PublicKey.create = function create(properties) {\n          return new PublicKey(properties);\n        };\n        /**\n         * Encodes the specified PublicKey message. Does not implicitly {@link tendermint.crypto.PublicKey.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.crypto.PublicKey\n         * @static\n         * @param {tendermint.crypto.IPublicKey} message PublicKey message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        PublicKey.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.ed25519 != null && Object.hasOwnProperty.call(message, \"ed25519\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).bytes(message.ed25519);\n          if (message.secp256k1 != null && Object.hasOwnProperty.call(message, \"secp256k1\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.secp256k1);\n          return writer;\n        };\n        /**\n         * Encodes the specified PublicKey message, length delimited. Does not implicitly {@link tendermint.crypto.PublicKey.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.crypto.PublicKey\n         * @static\n         * @param {tendermint.crypto.IPublicKey} message PublicKey message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        PublicKey.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a PublicKey message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.crypto.PublicKey\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.crypto.PublicKey} PublicKey\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        PublicKey.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.crypto.PublicKey();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.ed25519 = reader.bytes();\n                break;\n\n              case 2:\n                message.secp256k1 = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a PublicKey message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.crypto.PublicKey\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.crypto.PublicKey} PublicKey\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        PublicKey.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a PublicKey message.\n         * @function verify\n         * @memberof tendermint.crypto.PublicKey\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        PublicKey.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          var properties = {};\n\n          if (message.ed25519 != null && message.hasOwnProperty(\"ed25519\")) {\n            properties.sum = 1;\n            if (!(message.ed25519 && typeof message.ed25519.length === \"number\" || $util.isString(message.ed25519))) return \"ed25519: buffer expected\";\n          }\n\n          if (message.secp256k1 != null && message.hasOwnProperty(\"secp256k1\")) {\n            if (properties.sum === 1) return \"sum: multiple values\";\n            properties.sum = 1;\n            if (!(message.secp256k1 && typeof message.secp256k1.length === \"number\" || $util.isString(message.secp256k1))) return \"secp256k1: buffer expected\";\n          }\n\n          return null;\n        };\n        /**\n         * Creates a PublicKey message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.crypto.PublicKey\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.crypto.PublicKey} PublicKey\n         */\n\n\n        PublicKey.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.crypto.PublicKey) return object;\n          var message = new $root.tendermint.crypto.PublicKey();\n          if (object.ed25519 != null) if (typeof object.ed25519 === \"string\") $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);else if (object.ed25519.length) message.ed25519 = object.ed25519;\n          if (object.secp256k1 != null) if (typeof object.secp256k1 === \"string\") $util.base64.decode(object.secp256k1, message.secp256k1 = $util.newBuffer($util.base64.length(object.secp256k1)), 0);else if (object.secp256k1.length) message.secp256k1 = object.secp256k1;\n          return message;\n        };\n        /**\n         * Creates a plain object from a PublicKey message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.crypto.PublicKey\n         * @static\n         * @param {tendermint.crypto.PublicKey} message PublicKey\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        PublicKey.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (message.ed25519 != null && message.hasOwnProperty(\"ed25519\")) {\n            object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;\n            if (options.oneofs) object.sum = \"ed25519\";\n          }\n\n          if (message.secp256k1 != null && message.hasOwnProperty(\"secp256k1\")) {\n            object.secp256k1 = options.bytes === String ? $util.base64.encode(message.secp256k1, 0, message.secp256k1.length) : options.bytes === Array ? Array.prototype.slice.call(message.secp256k1) : message.secp256k1;\n            if (options.oneofs) object.sum = \"secp256k1\";\n          }\n\n          return object;\n        };\n        /**\n         * Converts this PublicKey to JSON.\n         * @function toJSON\n         * @memberof tendermint.crypto.PublicKey\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        PublicKey.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return PublicKey;\n      }();\n\n      crypto.Proof = function () {\n        /**\n         * Properties of a Proof.\n         * @memberof tendermint.crypto\n         * @interface IProof\n         * @property {number|Long|null} [total] Proof total\n         * @property {number|Long|null} [index] Proof index\n         * @property {Uint8Array|null} [leafHash] Proof leafHash\n         * @property {Array.<Uint8Array>|null} [aunts] Proof aunts\n         */\n\n        /**\n         * Constructs a new Proof.\n         * @memberof tendermint.crypto\n         * @classdesc Represents a Proof.\n         * @implements IProof\n         * @constructor\n         * @param {tendermint.crypto.IProof=} [properties] Properties to set\n         */\n        function Proof(properties) {\n          this.aunts = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Proof total.\n         * @member {number|Long} total\n         * @memberof tendermint.crypto.Proof\n         * @instance\n         */\n\n\n        Proof.prototype.total = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Proof index.\n         * @member {number|Long} index\n         * @memberof tendermint.crypto.Proof\n         * @instance\n         */\n\n        Proof.prototype.index = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Proof leafHash.\n         * @member {Uint8Array} leafHash\n         * @memberof tendermint.crypto.Proof\n         * @instance\n         */\n\n        Proof.prototype.leafHash = $util.newBuffer([]);\n        /**\n         * Proof aunts.\n         * @member {Array.<Uint8Array>} aunts\n         * @memberof tendermint.crypto.Proof\n         * @instance\n         */\n\n        Proof.prototype.aunts = $util.emptyArray;\n        /**\n         * Creates a new Proof instance using the specified properties.\n         * @function create\n         * @memberof tendermint.crypto.Proof\n         * @static\n         * @param {tendermint.crypto.IProof=} [properties] Properties to set\n         * @returns {tendermint.crypto.Proof} Proof instance\n         */\n\n        Proof.create = function create(properties) {\n          return new Proof(properties);\n        };\n        /**\n         * Encodes the specified Proof message. Does not implicitly {@link tendermint.crypto.Proof.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.crypto.Proof\n         * @static\n         * @param {tendermint.crypto.IProof} message Proof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Proof.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.total != null && Object.hasOwnProperty.call(message, \"total\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int64(message.total);\n          if (message.index != null && Object.hasOwnProperty.call(message, \"index\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int64(message.index);\n          if (message.leafHash != null && Object.hasOwnProperty.call(message, \"leafHash\")) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).bytes(message.leafHash);\n          if (message.aunts != null && message.aunts.length) for (var i = 0; i < message.aunts.length; ++i) {\n            writer.uint32(\n            /* id 4, wireType 2 =*/\n            34).bytes(message.aunts[i]);\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified Proof message, length delimited. Does not implicitly {@link tendermint.crypto.Proof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.crypto.Proof\n         * @static\n         * @param {tendermint.crypto.IProof} message Proof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Proof.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Proof message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.crypto.Proof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.crypto.Proof} Proof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Proof.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.crypto.Proof();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.total = reader.int64();\n                break;\n\n              case 2:\n                message.index = reader.int64();\n                break;\n\n              case 3:\n                message.leafHash = reader.bytes();\n                break;\n\n              case 4:\n                if (!(message.aunts && message.aunts.length)) message.aunts = [];\n                message.aunts.push(reader.bytes());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Proof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.crypto.Proof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.crypto.Proof} Proof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Proof.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Proof message.\n         * @function verify\n         * @memberof tendermint.crypto.Proof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Proof.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.total != null && message.hasOwnProperty(\"total\")) if (!$util.isInteger(message.total) && !(message.total && $util.isInteger(message.total.low) && $util.isInteger(message.total.high))) return \"total: integer|Long expected\";\n          if (message.index != null && message.hasOwnProperty(\"index\")) if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high))) return \"index: integer|Long expected\";\n          if (message.leafHash != null && message.hasOwnProperty(\"leafHash\")) if (!(message.leafHash && typeof message.leafHash.length === \"number\" || $util.isString(message.leafHash))) return \"leafHash: buffer expected\";\n\n          if (message.aunts != null && message.hasOwnProperty(\"aunts\")) {\n            if (!Array.isArray(message.aunts)) return \"aunts: array expected\";\n\n            for (var i = 0; i < message.aunts.length; ++i) {\n              if (!(message.aunts[i] && typeof message.aunts[i].length === \"number\" || $util.isString(message.aunts[i]))) return \"aunts: buffer[] expected\";\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a Proof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.crypto.Proof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.crypto.Proof} Proof\n         */\n\n\n        Proof.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.crypto.Proof) return object;\n          var message = new $root.tendermint.crypto.Proof();\n          if (object.total != null) if ($util.Long) (message.total = $util.Long.fromValue(object.total)).unsigned = false;else if (typeof object.total === \"string\") message.total = parseInt(object.total, 10);else if (typeof object.total === \"number\") message.total = object.total;else if (typeof object.total === \"object\") message.total = new $util.LongBits(object.total.low >>> 0, object.total.high >>> 0).toNumber();\n          if (object.index != null) if ($util.Long) (message.index = $util.Long.fromValue(object.index)).unsigned = false;else if (typeof object.index === \"string\") message.index = parseInt(object.index, 10);else if (typeof object.index === \"number\") message.index = object.index;else if (typeof object.index === \"object\") message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber();\n          if (object.leafHash != null) if (typeof object.leafHash === \"string\") $util.base64.decode(object.leafHash, message.leafHash = $util.newBuffer($util.base64.length(object.leafHash)), 0);else if (object.leafHash.length) message.leafHash = object.leafHash;\n\n          if (object.aunts) {\n            if (!Array.isArray(object.aunts)) throw TypeError(\".tendermint.crypto.Proof.aunts: array expected\");\n            message.aunts = [];\n\n            for (var i = 0; i < object.aunts.length; ++i) {\n              if (typeof object.aunts[i] === \"string\") $util.base64.decode(object.aunts[i], message.aunts[i] = $util.newBuffer($util.base64.length(object.aunts[i])), 0);else if (object.aunts[i].length) message.aunts[i] = object.aunts[i];\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a Proof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.crypto.Proof\n         * @static\n         * @param {tendermint.crypto.Proof} message Proof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Proof.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.aunts = [];\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.total = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.total = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.index = options.longs === String ? \"0\" : 0;\n\n            if (options.bytes === String) object.leafHash = \"\";else {\n              object.leafHash = [];\n              if (options.bytes !== Array) object.leafHash = $util.newBuffer(object.leafHash);\n            }\n          }\n\n          if (message.total != null && message.hasOwnProperty(\"total\")) if (typeof message.total === \"number\") object.total = options.longs === String ? String(message.total) : message.total;else object.total = options.longs === String ? $util.Long.prototype.toString.call(message.total) : options.longs === Number ? new $util.LongBits(message.total.low >>> 0, message.total.high >>> 0).toNumber() : message.total;\n          if (message.index != null && message.hasOwnProperty(\"index\")) if (typeof message.index === \"number\") object.index = options.longs === String ? String(message.index) : message.index;else object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber() : message.index;\n          if (message.leafHash != null && message.hasOwnProperty(\"leafHash\")) object.leafHash = options.bytes === String ? $util.base64.encode(message.leafHash, 0, message.leafHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.leafHash) : message.leafHash;\n\n          if (message.aunts && message.aunts.length) {\n            object.aunts = [];\n\n            for (var j = 0; j < message.aunts.length; ++j) {\n              object.aunts[j] = options.bytes === String ? $util.base64.encode(message.aunts[j], 0, message.aunts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.aunts[j]) : message.aunts[j];\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this Proof to JSON.\n         * @function toJSON\n         * @memberof tendermint.crypto.Proof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Proof.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Proof;\n      }();\n\n      crypto.ValueOp = function () {\n        /**\n         * Properties of a ValueOp.\n         * @memberof tendermint.crypto\n         * @interface IValueOp\n         * @property {Uint8Array|null} [key] ValueOp key\n         * @property {tendermint.crypto.IProof|null} [proof] ValueOp proof\n         */\n\n        /**\n         * Constructs a new ValueOp.\n         * @memberof tendermint.crypto\n         * @classdesc Represents a ValueOp.\n         * @implements IValueOp\n         * @constructor\n         * @param {tendermint.crypto.IValueOp=} [properties] Properties to set\n         */\n        function ValueOp(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ValueOp key.\n         * @member {Uint8Array} key\n         * @memberof tendermint.crypto.ValueOp\n         * @instance\n         */\n\n\n        ValueOp.prototype.key = $util.newBuffer([]);\n        /**\n         * ValueOp proof.\n         * @member {tendermint.crypto.IProof|null|undefined} proof\n         * @memberof tendermint.crypto.ValueOp\n         * @instance\n         */\n\n        ValueOp.prototype.proof = null;\n        /**\n         * Creates a new ValueOp instance using the specified properties.\n         * @function create\n         * @memberof tendermint.crypto.ValueOp\n         * @static\n         * @param {tendermint.crypto.IValueOp=} [properties] Properties to set\n         * @returns {tendermint.crypto.ValueOp} ValueOp instance\n         */\n\n        ValueOp.create = function create(properties) {\n          return new ValueOp(properties);\n        };\n        /**\n         * Encodes the specified ValueOp message. Does not implicitly {@link tendermint.crypto.ValueOp.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.crypto.ValueOp\n         * @static\n         * @param {tendermint.crypto.IValueOp} message ValueOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ValueOp.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.key != null && Object.hasOwnProperty.call(message, \"key\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).bytes(message.key);\n          if (message.proof != null && Object.hasOwnProperty.call(message, \"proof\")) $root.tendermint.crypto.Proof.encode(message.proof, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified ValueOp message, length delimited. Does not implicitly {@link tendermint.crypto.ValueOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.crypto.ValueOp\n         * @static\n         * @param {tendermint.crypto.IValueOp} message ValueOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ValueOp.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ValueOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.crypto.ValueOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.crypto.ValueOp} ValueOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ValueOp.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.crypto.ValueOp();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.key = reader.bytes();\n                break;\n\n              case 2:\n                message.proof = $root.tendermint.crypto.Proof.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ValueOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.crypto.ValueOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.crypto.ValueOp} ValueOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ValueOp.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ValueOp message.\n         * @function verify\n         * @memberof tendermint.crypto.ValueOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ValueOp.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.key != null && message.hasOwnProperty(\"key\")) if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key))) return \"key: buffer expected\";\n\n          if (message.proof != null && message.hasOwnProperty(\"proof\")) {\n            var error = $root.tendermint.crypto.Proof.verify(message.proof);\n            if (error) return \"proof.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a ValueOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.crypto.ValueOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.crypto.ValueOp} ValueOp\n         */\n\n\n        ValueOp.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.crypto.ValueOp) return object;\n          var message = new $root.tendermint.crypto.ValueOp();\n          if (object.key != null) if (typeof object.key === \"string\") $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);else if (object.key.length) message.key = object.key;\n\n          if (object.proof != null) {\n            if (typeof object.proof !== \"object\") throw TypeError(\".tendermint.crypto.ValueOp.proof: object expected\");\n            message.proof = $root.tendermint.crypto.Proof.fromObject(object.proof);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a ValueOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.crypto.ValueOp\n         * @static\n         * @param {tendermint.crypto.ValueOp} message ValueOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ValueOp.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if (options.bytes === String) object.key = \"\";else {\n              object.key = [];\n              if (options.bytes !== Array) object.key = $util.newBuffer(object.key);\n            }\n            object.proof = null;\n          }\n\n          if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n          if (message.proof != null && message.hasOwnProperty(\"proof\")) object.proof = $root.tendermint.crypto.Proof.toObject(message.proof, options);\n          return object;\n        };\n        /**\n         * Converts this ValueOp to JSON.\n         * @function toJSON\n         * @memberof tendermint.crypto.ValueOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ValueOp.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ValueOp;\n      }();\n\n      crypto.DominoOp = function () {\n        /**\n         * Properties of a DominoOp.\n         * @memberof tendermint.crypto\n         * @interface IDominoOp\n         * @property {string|null} [key] DominoOp key\n         * @property {string|null} [input] DominoOp input\n         * @property {string|null} [output] DominoOp output\n         */\n\n        /**\n         * Constructs a new DominoOp.\n         * @memberof tendermint.crypto\n         * @classdesc Represents a DominoOp.\n         * @implements IDominoOp\n         * @constructor\n         * @param {tendermint.crypto.IDominoOp=} [properties] Properties to set\n         */\n        function DominoOp(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * DominoOp key.\n         * @member {string} key\n         * @memberof tendermint.crypto.DominoOp\n         * @instance\n         */\n\n\n        DominoOp.prototype.key = \"\";\n        /**\n         * DominoOp input.\n         * @member {string} input\n         * @memberof tendermint.crypto.DominoOp\n         * @instance\n         */\n\n        DominoOp.prototype.input = \"\";\n        /**\n         * DominoOp output.\n         * @member {string} output\n         * @memberof tendermint.crypto.DominoOp\n         * @instance\n         */\n\n        DominoOp.prototype.output = \"\";\n        /**\n         * Creates a new DominoOp instance using the specified properties.\n         * @function create\n         * @memberof tendermint.crypto.DominoOp\n         * @static\n         * @param {tendermint.crypto.IDominoOp=} [properties] Properties to set\n         * @returns {tendermint.crypto.DominoOp} DominoOp instance\n         */\n\n        DominoOp.create = function create(properties) {\n          return new DominoOp(properties);\n        };\n        /**\n         * Encodes the specified DominoOp message. Does not implicitly {@link tendermint.crypto.DominoOp.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.crypto.DominoOp\n         * @static\n         * @param {tendermint.crypto.IDominoOp} message DominoOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        DominoOp.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.key != null && Object.hasOwnProperty.call(message, \"key\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.key);\n          if (message.input != null && Object.hasOwnProperty.call(message, \"input\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).string(message.input);\n          if (message.output != null && Object.hasOwnProperty.call(message, \"output\")) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).string(message.output);\n          return writer;\n        };\n        /**\n         * Encodes the specified DominoOp message, length delimited. Does not implicitly {@link tendermint.crypto.DominoOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.crypto.DominoOp\n         * @static\n         * @param {tendermint.crypto.IDominoOp} message DominoOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        DominoOp.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a DominoOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.crypto.DominoOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.crypto.DominoOp} DominoOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        DominoOp.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.crypto.DominoOp();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.key = reader.string();\n                break;\n\n              case 2:\n                message.input = reader.string();\n                break;\n\n              case 3:\n                message.output = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a DominoOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.crypto.DominoOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.crypto.DominoOp} DominoOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        DominoOp.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a DominoOp message.\n         * @function verify\n         * @memberof tendermint.crypto.DominoOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        DominoOp.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.key != null && message.hasOwnProperty(\"key\")) if (!$util.isString(message.key)) return \"key: string expected\";\n          if (message.input != null && message.hasOwnProperty(\"input\")) if (!$util.isString(message.input)) return \"input: string expected\";\n          if (message.output != null && message.hasOwnProperty(\"output\")) if (!$util.isString(message.output)) return \"output: string expected\";\n          return null;\n        };\n        /**\n         * Creates a DominoOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.crypto.DominoOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.crypto.DominoOp} DominoOp\n         */\n\n\n        DominoOp.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.crypto.DominoOp) return object;\n          var message = new $root.tendermint.crypto.DominoOp();\n          if (object.key != null) message.key = String(object.key);\n          if (object.input != null) message.input = String(object.input);\n          if (object.output != null) message.output = String(object.output);\n          return message;\n        };\n        /**\n         * Creates a plain object from a DominoOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.crypto.DominoOp\n         * @static\n         * @param {tendermint.crypto.DominoOp} message DominoOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        DominoOp.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.key = \"\";\n            object.input = \"\";\n            object.output = \"\";\n          }\n\n          if (message.key != null && message.hasOwnProperty(\"key\")) object.key = message.key;\n          if (message.input != null && message.hasOwnProperty(\"input\")) object.input = message.input;\n          if (message.output != null && message.hasOwnProperty(\"output\")) object.output = message.output;\n          return object;\n        };\n        /**\n         * Converts this DominoOp to JSON.\n         * @function toJSON\n         * @memberof tendermint.crypto.DominoOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        DominoOp.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return DominoOp;\n      }();\n\n      crypto.ProofOp = function () {\n        /**\n         * Properties of a ProofOp.\n         * @memberof tendermint.crypto\n         * @interface IProofOp\n         * @property {string|null} [type] ProofOp type\n         * @property {Uint8Array|null} [key] ProofOp key\n         * @property {Uint8Array|null} [data] ProofOp data\n         */\n\n        /**\n         * Constructs a new ProofOp.\n         * @memberof tendermint.crypto\n         * @classdesc Represents a ProofOp.\n         * @implements IProofOp\n         * @constructor\n         * @param {tendermint.crypto.IProofOp=} [properties] Properties to set\n         */\n        function ProofOp(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ProofOp type.\n         * @member {string} type\n         * @memberof tendermint.crypto.ProofOp\n         * @instance\n         */\n\n\n        ProofOp.prototype.type = \"\";\n        /**\n         * ProofOp key.\n         * @member {Uint8Array} key\n         * @memberof tendermint.crypto.ProofOp\n         * @instance\n         */\n\n        ProofOp.prototype.key = $util.newBuffer([]);\n        /**\n         * ProofOp data.\n         * @member {Uint8Array} data\n         * @memberof tendermint.crypto.ProofOp\n         * @instance\n         */\n\n        ProofOp.prototype.data = $util.newBuffer([]);\n        /**\n         * Creates a new ProofOp instance using the specified properties.\n         * @function create\n         * @memberof tendermint.crypto.ProofOp\n         * @static\n         * @param {tendermint.crypto.IProofOp=} [properties] Properties to set\n         * @returns {tendermint.crypto.ProofOp} ProofOp instance\n         */\n\n        ProofOp.create = function create(properties) {\n          return new ProofOp(properties);\n        };\n        /**\n         * Encodes the specified ProofOp message. Does not implicitly {@link tendermint.crypto.ProofOp.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.crypto.ProofOp\n         * @static\n         * @param {tendermint.crypto.IProofOp} message ProofOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ProofOp.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.type);\n          if (message.key != null && Object.hasOwnProperty.call(message, \"key\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.key);\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\")) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).bytes(message.data);\n          return writer;\n        };\n        /**\n         * Encodes the specified ProofOp message, length delimited. Does not implicitly {@link tendermint.crypto.ProofOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.crypto.ProofOp\n         * @static\n         * @param {tendermint.crypto.IProofOp} message ProofOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ProofOp.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ProofOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.crypto.ProofOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.crypto.ProofOp} ProofOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ProofOp.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.crypto.ProofOp();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.type = reader.string();\n                break;\n\n              case 2:\n                message.key = reader.bytes();\n                break;\n\n              case 3:\n                message.data = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ProofOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.crypto.ProofOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.crypto.ProofOp} ProofOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ProofOp.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ProofOp message.\n         * @function verify\n         * @memberof tendermint.crypto.ProofOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ProofOp.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.type != null && message.hasOwnProperty(\"type\")) if (!$util.isString(message.type)) return \"type: string expected\";\n          if (message.key != null && message.hasOwnProperty(\"key\")) if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key))) return \"key: buffer expected\";\n          if (message.data != null && message.hasOwnProperty(\"data\")) if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data))) return \"data: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates a ProofOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.crypto.ProofOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.crypto.ProofOp} ProofOp\n         */\n\n\n        ProofOp.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.crypto.ProofOp) return object;\n          var message = new $root.tendermint.crypto.ProofOp();\n          if (object.type != null) message.type = String(object.type);\n          if (object.key != null) if (typeof object.key === \"string\") $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);else if (object.key.length) message.key = object.key;\n          if (object.data != null) if (typeof object.data === \"string\") $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;\n          return message;\n        };\n        /**\n         * Creates a plain object from a ProofOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.crypto.ProofOp\n         * @static\n         * @param {tendermint.crypto.ProofOp} message ProofOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ProofOp.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.type = \"\";\n            if (options.bytes === String) object.key = \"\";else {\n              object.key = [];\n              if (options.bytes !== Array) object.key = $util.newBuffer(object.key);\n            }\n            if (options.bytes === String) object.data = \"\";else {\n              object.data = [];\n              if (options.bytes !== Array) object.data = $util.newBuffer(object.data);\n            }\n          }\n\n          if (message.type != null && message.hasOwnProperty(\"type\")) object.type = message.type;\n          if (message.key != null && message.hasOwnProperty(\"key\")) object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n          if (message.data != null && message.hasOwnProperty(\"data\")) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n          return object;\n        };\n        /**\n         * Converts this ProofOp to JSON.\n         * @function toJSON\n         * @memberof tendermint.crypto.ProofOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ProofOp.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ProofOp;\n      }();\n\n      crypto.ProofOps = function () {\n        /**\n         * Properties of a ProofOps.\n         * @memberof tendermint.crypto\n         * @interface IProofOps\n         * @property {Array.<tendermint.crypto.IProofOp>|null} [ops] ProofOps ops\n         */\n\n        /**\n         * Constructs a new ProofOps.\n         * @memberof tendermint.crypto\n         * @classdesc Represents a ProofOps.\n         * @implements IProofOps\n         * @constructor\n         * @param {tendermint.crypto.IProofOps=} [properties] Properties to set\n         */\n        function ProofOps(properties) {\n          this.ops = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ProofOps ops.\n         * @member {Array.<tendermint.crypto.IProofOp>} ops\n         * @memberof tendermint.crypto.ProofOps\n         * @instance\n         */\n\n\n        ProofOps.prototype.ops = $util.emptyArray;\n        /**\n         * Creates a new ProofOps instance using the specified properties.\n         * @function create\n         * @memberof tendermint.crypto.ProofOps\n         * @static\n         * @param {tendermint.crypto.IProofOps=} [properties] Properties to set\n         * @returns {tendermint.crypto.ProofOps} ProofOps instance\n         */\n\n        ProofOps.create = function create(properties) {\n          return new ProofOps(properties);\n        };\n        /**\n         * Encodes the specified ProofOps message. Does not implicitly {@link tendermint.crypto.ProofOps.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.crypto.ProofOps\n         * @static\n         * @param {tendermint.crypto.IProofOps} message ProofOps message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ProofOps.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.ops != null && message.ops.length) for (var i = 0; i < message.ops.length; ++i) {\n            $root.tendermint.crypto.ProofOp.encode(message.ops[i], writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified ProofOps message, length delimited. Does not implicitly {@link tendermint.crypto.ProofOps.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.crypto.ProofOps\n         * @static\n         * @param {tendermint.crypto.IProofOps} message ProofOps message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ProofOps.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ProofOps message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.crypto.ProofOps\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.crypto.ProofOps} ProofOps\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ProofOps.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.crypto.ProofOps();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.ops && message.ops.length)) message.ops = [];\n                message.ops.push($root.tendermint.crypto.ProofOp.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ProofOps message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.crypto.ProofOps\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.crypto.ProofOps} ProofOps\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ProofOps.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ProofOps message.\n         * @function verify\n         * @memberof tendermint.crypto.ProofOps\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ProofOps.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.ops != null && message.hasOwnProperty(\"ops\")) {\n            if (!Array.isArray(message.ops)) return \"ops: array expected\";\n\n            for (var i = 0; i < message.ops.length; ++i) {\n              var error = $root.tendermint.crypto.ProofOp.verify(message.ops[i]);\n              if (error) return \"ops.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a ProofOps message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.crypto.ProofOps\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.crypto.ProofOps} ProofOps\n         */\n\n\n        ProofOps.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.crypto.ProofOps) return object;\n          var message = new $root.tendermint.crypto.ProofOps();\n\n          if (object.ops) {\n            if (!Array.isArray(object.ops)) throw TypeError(\".tendermint.crypto.ProofOps.ops: array expected\");\n            message.ops = [];\n\n            for (var i = 0; i < object.ops.length; ++i) {\n              if (typeof object.ops[i] !== \"object\") throw TypeError(\".tendermint.crypto.ProofOps.ops: object expected\");\n              message.ops[i] = $root.tendermint.crypto.ProofOp.fromObject(object.ops[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a ProofOps message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.crypto.ProofOps\n         * @static\n         * @param {tendermint.crypto.ProofOps} message ProofOps\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ProofOps.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.ops = [];\n\n          if (message.ops && message.ops.length) {\n            object.ops = [];\n\n            for (var j = 0; j < message.ops.length; ++j) {\n              object.ops[j] = $root.tendermint.crypto.ProofOp.toObject(message.ops[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this ProofOps to JSON.\n         * @function toJSON\n         * @memberof tendermint.crypto.ProofOps\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ProofOps.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ProofOps;\n      }();\n\n      return crypto;\n    }();\n\n    tendermint.version = function () {\n      /**\n       * Namespace version.\n       * @memberof tendermint\n       * @namespace\n       */\n      var version = {};\n\n      version.App = function () {\n        /**\n         * Properties of an App.\n         * @memberof tendermint.version\n         * @interface IApp\n         * @property {number|Long|null} [protocol] App protocol\n         * @property {string|null} [software] App software\n         */\n\n        /**\n         * Constructs a new App.\n         * @memberof tendermint.version\n         * @classdesc Represents an App.\n         * @implements IApp\n         * @constructor\n         * @param {tendermint.version.IApp=} [properties] Properties to set\n         */\n        function App(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * App protocol.\n         * @member {number|Long} protocol\n         * @memberof tendermint.version.App\n         * @instance\n         */\n\n\n        App.prototype.protocol = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        /**\n         * App software.\n         * @member {string} software\n         * @memberof tendermint.version.App\n         * @instance\n         */\n\n        App.prototype.software = \"\";\n        /**\n         * Creates a new App instance using the specified properties.\n         * @function create\n         * @memberof tendermint.version.App\n         * @static\n         * @param {tendermint.version.IApp=} [properties] Properties to set\n         * @returns {tendermint.version.App} App instance\n         */\n\n        App.create = function create(properties) {\n          return new App(properties);\n        };\n        /**\n         * Encodes the specified App message. Does not implicitly {@link tendermint.version.App.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.version.App\n         * @static\n         * @param {tendermint.version.IApp} message App message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        App.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).uint64(message.protocol);\n          if (message.software != null && Object.hasOwnProperty.call(message, \"software\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).string(message.software);\n          return writer;\n        };\n        /**\n         * Encodes the specified App message, length delimited. Does not implicitly {@link tendermint.version.App.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.version.App\n         * @static\n         * @param {tendermint.version.IApp} message App message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        App.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an App message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.version.App\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.version.App} App\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        App.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.version.App();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.protocol = reader.uint64();\n                break;\n\n              case 2:\n                message.software = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an App message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.version.App\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.version.App} App\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        App.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an App message.\n         * @function verify\n         * @memberof tendermint.version.App\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        App.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.protocol != null && message.hasOwnProperty(\"protocol\")) if (!$util.isInteger(message.protocol) && !(message.protocol && $util.isInteger(message.protocol.low) && $util.isInteger(message.protocol.high))) return \"protocol: integer|Long expected\";\n          if (message.software != null && message.hasOwnProperty(\"software\")) if (!$util.isString(message.software)) return \"software: string expected\";\n          return null;\n        };\n        /**\n         * Creates an App message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.version.App\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.version.App} App\n         */\n\n\n        App.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.version.App) return object;\n          var message = new $root.tendermint.version.App();\n          if (object.protocol != null) if ($util.Long) (message.protocol = $util.Long.fromValue(object.protocol)).unsigned = true;else if (typeof object.protocol === \"string\") message.protocol = parseInt(object.protocol, 10);else if (typeof object.protocol === \"number\") message.protocol = object.protocol;else if (typeof object.protocol === \"object\") message.protocol = new $util.LongBits(object.protocol.low >>> 0, object.protocol.high >>> 0).toNumber(true);\n          if (object.software != null) message.software = String(object.software);\n          return message;\n        };\n        /**\n         * Creates a plain object from an App message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.version.App\n         * @static\n         * @param {tendermint.version.App} message App\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        App.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.protocol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.protocol = options.longs === String ? \"0\" : 0;\n\n            object.software = \"\";\n          }\n\n          if (message.protocol != null && message.hasOwnProperty(\"protocol\")) if (typeof message.protocol === \"number\") object.protocol = options.longs === String ? String(message.protocol) : message.protocol;else object.protocol = options.longs === String ? $util.Long.prototype.toString.call(message.protocol) : options.longs === Number ? new $util.LongBits(message.protocol.low >>> 0, message.protocol.high >>> 0).toNumber(true) : message.protocol;\n          if (message.software != null && message.hasOwnProperty(\"software\")) object.software = message.software;\n          return object;\n        };\n        /**\n         * Converts this App to JSON.\n         * @function toJSON\n         * @memberof tendermint.version.App\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        App.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return App;\n      }();\n\n      version.Consensus = function () {\n        /**\n         * Properties of a Consensus.\n         * @memberof tendermint.version\n         * @interface IConsensus\n         * @property {number|Long|null} [block] Consensus block\n         * @property {number|Long|null} [app] Consensus app\n         */\n\n        /**\n         * Constructs a new Consensus.\n         * @memberof tendermint.version\n         * @classdesc Represents a Consensus.\n         * @implements IConsensus\n         * @constructor\n         * @param {tendermint.version.IConsensus=} [properties] Properties to set\n         */\n        function Consensus(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Consensus block.\n         * @member {number|Long} block\n         * @memberof tendermint.version.Consensus\n         * @instance\n         */\n\n\n        Consensus.prototype.block = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        /**\n         * Consensus app.\n         * @member {number|Long} app\n         * @memberof tendermint.version.Consensus\n         * @instance\n         */\n\n        Consensus.prototype.app = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        /**\n         * Creates a new Consensus instance using the specified properties.\n         * @function create\n         * @memberof tendermint.version.Consensus\n         * @static\n         * @param {tendermint.version.IConsensus=} [properties] Properties to set\n         * @returns {tendermint.version.Consensus} Consensus instance\n         */\n\n        Consensus.create = function create(properties) {\n          return new Consensus(properties);\n        };\n        /**\n         * Encodes the specified Consensus message. Does not implicitly {@link tendermint.version.Consensus.verify|verify} messages.\n         * @function encode\n         * @memberof tendermint.version.Consensus\n         * @static\n         * @param {tendermint.version.IConsensus} message Consensus message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Consensus.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.block != null && Object.hasOwnProperty.call(message, \"block\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).uint64(message.block);\n          if (message.app != null && Object.hasOwnProperty.call(message, \"app\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).uint64(message.app);\n          return writer;\n        };\n        /**\n         * Encodes the specified Consensus message, length delimited. Does not implicitly {@link tendermint.version.Consensus.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof tendermint.version.Consensus\n         * @static\n         * @param {tendermint.version.IConsensus} message Consensus message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Consensus.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Consensus message from the specified reader or buffer.\n         * @function decode\n         * @memberof tendermint.version.Consensus\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {tendermint.version.Consensus} Consensus\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Consensus.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.tendermint.version.Consensus();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.block = reader.uint64();\n                break;\n\n              case 2:\n                message.app = reader.uint64();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Consensus message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof tendermint.version.Consensus\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {tendermint.version.Consensus} Consensus\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Consensus.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Consensus message.\n         * @function verify\n         * @memberof tendermint.version.Consensus\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Consensus.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.block != null && message.hasOwnProperty(\"block\")) if (!$util.isInteger(message.block) && !(message.block && $util.isInteger(message.block.low) && $util.isInteger(message.block.high))) return \"block: integer|Long expected\";\n          if (message.app != null && message.hasOwnProperty(\"app\")) if (!$util.isInteger(message.app) && !(message.app && $util.isInteger(message.app.low) && $util.isInteger(message.app.high))) return \"app: integer|Long expected\";\n          return null;\n        };\n        /**\n         * Creates a Consensus message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof tendermint.version.Consensus\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {tendermint.version.Consensus} Consensus\n         */\n\n\n        Consensus.fromObject = function fromObject(object) {\n          if (object instanceof $root.tendermint.version.Consensus) return object;\n          var message = new $root.tendermint.version.Consensus();\n          if (object.block != null) if ($util.Long) (message.block = $util.Long.fromValue(object.block)).unsigned = true;else if (typeof object.block === \"string\") message.block = parseInt(object.block, 10);else if (typeof object.block === \"number\") message.block = object.block;else if (typeof object.block === \"object\") message.block = new $util.LongBits(object.block.low >>> 0, object.block.high >>> 0).toNumber(true);\n          if (object.app != null) if ($util.Long) (message.app = $util.Long.fromValue(object.app)).unsigned = true;else if (typeof object.app === \"string\") message.app = parseInt(object.app, 10);else if (typeof object.app === \"number\") message.app = object.app;else if (typeof object.app === \"object\") message.app = new $util.LongBits(object.app.low >>> 0, object.app.high >>> 0).toNumber(true);\n          return message;\n        };\n        /**\n         * Creates a plain object from a Consensus message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof tendermint.version.Consensus\n         * @static\n         * @param {tendermint.version.Consensus} message Consensus\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Consensus.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.block = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.block = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.app = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.app = options.longs === String ? \"0\" : 0;\n          }\n\n          if (message.block != null && message.hasOwnProperty(\"block\")) if (typeof message.block === \"number\") object.block = options.longs === String ? String(message.block) : message.block;else object.block = options.longs === String ? $util.Long.prototype.toString.call(message.block) : options.longs === Number ? new $util.LongBits(message.block.low >>> 0, message.block.high >>> 0).toNumber(true) : message.block;\n          if (message.app != null && message.hasOwnProperty(\"app\")) if (typeof message.app === \"number\") object.app = options.longs === String ? String(message.app) : message.app;else object.app = options.longs === String ? $util.Long.prototype.toString.call(message.app) : options.longs === Number ? new $util.LongBits(message.app.low >>> 0, message.app.high >>> 0).toNumber(true) : message.app;\n          return object;\n        };\n        /**\n         * Converts this Consensus to JSON.\n         * @function toJSON\n         * @memberof tendermint.version.Consensus\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Consensus.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Consensus;\n      }();\n\n      return version;\n    }();\n\n    return tendermint;\n  }();\n\n  $root.cosmos = function () {\n    /**\n     * Namespace cosmos.\n     * @exports cosmos\n     * @namespace\n     */\n    var cosmos = {};\n\n    cosmos.base = function () {\n      /**\n       * Namespace base.\n       * @memberof cosmos\n       * @namespace\n       */\n      var base = {};\n\n      base.abci = function () {\n        /**\n         * Namespace abci.\n         * @memberof cosmos.base\n         * @namespace\n         */\n        var abci = {};\n\n        abci.v1beta1 = function () {\n          /**\n           * Namespace v1beta1.\n           * @memberof cosmos.base.abci\n           * @namespace\n           */\n          var v1beta1 = {};\n\n          v1beta1.TxResponse = function () {\n            /**\n             * Properties of a TxResponse.\n             * @memberof cosmos.base.abci.v1beta1\n             * @interface ITxResponse\n             * @property {number|Long|null} [height] TxResponse height\n             * @property {string|null} [txhash] TxResponse txhash\n             * @property {string|null} [codespace] TxResponse codespace\n             * @property {number|null} [code] TxResponse code\n             * @property {string|null} [data] TxResponse data\n             * @property {string|null} [rawLog] TxResponse rawLog\n             * @property {Array.<cosmos.base.abci.v1beta1.IABCIMessageLog>|null} [logs] TxResponse logs\n             * @property {string|null} [info] TxResponse info\n             * @property {number|Long|null} [gasWanted] TxResponse gasWanted\n             * @property {number|Long|null} [gasUsed] TxResponse gasUsed\n             * @property {google.protobuf.IAny|null} [tx] TxResponse tx\n             * @property {string|null} [timestamp] TxResponse timestamp\n             */\n\n            /**\n             * Constructs a new TxResponse.\n             * @memberof cosmos.base.abci.v1beta1\n             * @classdesc Represents a TxResponse.\n             * @implements ITxResponse\n             * @constructor\n             * @param {cosmos.base.abci.v1beta1.ITxResponse=} [properties] Properties to set\n             */\n            function TxResponse(properties) {\n              this.logs = [];\n              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n              }\n            }\n            /**\n             * TxResponse height.\n             * @member {number|Long} height\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             */\n\n\n            TxResponse.prototype.height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n            /**\n             * TxResponse txhash.\n             * @member {string} txhash\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             */\n\n            TxResponse.prototype.txhash = \"\";\n            /**\n             * TxResponse codespace.\n             * @member {string} codespace\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             */\n\n            TxResponse.prototype.codespace = \"\";\n            /**\n             * TxResponse code.\n             * @member {number} code\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             */\n\n            TxResponse.prototype.code = 0;\n            /**\n             * TxResponse data.\n             * @member {string} data\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             */\n\n            TxResponse.prototype.data = \"\";\n            /**\n             * TxResponse rawLog.\n             * @member {string} rawLog\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             */\n\n            TxResponse.prototype.rawLog = \"\";\n            /**\n             * TxResponse logs.\n             * @member {Array.<cosmos.base.abci.v1beta1.IABCIMessageLog>} logs\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             */\n\n            TxResponse.prototype.logs = $util.emptyArray;\n            /**\n             * TxResponse info.\n             * @member {string} info\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             */\n\n            TxResponse.prototype.info = \"\";\n            /**\n             * TxResponse gasWanted.\n             * @member {number|Long} gasWanted\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             */\n\n            TxResponse.prototype.gasWanted = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n            /**\n             * TxResponse gasUsed.\n             * @member {number|Long} gasUsed\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             */\n\n            TxResponse.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n            /**\n             * TxResponse tx.\n             * @member {google.protobuf.IAny|null|undefined} tx\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             */\n\n            TxResponse.prototype.tx = null;\n            /**\n             * TxResponse timestamp.\n             * @member {string} timestamp\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             */\n\n            TxResponse.prototype.timestamp = \"\";\n            /**\n             * Creates a new TxResponse instance using the specified properties.\n             * @function create\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ITxResponse=} [properties] Properties to set\n             * @returns {cosmos.base.abci.v1beta1.TxResponse} TxResponse instance\n             */\n\n            TxResponse.create = function create(properties) {\n              return new TxResponse(properties);\n            };\n            /**\n             * Encodes the specified TxResponse message. Does not implicitly {@link cosmos.base.abci.v1beta1.TxResponse.verify|verify} messages.\n             * @function encode\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ITxResponse} message TxResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            TxResponse.encode = function encode(message, writer) {\n              if (!writer) writer = $Writer.create();\n              if (message.height != null && Object.hasOwnProperty.call(message, \"height\")) writer.uint32(\n              /* id 1, wireType 0 =*/\n              8).int64(message.height);\n              if (message.txhash != null && Object.hasOwnProperty.call(message, \"txhash\")) writer.uint32(\n              /* id 2, wireType 2 =*/\n              18).string(message.txhash);\n              if (message.codespace != null && Object.hasOwnProperty.call(message, \"codespace\")) writer.uint32(\n              /* id 3, wireType 2 =*/\n              26).string(message.codespace);\n              if (message.code != null && Object.hasOwnProperty.call(message, \"code\")) writer.uint32(\n              /* id 4, wireType 0 =*/\n              32).uint32(message.code);\n              if (message.data != null && Object.hasOwnProperty.call(message, \"data\")) writer.uint32(\n              /* id 5, wireType 2 =*/\n              42).string(message.data);\n              if (message.rawLog != null && Object.hasOwnProperty.call(message, \"rawLog\")) writer.uint32(\n              /* id 6, wireType 2 =*/\n              50).string(message.rawLog);\n              if (message.logs != null && message.logs.length) for (var i = 0; i < message.logs.length; ++i) {\n                $root.cosmos.base.abci.v1beta1.ABCIMessageLog.encode(message.logs[i], writer.uint32(\n                /* id 7, wireType 2 =*/\n                58).fork()).ldelim();\n              }\n              if (message.info != null && Object.hasOwnProperty.call(message, \"info\")) writer.uint32(\n              /* id 8, wireType 2 =*/\n              66).string(message.info);\n              if (message.gasWanted != null && Object.hasOwnProperty.call(message, \"gasWanted\")) writer.uint32(\n              /* id 9, wireType 0 =*/\n              72).int64(message.gasWanted);\n              if (message.gasUsed != null && Object.hasOwnProperty.call(message, \"gasUsed\")) writer.uint32(\n              /* id 10, wireType 0 =*/\n              80).int64(message.gasUsed);\n              if (message.tx != null && Object.hasOwnProperty.call(message, \"tx\")) $root.google.protobuf.Any.encode(message.tx, writer.uint32(\n              /* id 11, wireType 2 =*/\n              90).fork()).ldelim();\n              if (message.timestamp != null && Object.hasOwnProperty.call(message, \"timestamp\")) writer.uint32(\n              /* id 12, wireType 2 =*/\n              98).string(message.timestamp);\n              return writer;\n            };\n            /**\n             * Encodes the specified TxResponse message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.TxResponse.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ITxResponse} message TxResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            TxResponse.encodeDelimited = function encodeDelimited(message, writer) {\n              return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a TxResponse message from the specified reader or buffer.\n             * @function decode\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {cosmos.base.abci.v1beta1.TxResponse} TxResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            TxResponse.decode = function decode(reader, length) {\n              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n              var end = length === undefined ? reader.len : reader.pos + length,\n                  message = new $root.cosmos.base.abci.v1beta1.TxResponse();\n\n              while (reader.pos < end) {\n                var tag = reader.uint32();\n\n                switch (tag >>> 3) {\n                  case 1:\n                    message.height = reader.int64();\n                    break;\n\n                  case 2:\n                    message.txhash = reader.string();\n                    break;\n\n                  case 3:\n                    message.codespace = reader.string();\n                    break;\n\n                  case 4:\n                    message.code = reader.uint32();\n                    break;\n\n                  case 5:\n                    message.data = reader.string();\n                    break;\n\n                  case 6:\n                    message.rawLog = reader.string();\n                    break;\n\n                  case 7:\n                    if (!(message.logs && message.logs.length)) message.logs = [];\n                    message.logs.push($root.cosmos.base.abci.v1beta1.ABCIMessageLog.decode(reader, reader.uint32()));\n                    break;\n\n                  case 8:\n                    message.info = reader.string();\n                    break;\n\n                  case 9:\n                    message.gasWanted = reader.int64();\n                    break;\n\n                  case 10:\n                    message.gasUsed = reader.int64();\n                    break;\n\n                  case 11:\n                    message.tx = $root.google.protobuf.Any.decode(reader, reader.uint32());\n                    break;\n\n                  case 12:\n                    message.timestamp = reader.string();\n                    break;\n\n                  default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Decodes a TxResponse message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {cosmos.base.abci.v1beta1.TxResponse} TxResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            TxResponse.decodeDelimited = function decodeDelimited(reader) {\n              if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n              return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a TxResponse message.\n             * @function verify\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n\n\n            TxResponse.verify = function verify(message) {\n              if (typeof message !== \"object\" || message === null) return \"object expected\";\n              if (message.height != null && message.hasOwnProperty(\"height\")) if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high))) return \"height: integer|Long expected\";\n              if (message.txhash != null && message.hasOwnProperty(\"txhash\")) if (!$util.isString(message.txhash)) return \"txhash: string expected\";\n              if (message.codespace != null && message.hasOwnProperty(\"codespace\")) if (!$util.isString(message.codespace)) return \"codespace: string expected\";\n              if (message.code != null && message.hasOwnProperty(\"code\")) if (!$util.isInteger(message.code)) return \"code: integer expected\";\n              if (message.data != null && message.hasOwnProperty(\"data\")) if (!$util.isString(message.data)) return \"data: string expected\";\n              if (message.rawLog != null && message.hasOwnProperty(\"rawLog\")) if (!$util.isString(message.rawLog)) return \"rawLog: string expected\";\n\n              if (message.logs != null && message.hasOwnProperty(\"logs\")) {\n                if (!Array.isArray(message.logs)) return \"logs: array expected\";\n\n                for (var i = 0; i < message.logs.length; ++i) {\n                  var error = $root.cosmos.base.abci.v1beta1.ABCIMessageLog.verify(message.logs[i]);\n                  if (error) return \"logs.\" + error;\n                }\n              }\n\n              if (message.info != null && message.hasOwnProperty(\"info\")) if (!$util.isString(message.info)) return \"info: string expected\";\n              if (message.gasWanted != null && message.hasOwnProperty(\"gasWanted\")) if (!$util.isInteger(message.gasWanted) && !(message.gasWanted && $util.isInteger(message.gasWanted.low) && $util.isInteger(message.gasWanted.high))) return \"gasWanted: integer|Long expected\";\n              if (message.gasUsed != null && message.hasOwnProperty(\"gasUsed\")) if (!$util.isInteger(message.gasUsed) && !(message.gasUsed && $util.isInteger(message.gasUsed.low) && $util.isInteger(message.gasUsed.high))) return \"gasUsed: integer|Long expected\";\n\n              if (message.tx != null && message.hasOwnProperty(\"tx\")) {\n                var error = $root.google.protobuf.Any.verify(message.tx);\n                if (error) return \"tx.\" + error;\n              }\n\n              if (message.timestamp != null && message.hasOwnProperty(\"timestamp\")) if (!$util.isString(message.timestamp)) return \"timestamp: string expected\";\n              return null;\n            };\n            /**\n             * Creates a TxResponse message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {cosmos.base.abci.v1beta1.TxResponse} TxResponse\n             */\n\n\n            TxResponse.fromObject = function fromObject(object) {\n              if (object instanceof $root.cosmos.base.abci.v1beta1.TxResponse) return object;\n              var message = new $root.cosmos.base.abci.v1beta1.TxResponse();\n              if (object.height != null) if ($util.Long) (message.height = $util.Long.fromValue(object.height)).unsigned = false;else if (typeof object.height === \"string\") message.height = parseInt(object.height, 10);else if (typeof object.height === \"number\") message.height = object.height;else if (typeof object.height === \"object\") message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();\n              if (object.txhash != null) message.txhash = String(object.txhash);\n              if (object.codespace != null) message.codespace = String(object.codespace);\n              if (object.code != null) message.code = object.code >>> 0;\n              if (object.data != null) message.data = String(object.data);\n              if (object.rawLog != null) message.rawLog = String(object.rawLog);\n\n              if (object.logs) {\n                if (!Array.isArray(object.logs)) throw TypeError(\".cosmos.base.abci.v1beta1.TxResponse.logs: array expected\");\n                message.logs = [];\n\n                for (var i = 0; i < object.logs.length; ++i) {\n                  if (typeof object.logs[i] !== \"object\") throw TypeError(\".cosmos.base.abci.v1beta1.TxResponse.logs: object expected\");\n                  message.logs[i] = $root.cosmos.base.abci.v1beta1.ABCIMessageLog.fromObject(object.logs[i]);\n                }\n              }\n\n              if (object.info != null) message.info = String(object.info);\n              if (object.gasWanted != null) if ($util.Long) (message.gasWanted = $util.Long.fromValue(object.gasWanted)).unsigned = false;else if (typeof object.gasWanted === \"string\") message.gasWanted = parseInt(object.gasWanted, 10);else if (typeof object.gasWanted === \"number\") message.gasWanted = object.gasWanted;else if (typeof object.gasWanted === \"object\") message.gasWanted = new $util.LongBits(object.gasWanted.low >>> 0, object.gasWanted.high >>> 0).toNumber();\n              if (object.gasUsed != null) if ($util.Long) (message.gasUsed = $util.Long.fromValue(object.gasUsed)).unsigned = false;else if (typeof object.gasUsed === \"string\") message.gasUsed = parseInt(object.gasUsed, 10);else if (typeof object.gasUsed === \"number\") message.gasUsed = object.gasUsed;else if (typeof object.gasUsed === \"object\") message.gasUsed = new $util.LongBits(object.gasUsed.low >>> 0, object.gasUsed.high >>> 0).toNumber();\n\n              if (object.tx != null) {\n                if (typeof object.tx !== \"object\") throw TypeError(\".cosmos.base.abci.v1beta1.TxResponse.tx: object expected\");\n                message.tx = $root.google.protobuf.Any.fromObject(object.tx);\n              }\n\n              if (object.timestamp != null) message.timestamp = String(object.timestamp);\n              return message;\n            };\n            /**\n             * Creates a plain object from a TxResponse message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @static\n             * @param {cosmos.base.abci.v1beta1.TxResponse} message TxResponse\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n\n\n            TxResponse.toObject = function toObject(message, options) {\n              if (!options) options = {};\n              var object = {};\n              if (options.arrays || options.defaults) object.logs = [];\n\n              if (options.defaults) {\n                if ($util.Long) {\n                  var long = new $util.Long(0, 0, false);\n                  object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else object.height = options.longs === String ? \"0\" : 0;\n\n                object.txhash = \"\";\n                object.codespace = \"\";\n                object.code = 0;\n                object.data = \"\";\n                object.rawLog = \"\";\n                object.info = \"\";\n\n                if ($util.Long) {\n                  var long = new $util.Long(0, 0, false);\n                  object.gasWanted = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else object.gasWanted = options.longs === String ? \"0\" : 0;\n\n                if ($util.Long) {\n                  var long = new $util.Long(0, 0, false);\n                  object.gasUsed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else object.gasUsed = options.longs === String ? \"0\" : 0;\n\n                object.tx = null;\n                object.timestamp = \"\";\n              }\n\n              if (message.height != null && message.hasOwnProperty(\"height\")) if (typeof message.height === \"number\") object.height = options.longs === String ? String(message.height) : message.height;else object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;\n              if (message.txhash != null && message.hasOwnProperty(\"txhash\")) object.txhash = message.txhash;\n              if (message.codespace != null && message.hasOwnProperty(\"codespace\")) object.codespace = message.codespace;\n              if (message.code != null && message.hasOwnProperty(\"code\")) object.code = message.code;\n              if (message.data != null && message.hasOwnProperty(\"data\")) object.data = message.data;\n              if (message.rawLog != null && message.hasOwnProperty(\"rawLog\")) object.rawLog = message.rawLog;\n\n              if (message.logs && message.logs.length) {\n                object.logs = [];\n\n                for (var j = 0; j < message.logs.length; ++j) {\n                  object.logs[j] = $root.cosmos.base.abci.v1beta1.ABCIMessageLog.toObject(message.logs[j], options);\n                }\n              }\n\n              if (message.info != null && message.hasOwnProperty(\"info\")) object.info = message.info;\n              if (message.gasWanted != null && message.hasOwnProperty(\"gasWanted\")) if (typeof message.gasWanted === \"number\") object.gasWanted = options.longs === String ? String(message.gasWanted) : message.gasWanted;else object.gasWanted = options.longs === String ? $util.Long.prototype.toString.call(message.gasWanted) : options.longs === Number ? new $util.LongBits(message.gasWanted.low >>> 0, message.gasWanted.high >>> 0).toNumber() : message.gasWanted;\n              if (message.gasUsed != null && message.hasOwnProperty(\"gasUsed\")) if (typeof message.gasUsed === \"number\") object.gasUsed = options.longs === String ? String(message.gasUsed) : message.gasUsed;else object.gasUsed = options.longs === String ? $util.Long.prototype.toString.call(message.gasUsed) : options.longs === Number ? new $util.LongBits(message.gasUsed.low >>> 0, message.gasUsed.high >>> 0).toNumber() : message.gasUsed;\n              if (message.tx != null && message.hasOwnProperty(\"tx\")) object.tx = $root.google.protobuf.Any.toObject(message.tx, options);\n              if (message.timestamp != null && message.hasOwnProperty(\"timestamp\")) object.timestamp = message.timestamp;\n              return object;\n            };\n            /**\n             * Converts this TxResponse to JSON.\n             * @function toJSON\n             * @memberof cosmos.base.abci.v1beta1.TxResponse\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n\n\n            TxResponse.prototype.toJSON = function toJSON() {\n              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return TxResponse;\n          }();\n\n          v1beta1.ABCIMessageLog = function () {\n            /**\n             * Properties of a ABCIMessageLog.\n             * @memberof cosmos.base.abci.v1beta1\n             * @interface IABCIMessageLog\n             * @property {number|null} [msgIndex] ABCIMessageLog msgIndex\n             * @property {string|null} [log] ABCIMessageLog log\n             * @property {Array.<cosmos.base.abci.v1beta1.IStringEvent>|null} [events] ABCIMessageLog events\n             */\n\n            /**\n             * Constructs a new ABCIMessageLog.\n             * @memberof cosmos.base.abci.v1beta1\n             * @classdesc Represents a ABCIMessageLog.\n             * @implements IABCIMessageLog\n             * @constructor\n             * @param {cosmos.base.abci.v1beta1.IABCIMessageLog=} [properties] Properties to set\n             */\n            function ABCIMessageLog(properties) {\n              this.events = [];\n              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n              }\n            }\n            /**\n             * ABCIMessageLog msgIndex.\n             * @member {number} msgIndex\n             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog\n             * @instance\n             */\n\n\n            ABCIMessageLog.prototype.msgIndex = 0;\n            /**\n             * ABCIMessageLog log.\n             * @member {string} log\n             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog\n             * @instance\n             */\n\n            ABCIMessageLog.prototype.log = \"\";\n            /**\n             * ABCIMessageLog events.\n             * @member {Array.<cosmos.base.abci.v1beta1.IStringEvent>} events\n             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog\n             * @instance\n             */\n\n            ABCIMessageLog.prototype.events = $util.emptyArray;\n            /**\n             * Creates a new ABCIMessageLog instance using the specified properties.\n             * @function create\n             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IABCIMessageLog=} [properties] Properties to set\n             * @returns {cosmos.base.abci.v1beta1.ABCIMessageLog} ABCIMessageLog instance\n             */\n\n            ABCIMessageLog.create = function create(properties) {\n              return new ABCIMessageLog(properties);\n            };\n            /**\n             * Encodes the specified ABCIMessageLog message. Does not implicitly {@link cosmos.base.abci.v1beta1.ABCIMessageLog.verify|verify} messages.\n             * @function encode\n             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IABCIMessageLog} message ABCIMessageLog message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            ABCIMessageLog.encode = function encode(message, writer) {\n              if (!writer) writer = $Writer.create();\n              if (message.msgIndex != null && Object.hasOwnProperty.call(message, \"msgIndex\")) writer.uint32(\n              /* id 1, wireType 0 =*/\n              8).uint32(message.msgIndex);\n              if (message.log != null && Object.hasOwnProperty.call(message, \"log\")) writer.uint32(\n              /* id 2, wireType 2 =*/\n              18).string(message.log);\n              if (message.events != null && message.events.length) for (var i = 0; i < message.events.length; ++i) {\n                $root.cosmos.base.abci.v1beta1.StringEvent.encode(message.events[i], writer.uint32(\n                /* id 3, wireType 2 =*/\n                26).fork()).ldelim();\n              }\n              return writer;\n            };\n            /**\n             * Encodes the specified ABCIMessageLog message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.ABCIMessageLog.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IABCIMessageLog} message ABCIMessageLog message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            ABCIMessageLog.encodeDelimited = function encodeDelimited(message, writer) {\n              return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a ABCIMessageLog message from the specified reader or buffer.\n             * @function decode\n             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {cosmos.base.abci.v1beta1.ABCIMessageLog} ABCIMessageLog\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            ABCIMessageLog.decode = function decode(reader, length) {\n              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n              var end = length === undefined ? reader.len : reader.pos + length,\n                  message = new $root.cosmos.base.abci.v1beta1.ABCIMessageLog();\n\n              while (reader.pos < end) {\n                var tag = reader.uint32();\n\n                switch (tag >>> 3) {\n                  case 1:\n                    message.msgIndex = reader.uint32();\n                    break;\n\n                  case 2:\n                    message.log = reader.string();\n                    break;\n\n                  case 3:\n                    if (!(message.events && message.events.length)) message.events = [];\n                    message.events.push($root.cosmos.base.abci.v1beta1.StringEvent.decode(reader, reader.uint32()));\n                    break;\n\n                  default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Decodes a ABCIMessageLog message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {cosmos.base.abci.v1beta1.ABCIMessageLog} ABCIMessageLog\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            ABCIMessageLog.decodeDelimited = function decodeDelimited(reader) {\n              if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n              return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a ABCIMessageLog message.\n             * @function verify\n             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n\n\n            ABCIMessageLog.verify = function verify(message) {\n              if (typeof message !== \"object\" || message === null) return \"object expected\";\n              if (message.msgIndex != null && message.hasOwnProperty(\"msgIndex\")) if (!$util.isInteger(message.msgIndex)) return \"msgIndex: integer expected\";\n              if (message.log != null && message.hasOwnProperty(\"log\")) if (!$util.isString(message.log)) return \"log: string expected\";\n\n              if (message.events != null && message.hasOwnProperty(\"events\")) {\n                if (!Array.isArray(message.events)) return \"events: array expected\";\n\n                for (var i = 0; i < message.events.length; ++i) {\n                  var error = $root.cosmos.base.abci.v1beta1.StringEvent.verify(message.events[i]);\n                  if (error) return \"events.\" + error;\n                }\n              }\n\n              return null;\n            };\n            /**\n             * Creates a ABCIMessageLog message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {cosmos.base.abci.v1beta1.ABCIMessageLog} ABCIMessageLog\n             */\n\n\n            ABCIMessageLog.fromObject = function fromObject(object) {\n              if (object instanceof $root.cosmos.base.abci.v1beta1.ABCIMessageLog) return object;\n              var message = new $root.cosmos.base.abci.v1beta1.ABCIMessageLog();\n              if (object.msgIndex != null) message.msgIndex = object.msgIndex >>> 0;\n              if (object.log != null) message.log = String(object.log);\n\n              if (object.events) {\n                if (!Array.isArray(object.events)) throw TypeError(\".cosmos.base.abci.v1beta1.ABCIMessageLog.events: array expected\");\n                message.events = [];\n\n                for (var i = 0; i < object.events.length; ++i) {\n                  if (typeof object.events[i] !== \"object\") throw TypeError(\".cosmos.base.abci.v1beta1.ABCIMessageLog.events: object expected\");\n                  message.events[i] = $root.cosmos.base.abci.v1beta1.StringEvent.fromObject(object.events[i]);\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Creates a plain object from a ABCIMessageLog message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ABCIMessageLog} message ABCIMessageLog\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n\n\n            ABCIMessageLog.toObject = function toObject(message, options) {\n              if (!options) options = {};\n              var object = {};\n              if (options.arrays || options.defaults) object.events = [];\n\n              if (options.defaults) {\n                object.msgIndex = 0;\n                object.log = \"\";\n              }\n\n              if (message.msgIndex != null && message.hasOwnProperty(\"msgIndex\")) object.msgIndex = message.msgIndex;\n              if (message.log != null && message.hasOwnProperty(\"log\")) object.log = message.log;\n\n              if (message.events && message.events.length) {\n                object.events = [];\n\n                for (var j = 0; j < message.events.length; ++j) {\n                  object.events[j] = $root.cosmos.base.abci.v1beta1.StringEvent.toObject(message.events[j], options);\n                }\n              }\n\n              return object;\n            };\n            /**\n             * Converts this ABCIMessageLog to JSON.\n             * @function toJSON\n             * @memberof cosmos.base.abci.v1beta1.ABCIMessageLog\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n\n\n            ABCIMessageLog.prototype.toJSON = function toJSON() {\n              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ABCIMessageLog;\n          }();\n\n          v1beta1.StringEvent = function () {\n            /**\n             * Properties of a StringEvent.\n             * @memberof cosmos.base.abci.v1beta1\n             * @interface IStringEvent\n             * @property {string|null} [type] StringEvent type\n             * @property {Array.<cosmos.base.abci.v1beta1.IAttribute>|null} [attributes] StringEvent attributes\n             */\n\n            /**\n             * Constructs a new StringEvent.\n             * @memberof cosmos.base.abci.v1beta1\n             * @classdesc Represents a StringEvent.\n             * @implements IStringEvent\n             * @constructor\n             * @param {cosmos.base.abci.v1beta1.IStringEvent=} [properties] Properties to set\n             */\n            function StringEvent(properties) {\n              this.attributes = [];\n              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n              }\n            }\n            /**\n             * StringEvent type.\n             * @member {string} type\n             * @memberof cosmos.base.abci.v1beta1.StringEvent\n             * @instance\n             */\n\n\n            StringEvent.prototype.type = \"\";\n            /**\n             * StringEvent attributes.\n             * @member {Array.<cosmos.base.abci.v1beta1.IAttribute>} attributes\n             * @memberof cosmos.base.abci.v1beta1.StringEvent\n             * @instance\n             */\n\n            StringEvent.prototype.attributes = $util.emptyArray;\n            /**\n             * Creates a new StringEvent instance using the specified properties.\n             * @function create\n             * @memberof cosmos.base.abci.v1beta1.StringEvent\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IStringEvent=} [properties] Properties to set\n             * @returns {cosmos.base.abci.v1beta1.StringEvent} StringEvent instance\n             */\n\n            StringEvent.create = function create(properties) {\n              return new StringEvent(properties);\n            };\n            /**\n             * Encodes the specified StringEvent message. Does not implicitly {@link cosmos.base.abci.v1beta1.StringEvent.verify|verify} messages.\n             * @function encode\n             * @memberof cosmos.base.abci.v1beta1.StringEvent\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IStringEvent} message StringEvent message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            StringEvent.encode = function encode(message, writer) {\n              if (!writer) writer = $Writer.create();\n              if (message.type != null && Object.hasOwnProperty.call(message, \"type\")) writer.uint32(\n              /* id 1, wireType 2 =*/\n              10).string(message.type);\n              if (message.attributes != null && message.attributes.length) for (var i = 0; i < message.attributes.length; ++i) {\n                $root.cosmos.base.abci.v1beta1.Attribute.encode(message.attributes[i], writer.uint32(\n                /* id 2, wireType 2 =*/\n                18).fork()).ldelim();\n              }\n              return writer;\n            };\n            /**\n             * Encodes the specified StringEvent message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.StringEvent.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.StringEvent\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IStringEvent} message StringEvent message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            StringEvent.encodeDelimited = function encodeDelimited(message, writer) {\n              return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a StringEvent message from the specified reader or buffer.\n             * @function decode\n             * @memberof cosmos.base.abci.v1beta1.StringEvent\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {cosmos.base.abci.v1beta1.StringEvent} StringEvent\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            StringEvent.decode = function decode(reader, length) {\n              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n              var end = length === undefined ? reader.len : reader.pos + length,\n                  message = new $root.cosmos.base.abci.v1beta1.StringEvent();\n\n              while (reader.pos < end) {\n                var tag = reader.uint32();\n\n                switch (tag >>> 3) {\n                  case 1:\n                    message.type = reader.string();\n                    break;\n\n                  case 2:\n                    if (!(message.attributes && message.attributes.length)) message.attributes = [];\n                    message.attributes.push($root.cosmos.base.abci.v1beta1.Attribute.decode(reader, reader.uint32()));\n                    break;\n\n                  default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Decodes a StringEvent message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.StringEvent\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {cosmos.base.abci.v1beta1.StringEvent} StringEvent\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            StringEvent.decodeDelimited = function decodeDelimited(reader) {\n              if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n              return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a StringEvent message.\n             * @function verify\n             * @memberof cosmos.base.abci.v1beta1.StringEvent\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n\n\n            StringEvent.verify = function verify(message) {\n              if (typeof message !== \"object\" || message === null) return \"object expected\";\n              if (message.type != null && message.hasOwnProperty(\"type\")) if (!$util.isString(message.type)) return \"type: string expected\";\n\n              if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                if (!Array.isArray(message.attributes)) return \"attributes: array expected\";\n\n                for (var i = 0; i < message.attributes.length; ++i) {\n                  var error = $root.cosmos.base.abci.v1beta1.Attribute.verify(message.attributes[i]);\n                  if (error) return \"attributes.\" + error;\n                }\n              }\n\n              return null;\n            };\n            /**\n             * Creates a StringEvent message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof cosmos.base.abci.v1beta1.StringEvent\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {cosmos.base.abci.v1beta1.StringEvent} StringEvent\n             */\n\n\n            StringEvent.fromObject = function fromObject(object) {\n              if (object instanceof $root.cosmos.base.abci.v1beta1.StringEvent) return object;\n              var message = new $root.cosmos.base.abci.v1beta1.StringEvent();\n              if (object.type != null) message.type = String(object.type);\n\n              if (object.attributes) {\n                if (!Array.isArray(object.attributes)) throw TypeError(\".cosmos.base.abci.v1beta1.StringEvent.attributes: array expected\");\n                message.attributes = [];\n\n                for (var i = 0; i < object.attributes.length; ++i) {\n                  if (typeof object.attributes[i] !== \"object\") throw TypeError(\".cosmos.base.abci.v1beta1.StringEvent.attributes: object expected\");\n                  message.attributes[i] = $root.cosmos.base.abci.v1beta1.Attribute.fromObject(object.attributes[i]);\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Creates a plain object from a StringEvent message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof cosmos.base.abci.v1beta1.StringEvent\n             * @static\n             * @param {cosmos.base.abci.v1beta1.StringEvent} message StringEvent\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n\n\n            StringEvent.toObject = function toObject(message, options) {\n              if (!options) options = {};\n              var object = {};\n              if (options.arrays || options.defaults) object.attributes = [];\n              if (options.defaults) object.type = \"\";\n              if (message.type != null && message.hasOwnProperty(\"type\")) object.type = message.type;\n\n              if (message.attributes && message.attributes.length) {\n                object.attributes = [];\n\n                for (var j = 0; j < message.attributes.length; ++j) {\n                  object.attributes[j] = $root.cosmos.base.abci.v1beta1.Attribute.toObject(message.attributes[j], options);\n                }\n              }\n\n              return object;\n            };\n            /**\n             * Converts this StringEvent to JSON.\n             * @function toJSON\n             * @memberof cosmos.base.abci.v1beta1.StringEvent\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n\n\n            StringEvent.prototype.toJSON = function toJSON() {\n              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return StringEvent;\n          }();\n\n          v1beta1.Attribute = function () {\n            /**\n             * Properties of an Attribute.\n             * @memberof cosmos.base.abci.v1beta1\n             * @interface IAttribute\n             * @property {string|null} [key] Attribute key\n             * @property {string|null} [value] Attribute value\n             */\n\n            /**\n             * Constructs a new Attribute.\n             * @memberof cosmos.base.abci.v1beta1\n             * @classdesc Represents an Attribute.\n             * @implements IAttribute\n             * @constructor\n             * @param {cosmos.base.abci.v1beta1.IAttribute=} [properties] Properties to set\n             */\n            function Attribute(properties) {\n              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n              }\n            }\n            /**\n             * Attribute key.\n             * @member {string} key\n             * @memberof cosmos.base.abci.v1beta1.Attribute\n             * @instance\n             */\n\n\n            Attribute.prototype.key = \"\";\n            /**\n             * Attribute value.\n             * @member {string} value\n             * @memberof cosmos.base.abci.v1beta1.Attribute\n             * @instance\n             */\n\n            Attribute.prototype.value = \"\";\n            /**\n             * Creates a new Attribute instance using the specified properties.\n             * @function create\n             * @memberof cosmos.base.abci.v1beta1.Attribute\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IAttribute=} [properties] Properties to set\n             * @returns {cosmos.base.abci.v1beta1.Attribute} Attribute instance\n             */\n\n            Attribute.create = function create(properties) {\n              return new Attribute(properties);\n            };\n            /**\n             * Encodes the specified Attribute message. Does not implicitly {@link cosmos.base.abci.v1beta1.Attribute.verify|verify} messages.\n             * @function encode\n             * @memberof cosmos.base.abci.v1beta1.Attribute\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IAttribute} message Attribute message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            Attribute.encode = function encode(message, writer) {\n              if (!writer) writer = $Writer.create();\n              if (message.key != null && Object.hasOwnProperty.call(message, \"key\")) writer.uint32(\n              /* id 1, wireType 2 =*/\n              10).string(message.key);\n              if (message.value != null && Object.hasOwnProperty.call(message, \"value\")) writer.uint32(\n              /* id 2, wireType 2 =*/\n              18).string(message.value);\n              return writer;\n            };\n            /**\n             * Encodes the specified Attribute message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.Attribute.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.Attribute\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IAttribute} message Attribute message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            Attribute.encodeDelimited = function encodeDelimited(message, writer) {\n              return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes an Attribute message from the specified reader or buffer.\n             * @function decode\n             * @memberof cosmos.base.abci.v1beta1.Attribute\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {cosmos.base.abci.v1beta1.Attribute} Attribute\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            Attribute.decode = function decode(reader, length) {\n              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n              var end = length === undefined ? reader.len : reader.pos + length,\n                  message = new $root.cosmos.base.abci.v1beta1.Attribute();\n\n              while (reader.pos < end) {\n                var tag = reader.uint32();\n\n                switch (tag >>> 3) {\n                  case 1:\n                    message.key = reader.string();\n                    break;\n\n                  case 2:\n                    message.value = reader.string();\n                    break;\n\n                  default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Decodes an Attribute message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.Attribute\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {cosmos.base.abci.v1beta1.Attribute} Attribute\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            Attribute.decodeDelimited = function decodeDelimited(reader) {\n              if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n              return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies an Attribute message.\n             * @function verify\n             * @memberof cosmos.base.abci.v1beta1.Attribute\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n\n\n            Attribute.verify = function verify(message) {\n              if (typeof message !== \"object\" || message === null) return \"object expected\";\n              if (message.key != null && message.hasOwnProperty(\"key\")) if (!$util.isString(message.key)) return \"key: string expected\";\n              if (message.value != null && message.hasOwnProperty(\"value\")) if (!$util.isString(message.value)) return \"value: string expected\";\n              return null;\n            };\n            /**\n             * Creates an Attribute message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof cosmos.base.abci.v1beta1.Attribute\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {cosmos.base.abci.v1beta1.Attribute} Attribute\n             */\n\n\n            Attribute.fromObject = function fromObject(object) {\n              if (object instanceof $root.cosmos.base.abci.v1beta1.Attribute) return object;\n              var message = new $root.cosmos.base.abci.v1beta1.Attribute();\n              if (object.key != null) message.key = String(object.key);\n              if (object.value != null) message.value = String(object.value);\n              return message;\n            };\n            /**\n             * Creates a plain object from an Attribute message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof cosmos.base.abci.v1beta1.Attribute\n             * @static\n             * @param {cosmos.base.abci.v1beta1.Attribute} message Attribute\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n\n\n            Attribute.toObject = function toObject(message, options) {\n              if (!options) options = {};\n              var object = {};\n\n              if (options.defaults) {\n                object.key = \"\";\n                object.value = \"\";\n              }\n\n              if (message.key != null && message.hasOwnProperty(\"key\")) object.key = message.key;\n              if (message.value != null && message.hasOwnProperty(\"value\")) object.value = message.value;\n              return object;\n            };\n            /**\n             * Converts this Attribute to JSON.\n             * @function toJSON\n             * @memberof cosmos.base.abci.v1beta1.Attribute\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n\n\n            Attribute.prototype.toJSON = function toJSON() {\n              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Attribute;\n          }();\n\n          v1beta1.GasInfo = function () {\n            /**\n             * Properties of a GasInfo.\n             * @memberof cosmos.base.abci.v1beta1\n             * @interface IGasInfo\n             * @property {number|Long|null} [gasWanted] GasInfo gasWanted\n             * @property {number|Long|null} [gasUsed] GasInfo gasUsed\n             */\n\n            /**\n             * Constructs a new GasInfo.\n             * @memberof cosmos.base.abci.v1beta1\n             * @classdesc Represents a GasInfo.\n             * @implements IGasInfo\n             * @constructor\n             * @param {cosmos.base.abci.v1beta1.IGasInfo=} [properties] Properties to set\n             */\n            function GasInfo(properties) {\n              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n              }\n            }\n            /**\n             * GasInfo gasWanted.\n             * @member {number|Long} gasWanted\n             * @memberof cosmos.base.abci.v1beta1.GasInfo\n             * @instance\n             */\n\n\n            GasInfo.prototype.gasWanted = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n            /**\n             * GasInfo gasUsed.\n             * @member {number|Long} gasUsed\n             * @memberof cosmos.base.abci.v1beta1.GasInfo\n             * @instance\n             */\n\n            GasInfo.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n            /**\n             * Creates a new GasInfo instance using the specified properties.\n             * @function create\n             * @memberof cosmos.base.abci.v1beta1.GasInfo\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IGasInfo=} [properties] Properties to set\n             * @returns {cosmos.base.abci.v1beta1.GasInfo} GasInfo instance\n             */\n\n            GasInfo.create = function create(properties) {\n              return new GasInfo(properties);\n            };\n            /**\n             * Encodes the specified GasInfo message. Does not implicitly {@link cosmos.base.abci.v1beta1.GasInfo.verify|verify} messages.\n             * @function encode\n             * @memberof cosmos.base.abci.v1beta1.GasInfo\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IGasInfo} message GasInfo message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            GasInfo.encode = function encode(message, writer) {\n              if (!writer) writer = $Writer.create();\n              if (message.gasWanted != null && Object.hasOwnProperty.call(message, \"gasWanted\")) writer.uint32(\n              /* id 1, wireType 0 =*/\n              8).uint64(message.gasWanted);\n              if (message.gasUsed != null && Object.hasOwnProperty.call(message, \"gasUsed\")) writer.uint32(\n              /* id 2, wireType 0 =*/\n              16).uint64(message.gasUsed);\n              return writer;\n            };\n            /**\n             * Encodes the specified GasInfo message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.GasInfo.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.GasInfo\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IGasInfo} message GasInfo message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            GasInfo.encodeDelimited = function encodeDelimited(message, writer) {\n              return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a GasInfo message from the specified reader or buffer.\n             * @function decode\n             * @memberof cosmos.base.abci.v1beta1.GasInfo\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {cosmos.base.abci.v1beta1.GasInfo} GasInfo\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            GasInfo.decode = function decode(reader, length) {\n              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n              var end = length === undefined ? reader.len : reader.pos + length,\n                  message = new $root.cosmos.base.abci.v1beta1.GasInfo();\n\n              while (reader.pos < end) {\n                var tag = reader.uint32();\n\n                switch (tag >>> 3) {\n                  case 1:\n                    message.gasWanted = reader.uint64();\n                    break;\n\n                  case 2:\n                    message.gasUsed = reader.uint64();\n                    break;\n\n                  default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Decodes a GasInfo message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.GasInfo\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {cosmos.base.abci.v1beta1.GasInfo} GasInfo\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            GasInfo.decodeDelimited = function decodeDelimited(reader) {\n              if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n              return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a GasInfo message.\n             * @function verify\n             * @memberof cosmos.base.abci.v1beta1.GasInfo\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n\n\n            GasInfo.verify = function verify(message) {\n              if (typeof message !== \"object\" || message === null) return \"object expected\";\n              if (message.gasWanted != null && message.hasOwnProperty(\"gasWanted\")) if (!$util.isInteger(message.gasWanted) && !(message.gasWanted && $util.isInteger(message.gasWanted.low) && $util.isInteger(message.gasWanted.high))) return \"gasWanted: integer|Long expected\";\n              if (message.gasUsed != null && message.hasOwnProperty(\"gasUsed\")) if (!$util.isInteger(message.gasUsed) && !(message.gasUsed && $util.isInteger(message.gasUsed.low) && $util.isInteger(message.gasUsed.high))) return \"gasUsed: integer|Long expected\";\n              return null;\n            };\n            /**\n             * Creates a GasInfo message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof cosmos.base.abci.v1beta1.GasInfo\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {cosmos.base.abci.v1beta1.GasInfo} GasInfo\n             */\n\n\n            GasInfo.fromObject = function fromObject(object) {\n              if (object instanceof $root.cosmos.base.abci.v1beta1.GasInfo) return object;\n              var message = new $root.cosmos.base.abci.v1beta1.GasInfo();\n              if (object.gasWanted != null) if ($util.Long) (message.gasWanted = $util.Long.fromValue(object.gasWanted)).unsigned = true;else if (typeof object.gasWanted === \"string\") message.gasWanted = parseInt(object.gasWanted, 10);else if (typeof object.gasWanted === \"number\") message.gasWanted = object.gasWanted;else if (typeof object.gasWanted === \"object\") message.gasWanted = new $util.LongBits(object.gasWanted.low >>> 0, object.gasWanted.high >>> 0).toNumber(true);\n              if (object.gasUsed != null) if ($util.Long) (message.gasUsed = $util.Long.fromValue(object.gasUsed)).unsigned = true;else if (typeof object.gasUsed === \"string\") message.gasUsed = parseInt(object.gasUsed, 10);else if (typeof object.gasUsed === \"number\") message.gasUsed = object.gasUsed;else if (typeof object.gasUsed === \"object\") message.gasUsed = new $util.LongBits(object.gasUsed.low >>> 0, object.gasUsed.high >>> 0).toNumber(true);\n              return message;\n            };\n            /**\n             * Creates a plain object from a GasInfo message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof cosmos.base.abci.v1beta1.GasInfo\n             * @static\n             * @param {cosmos.base.abci.v1beta1.GasInfo} message GasInfo\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n\n\n            GasInfo.toObject = function toObject(message, options) {\n              if (!options) options = {};\n              var object = {};\n\n              if (options.defaults) {\n                if ($util.Long) {\n                  var long = new $util.Long(0, 0, true);\n                  object.gasWanted = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else object.gasWanted = options.longs === String ? \"0\" : 0;\n\n                if ($util.Long) {\n                  var long = new $util.Long(0, 0, true);\n                  object.gasUsed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else object.gasUsed = options.longs === String ? \"0\" : 0;\n              }\n\n              if (message.gasWanted != null && message.hasOwnProperty(\"gasWanted\")) if (typeof message.gasWanted === \"number\") object.gasWanted = options.longs === String ? String(message.gasWanted) : message.gasWanted;else object.gasWanted = options.longs === String ? $util.Long.prototype.toString.call(message.gasWanted) : options.longs === Number ? new $util.LongBits(message.gasWanted.low >>> 0, message.gasWanted.high >>> 0).toNumber(true) : message.gasWanted;\n              if (message.gasUsed != null && message.hasOwnProperty(\"gasUsed\")) if (typeof message.gasUsed === \"number\") object.gasUsed = options.longs === String ? String(message.gasUsed) : message.gasUsed;else object.gasUsed = options.longs === String ? $util.Long.prototype.toString.call(message.gasUsed) : options.longs === Number ? new $util.LongBits(message.gasUsed.low >>> 0, message.gasUsed.high >>> 0).toNumber(true) : message.gasUsed;\n              return object;\n            };\n            /**\n             * Converts this GasInfo to JSON.\n             * @function toJSON\n             * @memberof cosmos.base.abci.v1beta1.GasInfo\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n\n\n            GasInfo.prototype.toJSON = function toJSON() {\n              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return GasInfo;\n          }();\n\n          v1beta1.Result = function () {\n            /**\n             * Properties of a Result.\n             * @memberof cosmos.base.abci.v1beta1\n             * @interface IResult\n             * @property {Uint8Array|null} [data] Result data\n             * @property {string|null} [log] Result log\n             * @property {Array.<tendermint.abci.IEvent>|null} [events] Result events\n             */\n\n            /**\n             * Constructs a new Result.\n             * @memberof cosmos.base.abci.v1beta1\n             * @classdesc Represents a Result.\n             * @implements IResult\n             * @constructor\n             * @param {cosmos.base.abci.v1beta1.IResult=} [properties] Properties to set\n             */\n            function Result(properties) {\n              this.events = [];\n              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n              }\n            }\n            /**\n             * Result data.\n             * @member {Uint8Array} data\n             * @memberof cosmos.base.abci.v1beta1.Result\n             * @instance\n             */\n\n\n            Result.prototype.data = $util.newBuffer([]);\n            /**\n             * Result log.\n             * @member {string} log\n             * @memberof cosmos.base.abci.v1beta1.Result\n             * @instance\n             */\n\n            Result.prototype.log = \"\";\n            /**\n             * Result events.\n             * @member {Array.<tendermint.abci.IEvent>} events\n             * @memberof cosmos.base.abci.v1beta1.Result\n             * @instance\n             */\n\n            Result.prototype.events = $util.emptyArray;\n            /**\n             * Creates a new Result instance using the specified properties.\n             * @function create\n             * @memberof cosmos.base.abci.v1beta1.Result\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IResult=} [properties] Properties to set\n             * @returns {cosmos.base.abci.v1beta1.Result} Result instance\n             */\n\n            Result.create = function create(properties) {\n              return new Result(properties);\n            };\n            /**\n             * Encodes the specified Result message. Does not implicitly {@link cosmos.base.abci.v1beta1.Result.verify|verify} messages.\n             * @function encode\n             * @memberof cosmos.base.abci.v1beta1.Result\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IResult} message Result message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            Result.encode = function encode(message, writer) {\n              if (!writer) writer = $Writer.create();\n              if (message.data != null && Object.hasOwnProperty.call(message, \"data\")) writer.uint32(\n              /* id 1, wireType 2 =*/\n              10).bytes(message.data);\n              if (message.log != null && Object.hasOwnProperty.call(message, \"log\")) writer.uint32(\n              /* id 2, wireType 2 =*/\n              18).string(message.log);\n              if (message.events != null && message.events.length) for (var i = 0; i < message.events.length; ++i) {\n                $root.tendermint.abci.Event.encode(message.events[i], writer.uint32(\n                /* id 3, wireType 2 =*/\n                26).fork()).ldelim();\n              }\n              return writer;\n            };\n            /**\n             * Encodes the specified Result message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.Result.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.Result\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IResult} message Result message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            Result.encodeDelimited = function encodeDelimited(message, writer) {\n              return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a Result message from the specified reader or buffer.\n             * @function decode\n             * @memberof cosmos.base.abci.v1beta1.Result\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {cosmos.base.abci.v1beta1.Result} Result\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            Result.decode = function decode(reader, length) {\n              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n              var end = length === undefined ? reader.len : reader.pos + length,\n                  message = new $root.cosmos.base.abci.v1beta1.Result();\n\n              while (reader.pos < end) {\n                var tag = reader.uint32();\n\n                switch (tag >>> 3) {\n                  case 1:\n                    message.data = reader.bytes();\n                    break;\n\n                  case 2:\n                    message.log = reader.string();\n                    break;\n\n                  case 3:\n                    if (!(message.events && message.events.length)) message.events = [];\n                    message.events.push($root.tendermint.abci.Event.decode(reader, reader.uint32()));\n                    break;\n\n                  default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Decodes a Result message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.Result\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {cosmos.base.abci.v1beta1.Result} Result\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            Result.decodeDelimited = function decodeDelimited(reader) {\n              if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n              return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a Result message.\n             * @function verify\n             * @memberof cosmos.base.abci.v1beta1.Result\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n\n\n            Result.verify = function verify(message) {\n              if (typeof message !== \"object\" || message === null) return \"object expected\";\n              if (message.data != null && message.hasOwnProperty(\"data\")) if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data))) return \"data: buffer expected\";\n              if (message.log != null && message.hasOwnProperty(\"log\")) if (!$util.isString(message.log)) return \"log: string expected\";\n\n              if (message.events != null && message.hasOwnProperty(\"events\")) {\n                if (!Array.isArray(message.events)) return \"events: array expected\";\n\n                for (var i = 0; i < message.events.length; ++i) {\n                  var error = $root.tendermint.abci.Event.verify(message.events[i]);\n                  if (error) return \"events.\" + error;\n                }\n              }\n\n              return null;\n            };\n            /**\n             * Creates a Result message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof cosmos.base.abci.v1beta1.Result\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {cosmos.base.abci.v1beta1.Result} Result\n             */\n\n\n            Result.fromObject = function fromObject(object) {\n              if (object instanceof $root.cosmos.base.abci.v1beta1.Result) return object;\n              var message = new $root.cosmos.base.abci.v1beta1.Result();\n              if (object.data != null) if (typeof object.data === \"string\") $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;\n              if (object.log != null) message.log = String(object.log);\n\n              if (object.events) {\n                if (!Array.isArray(object.events)) throw TypeError(\".cosmos.base.abci.v1beta1.Result.events: array expected\");\n                message.events = [];\n\n                for (var i = 0; i < object.events.length; ++i) {\n                  if (typeof object.events[i] !== \"object\") throw TypeError(\".cosmos.base.abci.v1beta1.Result.events: object expected\");\n                  message.events[i] = $root.tendermint.abci.Event.fromObject(object.events[i]);\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Creates a plain object from a Result message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof cosmos.base.abci.v1beta1.Result\n             * @static\n             * @param {cosmos.base.abci.v1beta1.Result} message Result\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n\n\n            Result.toObject = function toObject(message, options) {\n              if (!options) options = {};\n              var object = {};\n              if (options.arrays || options.defaults) object.events = [];\n\n              if (options.defaults) {\n                if (options.bytes === String) object.data = \"\";else {\n                  object.data = [];\n                  if (options.bytes !== Array) object.data = $util.newBuffer(object.data);\n                }\n                object.log = \"\";\n              }\n\n              if (message.data != null && message.hasOwnProperty(\"data\")) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n              if (message.log != null && message.hasOwnProperty(\"log\")) object.log = message.log;\n\n              if (message.events && message.events.length) {\n                object.events = [];\n\n                for (var j = 0; j < message.events.length; ++j) {\n                  object.events[j] = $root.tendermint.abci.Event.toObject(message.events[j], options);\n                }\n              }\n\n              return object;\n            };\n            /**\n             * Converts this Result to JSON.\n             * @function toJSON\n             * @memberof cosmos.base.abci.v1beta1.Result\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n\n\n            Result.prototype.toJSON = function toJSON() {\n              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Result;\n          }();\n\n          v1beta1.SimulationResponse = function () {\n            /**\n             * Properties of a SimulationResponse.\n             * @memberof cosmos.base.abci.v1beta1\n             * @interface ISimulationResponse\n             * @property {cosmos.base.abci.v1beta1.IGasInfo|null} [gasInfo] SimulationResponse gasInfo\n             * @property {cosmos.base.abci.v1beta1.IResult|null} [result] SimulationResponse result\n             */\n\n            /**\n             * Constructs a new SimulationResponse.\n             * @memberof cosmos.base.abci.v1beta1\n             * @classdesc Represents a SimulationResponse.\n             * @implements ISimulationResponse\n             * @constructor\n             * @param {cosmos.base.abci.v1beta1.ISimulationResponse=} [properties] Properties to set\n             */\n            function SimulationResponse(properties) {\n              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n              }\n            }\n            /**\n             * SimulationResponse gasInfo.\n             * @member {cosmos.base.abci.v1beta1.IGasInfo|null|undefined} gasInfo\n             * @memberof cosmos.base.abci.v1beta1.SimulationResponse\n             * @instance\n             */\n\n\n            SimulationResponse.prototype.gasInfo = null;\n            /**\n             * SimulationResponse result.\n             * @member {cosmos.base.abci.v1beta1.IResult|null|undefined} result\n             * @memberof cosmos.base.abci.v1beta1.SimulationResponse\n             * @instance\n             */\n\n            SimulationResponse.prototype.result = null;\n            /**\n             * Creates a new SimulationResponse instance using the specified properties.\n             * @function create\n             * @memberof cosmos.base.abci.v1beta1.SimulationResponse\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ISimulationResponse=} [properties] Properties to set\n             * @returns {cosmos.base.abci.v1beta1.SimulationResponse} SimulationResponse instance\n             */\n\n            SimulationResponse.create = function create(properties) {\n              return new SimulationResponse(properties);\n            };\n            /**\n             * Encodes the specified SimulationResponse message. Does not implicitly {@link cosmos.base.abci.v1beta1.SimulationResponse.verify|verify} messages.\n             * @function encode\n             * @memberof cosmos.base.abci.v1beta1.SimulationResponse\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ISimulationResponse} message SimulationResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            SimulationResponse.encode = function encode(message, writer) {\n              if (!writer) writer = $Writer.create();\n              if (message.gasInfo != null && Object.hasOwnProperty.call(message, \"gasInfo\")) $root.cosmos.base.abci.v1beta1.GasInfo.encode(message.gasInfo, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10).fork()).ldelim();\n              if (message.result != null && Object.hasOwnProperty.call(message, \"result\")) $root.cosmos.base.abci.v1beta1.Result.encode(message.result, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18).fork()).ldelim();\n              return writer;\n            };\n            /**\n             * Encodes the specified SimulationResponse message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.SimulationResponse.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.SimulationResponse\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ISimulationResponse} message SimulationResponse message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            SimulationResponse.encodeDelimited = function encodeDelimited(message, writer) {\n              return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a SimulationResponse message from the specified reader or buffer.\n             * @function decode\n             * @memberof cosmos.base.abci.v1beta1.SimulationResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {cosmos.base.abci.v1beta1.SimulationResponse} SimulationResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            SimulationResponse.decode = function decode(reader, length) {\n              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n              var end = length === undefined ? reader.len : reader.pos + length,\n                  message = new $root.cosmos.base.abci.v1beta1.SimulationResponse();\n\n              while (reader.pos < end) {\n                var tag = reader.uint32();\n\n                switch (tag >>> 3) {\n                  case 1:\n                    message.gasInfo = $root.cosmos.base.abci.v1beta1.GasInfo.decode(reader, reader.uint32());\n                    break;\n\n                  case 2:\n                    message.result = $root.cosmos.base.abci.v1beta1.Result.decode(reader, reader.uint32());\n                    break;\n\n                  default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Decodes a SimulationResponse message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.SimulationResponse\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {cosmos.base.abci.v1beta1.SimulationResponse} SimulationResponse\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            SimulationResponse.decodeDelimited = function decodeDelimited(reader) {\n              if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n              return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a SimulationResponse message.\n             * @function verify\n             * @memberof cosmos.base.abci.v1beta1.SimulationResponse\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n\n\n            SimulationResponse.verify = function verify(message) {\n              if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n              if (message.gasInfo != null && message.hasOwnProperty(\"gasInfo\")) {\n                var error = $root.cosmos.base.abci.v1beta1.GasInfo.verify(message.gasInfo);\n                if (error) return \"gasInfo.\" + error;\n              }\n\n              if (message.result != null && message.hasOwnProperty(\"result\")) {\n                var error = $root.cosmos.base.abci.v1beta1.Result.verify(message.result);\n                if (error) return \"result.\" + error;\n              }\n\n              return null;\n            };\n            /**\n             * Creates a SimulationResponse message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof cosmos.base.abci.v1beta1.SimulationResponse\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {cosmos.base.abci.v1beta1.SimulationResponse} SimulationResponse\n             */\n\n\n            SimulationResponse.fromObject = function fromObject(object) {\n              if (object instanceof $root.cosmos.base.abci.v1beta1.SimulationResponse) return object;\n              var message = new $root.cosmos.base.abci.v1beta1.SimulationResponse();\n\n              if (object.gasInfo != null) {\n                if (typeof object.gasInfo !== \"object\") throw TypeError(\".cosmos.base.abci.v1beta1.SimulationResponse.gasInfo: object expected\");\n                message.gasInfo = $root.cosmos.base.abci.v1beta1.GasInfo.fromObject(object.gasInfo);\n              }\n\n              if (object.result != null) {\n                if (typeof object.result !== \"object\") throw TypeError(\".cosmos.base.abci.v1beta1.SimulationResponse.result: object expected\");\n                message.result = $root.cosmos.base.abci.v1beta1.Result.fromObject(object.result);\n              }\n\n              return message;\n            };\n            /**\n             * Creates a plain object from a SimulationResponse message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof cosmos.base.abci.v1beta1.SimulationResponse\n             * @static\n             * @param {cosmos.base.abci.v1beta1.SimulationResponse} message SimulationResponse\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n\n\n            SimulationResponse.toObject = function toObject(message, options) {\n              if (!options) options = {};\n              var object = {};\n\n              if (options.defaults) {\n                object.gasInfo = null;\n                object.result = null;\n              }\n\n              if (message.gasInfo != null && message.hasOwnProperty(\"gasInfo\")) object.gasInfo = $root.cosmos.base.abci.v1beta1.GasInfo.toObject(message.gasInfo, options);\n              if (message.result != null && message.hasOwnProperty(\"result\")) object.result = $root.cosmos.base.abci.v1beta1.Result.toObject(message.result, options);\n              return object;\n            };\n            /**\n             * Converts this SimulationResponse to JSON.\n             * @function toJSON\n             * @memberof cosmos.base.abci.v1beta1.SimulationResponse\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n\n\n            SimulationResponse.prototype.toJSON = function toJSON() {\n              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return SimulationResponse;\n          }();\n\n          v1beta1.MsgData = function () {\n            /**\n             * Properties of a MsgData.\n             * @memberof cosmos.base.abci.v1beta1\n             * @interface IMsgData\n             * @property {string|null} [msgType] MsgData msgType\n             * @property {Uint8Array|null} [data] MsgData data\n             */\n\n            /**\n             * Constructs a new MsgData.\n             * @memberof cosmos.base.abci.v1beta1\n             * @classdesc Represents a MsgData.\n             * @implements IMsgData\n             * @constructor\n             * @param {cosmos.base.abci.v1beta1.IMsgData=} [properties] Properties to set\n             */\n            function MsgData(properties) {\n              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n              }\n            }\n            /**\n             * MsgData msgType.\n             * @member {string} msgType\n             * @memberof cosmos.base.abci.v1beta1.MsgData\n             * @instance\n             */\n\n\n            MsgData.prototype.msgType = \"\";\n            /**\n             * MsgData data.\n             * @member {Uint8Array} data\n             * @memberof cosmos.base.abci.v1beta1.MsgData\n             * @instance\n             */\n\n            MsgData.prototype.data = $util.newBuffer([]);\n            /**\n             * Creates a new MsgData instance using the specified properties.\n             * @function create\n             * @memberof cosmos.base.abci.v1beta1.MsgData\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IMsgData=} [properties] Properties to set\n             * @returns {cosmos.base.abci.v1beta1.MsgData} MsgData instance\n             */\n\n            MsgData.create = function create(properties) {\n              return new MsgData(properties);\n            };\n            /**\n             * Encodes the specified MsgData message. Does not implicitly {@link cosmos.base.abci.v1beta1.MsgData.verify|verify} messages.\n             * @function encode\n             * @memberof cosmos.base.abci.v1beta1.MsgData\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IMsgData} message MsgData message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            MsgData.encode = function encode(message, writer) {\n              if (!writer) writer = $Writer.create();\n              if (message.msgType != null && Object.hasOwnProperty.call(message, \"msgType\")) writer.uint32(\n              /* id 1, wireType 2 =*/\n              10).string(message.msgType);\n              if (message.data != null && Object.hasOwnProperty.call(message, \"data\")) writer.uint32(\n              /* id 2, wireType 2 =*/\n              18).bytes(message.data);\n              return writer;\n            };\n            /**\n             * Encodes the specified MsgData message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.MsgData.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.MsgData\n             * @static\n             * @param {cosmos.base.abci.v1beta1.IMsgData} message MsgData message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            MsgData.encodeDelimited = function encodeDelimited(message, writer) {\n              return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a MsgData message from the specified reader or buffer.\n             * @function decode\n             * @memberof cosmos.base.abci.v1beta1.MsgData\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {cosmos.base.abci.v1beta1.MsgData} MsgData\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            MsgData.decode = function decode(reader, length) {\n              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n              var end = length === undefined ? reader.len : reader.pos + length,\n                  message = new $root.cosmos.base.abci.v1beta1.MsgData();\n\n              while (reader.pos < end) {\n                var tag = reader.uint32();\n\n                switch (tag >>> 3) {\n                  case 1:\n                    message.msgType = reader.string();\n                    break;\n\n                  case 2:\n                    message.data = reader.bytes();\n                    break;\n\n                  default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Decodes a MsgData message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.MsgData\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {cosmos.base.abci.v1beta1.MsgData} MsgData\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            MsgData.decodeDelimited = function decodeDelimited(reader) {\n              if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n              return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a MsgData message.\n             * @function verify\n             * @memberof cosmos.base.abci.v1beta1.MsgData\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n\n\n            MsgData.verify = function verify(message) {\n              if (typeof message !== \"object\" || message === null) return \"object expected\";\n              if (message.msgType != null && message.hasOwnProperty(\"msgType\")) if (!$util.isString(message.msgType)) return \"msgType: string expected\";\n              if (message.data != null && message.hasOwnProperty(\"data\")) if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data))) return \"data: buffer expected\";\n              return null;\n            };\n            /**\n             * Creates a MsgData message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof cosmos.base.abci.v1beta1.MsgData\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {cosmos.base.abci.v1beta1.MsgData} MsgData\n             */\n\n\n            MsgData.fromObject = function fromObject(object) {\n              if (object instanceof $root.cosmos.base.abci.v1beta1.MsgData) return object;\n              var message = new $root.cosmos.base.abci.v1beta1.MsgData();\n              if (object.msgType != null) message.msgType = String(object.msgType);\n              if (object.data != null) if (typeof object.data === \"string\") $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;\n              return message;\n            };\n            /**\n             * Creates a plain object from a MsgData message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof cosmos.base.abci.v1beta1.MsgData\n             * @static\n             * @param {cosmos.base.abci.v1beta1.MsgData} message MsgData\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n\n\n            MsgData.toObject = function toObject(message, options) {\n              if (!options) options = {};\n              var object = {};\n\n              if (options.defaults) {\n                object.msgType = \"\";\n                if (options.bytes === String) object.data = \"\";else {\n                  object.data = [];\n                  if (options.bytes !== Array) object.data = $util.newBuffer(object.data);\n                }\n              }\n\n              if (message.msgType != null && message.hasOwnProperty(\"msgType\")) object.msgType = message.msgType;\n              if (message.data != null && message.hasOwnProperty(\"data\")) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n              return object;\n            };\n            /**\n             * Converts this MsgData to JSON.\n             * @function toJSON\n             * @memberof cosmos.base.abci.v1beta1.MsgData\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n\n\n            MsgData.prototype.toJSON = function toJSON() {\n              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return MsgData;\n          }();\n\n          v1beta1.TxMsgData = function () {\n            /**\n             * Properties of a TxMsgData.\n             * @memberof cosmos.base.abci.v1beta1\n             * @interface ITxMsgData\n             * @property {Array.<cosmos.base.abci.v1beta1.IMsgData>|null} [data] TxMsgData data\n             */\n\n            /**\n             * Constructs a new TxMsgData.\n             * @memberof cosmos.base.abci.v1beta1\n             * @classdesc Represents a TxMsgData.\n             * @implements ITxMsgData\n             * @constructor\n             * @param {cosmos.base.abci.v1beta1.ITxMsgData=} [properties] Properties to set\n             */\n            function TxMsgData(properties) {\n              this.data = [];\n              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n              }\n            }\n            /**\n             * TxMsgData data.\n             * @member {Array.<cosmos.base.abci.v1beta1.IMsgData>} data\n             * @memberof cosmos.base.abci.v1beta1.TxMsgData\n             * @instance\n             */\n\n\n            TxMsgData.prototype.data = $util.emptyArray;\n            /**\n             * Creates a new TxMsgData instance using the specified properties.\n             * @function create\n             * @memberof cosmos.base.abci.v1beta1.TxMsgData\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ITxMsgData=} [properties] Properties to set\n             * @returns {cosmos.base.abci.v1beta1.TxMsgData} TxMsgData instance\n             */\n\n            TxMsgData.create = function create(properties) {\n              return new TxMsgData(properties);\n            };\n            /**\n             * Encodes the specified TxMsgData message. Does not implicitly {@link cosmos.base.abci.v1beta1.TxMsgData.verify|verify} messages.\n             * @function encode\n             * @memberof cosmos.base.abci.v1beta1.TxMsgData\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ITxMsgData} message TxMsgData message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            TxMsgData.encode = function encode(message, writer) {\n              if (!writer) writer = $Writer.create();\n              if (message.data != null && message.data.length) for (var i = 0; i < message.data.length; ++i) {\n                $root.cosmos.base.abci.v1beta1.MsgData.encode(message.data[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10).fork()).ldelim();\n              }\n              return writer;\n            };\n            /**\n             * Encodes the specified TxMsgData message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.TxMsgData.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.TxMsgData\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ITxMsgData} message TxMsgData message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            TxMsgData.encodeDelimited = function encodeDelimited(message, writer) {\n              return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a TxMsgData message from the specified reader or buffer.\n             * @function decode\n             * @memberof cosmos.base.abci.v1beta1.TxMsgData\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {cosmos.base.abci.v1beta1.TxMsgData} TxMsgData\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            TxMsgData.decode = function decode(reader, length) {\n              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n              var end = length === undefined ? reader.len : reader.pos + length,\n                  message = new $root.cosmos.base.abci.v1beta1.TxMsgData();\n\n              while (reader.pos < end) {\n                var tag = reader.uint32();\n\n                switch (tag >>> 3) {\n                  case 1:\n                    if (!(message.data && message.data.length)) message.data = [];\n                    message.data.push($root.cosmos.base.abci.v1beta1.MsgData.decode(reader, reader.uint32()));\n                    break;\n\n                  default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Decodes a TxMsgData message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.TxMsgData\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {cosmos.base.abci.v1beta1.TxMsgData} TxMsgData\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            TxMsgData.decodeDelimited = function decodeDelimited(reader) {\n              if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n              return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a TxMsgData message.\n             * @function verify\n             * @memberof cosmos.base.abci.v1beta1.TxMsgData\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n\n\n            TxMsgData.verify = function verify(message) {\n              if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n              if (message.data != null && message.hasOwnProperty(\"data\")) {\n                if (!Array.isArray(message.data)) return \"data: array expected\";\n\n                for (var i = 0; i < message.data.length; ++i) {\n                  var error = $root.cosmos.base.abci.v1beta1.MsgData.verify(message.data[i]);\n                  if (error) return \"data.\" + error;\n                }\n              }\n\n              return null;\n            };\n            /**\n             * Creates a TxMsgData message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof cosmos.base.abci.v1beta1.TxMsgData\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {cosmos.base.abci.v1beta1.TxMsgData} TxMsgData\n             */\n\n\n            TxMsgData.fromObject = function fromObject(object) {\n              if (object instanceof $root.cosmos.base.abci.v1beta1.TxMsgData) return object;\n              var message = new $root.cosmos.base.abci.v1beta1.TxMsgData();\n\n              if (object.data) {\n                if (!Array.isArray(object.data)) throw TypeError(\".cosmos.base.abci.v1beta1.TxMsgData.data: array expected\");\n                message.data = [];\n\n                for (var i = 0; i < object.data.length; ++i) {\n                  if (typeof object.data[i] !== \"object\") throw TypeError(\".cosmos.base.abci.v1beta1.TxMsgData.data: object expected\");\n                  message.data[i] = $root.cosmos.base.abci.v1beta1.MsgData.fromObject(object.data[i]);\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Creates a plain object from a TxMsgData message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof cosmos.base.abci.v1beta1.TxMsgData\n             * @static\n             * @param {cosmos.base.abci.v1beta1.TxMsgData} message TxMsgData\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n\n\n            TxMsgData.toObject = function toObject(message, options) {\n              if (!options) options = {};\n              var object = {};\n              if (options.arrays || options.defaults) object.data = [];\n\n              if (message.data && message.data.length) {\n                object.data = [];\n\n                for (var j = 0; j < message.data.length; ++j) {\n                  object.data[j] = $root.cosmos.base.abci.v1beta1.MsgData.toObject(message.data[j], options);\n                }\n              }\n\n              return object;\n            };\n            /**\n             * Converts this TxMsgData to JSON.\n             * @function toJSON\n             * @memberof cosmos.base.abci.v1beta1.TxMsgData\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n\n\n            TxMsgData.prototype.toJSON = function toJSON() {\n              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return TxMsgData;\n          }();\n\n          v1beta1.SearchTxsResult = function () {\n            /**\n             * Properties of a SearchTxsResult.\n             * @memberof cosmos.base.abci.v1beta1\n             * @interface ISearchTxsResult\n             * @property {number|Long|null} [totalCount] SearchTxsResult totalCount\n             * @property {number|Long|null} [count] SearchTxsResult count\n             * @property {number|Long|null} [pageNumber] SearchTxsResult pageNumber\n             * @property {number|Long|null} [pageTotal] SearchTxsResult pageTotal\n             * @property {number|Long|null} [limit] SearchTxsResult limit\n             * @property {Array.<cosmos.base.abci.v1beta1.ITxResponse>|null} [txs] SearchTxsResult txs\n             */\n\n            /**\n             * Constructs a new SearchTxsResult.\n             * @memberof cosmos.base.abci.v1beta1\n             * @classdesc Represents a SearchTxsResult.\n             * @implements ISearchTxsResult\n             * @constructor\n             * @param {cosmos.base.abci.v1beta1.ISearchTxsResult=} [properties] Properties to set\n             */\n            function SearchTxsResult(properties) {\n              this.txs = [];\n              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n              }\n            }\n            /**\n             * SearchTxsResult totalCount.\n             * @member {number|Long} totalCount\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @instance\n             */\n\n\n            SearchTxsResult.prototype.totalCount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n            /**\n             * SearchTxsResult count.\n             * @member {number|Long} count\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @instance\n             */\n\n            SearchTxsResult.prototype.count = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n            /**\n             * SearchTxsResult pageNumber.\n             * @member {number|Long} pageNumber\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @instance\n             */\n\n            SearchTxsResult.prototype.pageNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n            /**\n             * SearchTxsResult pageTotal.\n             * @member {number|Long} pageTotal\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @instance\n             */\n\n            SearchTxsResult.prototype.pageTotal = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n            /**\n             * SearchTxsResult limit.\n             * @member {number|Long} limit\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @instance\n             */\n\n            SearchTxsResult.prototype.limit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n            /**\n             * SearchTxsResult txs.\n             * @member {Array.<cosmos.base.abci.v1beta1.ITxResponse>} txs\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @instance\n             */\n\n            SearchTxsResult.prototype.txs = $util.emptyArray;\n            /**\n             * Creates a new SearchTxsResult instance using the specified properties.\n             * @function create\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ISearchTxsResult=} [properties] Properties to set\n             * @returns {cosmos.base.abci.v1beta1.SearchTxsResult} SearchTxsResult instance\n             */\n\n            SearchTxsResult.create = function create(properties) {\n              return new SearchTxsResult(properties);\n            };\n            /**\n             * Encodes the specified SearchTxsResult message. Does not implicitly {@link cosmos.base.abci.v1beta1.SearchTxsResult.verify|verify} messages.\n             * @function encode\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ISearchTxsResult} message SearchTxsResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            SearchTxsResult.encode = function encode(message, writer) {\n              if (!writer) writer = $Writer.create();\n              if (message.totalCount != null && Object.hasOwnProperty.call(message, \"totalCount\")) writer.uint32(\n              /* id 1, wireType 0 =*/\n              8).uint64(message.totalCount);\n              if (message.count != null && Object.hasOwnProperty.call(message, \"count\")) writer.uint32(\n              /* id 2, wireType 0 =*/\n              16).uint64(message.count);\n              if (message.pageNumber != null && Object.hasOwnProperty.call(message, \"pageNumber\")) writer.uint32(\n              /* id 3, wireType 0 =*/\n              24).uint64(message.pageNumber);\n              if (message.pageTotal != null && Object.hasOwnProperty.call(message, \"pageTotal\")) writer.uint32(\n              /* id 4, wireType 0 =*/\n              32).uint64(message.pageTotal);\n              if (message.limit != null && Object.hasOwnProperty.call(message, \"limit\")) writer.uint32(\n              /* id 5, wireType 0 =*/\n              40).uint64(message.limit);\n              if (message.txs != null && message.txs.length) for (var i = 0; i < message.txs.length; ++i) {\n                $root.cosmos.base.abci.v1beta1.TxResponse.encode(message.txs[i], writer.uint32(\n                /* id 6, wireType 2 =*/\n                50).fork()).ldelim();\n              }\n              return writer;\n            };\n            /**\n             * Encodes the specified SearchTxsResult message, length delimited. Does not implicitly {@link cosmos.base.abci.v1beta1.SearchTxsResult.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @static\n             * @param {cosmos.base.abci.v1beta1.ISearchTxsResult} message SearchTxsResult message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n            SearchTxsResult.encodeDelimited = function encodeDelimited(message, writer) {\n              return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a SearchTxsResult message from the specified reader or buffer.\n             * @function decode\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {cosmos.base.abci.v1beta1.SearchTxsResult} SearchTxsResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            SearchTxsResult.decode = function decode(reader, length) {\n              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n              var end = length === undefined ? reader.len : reader.pos + length,\n                  message = new $root.cosmos.base.abci.v1beta1.SearchTxsResult();\n\n              while (reader.pos < end) {\n                var tag = reader.uint32();\n\n                switch (tag >>> 3) {\n                  case 1:\n                    message.totalCount = reader.uint64();\n                    break;\n\n                  case 2:\n                    message.count = reader.uint64();\n                    break;\n\n                  case 3:\n                    message.pageNumber = reader.uint64();\n                    break;\n\n                  case 4:\n                    message.pageTotal = reader.uint64();\n                    break;\n\n                  case 5:\n                    message.limit = reader.uint64();\n                    break;\n\n                  case 6:\n                    if (!(message.txs && message.txs.length)) message.txs = [];\n                    message.txs.push($root.cosmos.base.abci.v1beta1.TxResponse.decode(reader, reader.uint32()));\n                    break;\n\n                  default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Decodes a SearchTxsResult message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {cosmos.base.abci.v1beta1.SearchTxsResult} SearchTxsResult\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n            SearchTxsResult.decodeDelimited = function decodeDelimited(reader) {\n              if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n              return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a SearchTxsResult message.\n             * @function verify\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n\n\n            SearchTxsResult.verify = function verify(message) {\n              if (typeof message !== \"object\" || message === null) return \"object expected\";\n              if (message.totalCount != null && message.hasOwnProperty(\"totalCount\")) if (!$util.isInteger(message.totalCount) && !(message.totalCount && $util.isInteger(message.totalCount.low) && $util.isInteger(message.totalCount.high))) return \"totalCount: integer|Long expected\";\n              if (message.count != null && message.hasOwnProperty(\"count\")) if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high))) return \"count: integer|Long expected\";\n              if (message.pageNumber != null && message.hasOwnProperty(\"pageNumber\")) if (!$util.isInteger(message.pageNumber) && !(message.pageNumber && $util.isInteger(message.pageNumber.low) && $util.isInteger(message.pageNumber.high))) return \"pageNumber: integer|Long expected\";\n              if (message.pageTotal != null && message.hasOwnProperty(\"pageTotal\")) if (!$util.isInteger(message.pageTotal) && !(message.pageTotal && $util.isInteger(message.pageTotal.low) && $util.isInteger(message.pageTotal.high))) return \"pageTotal: integer|Long expected\";\n              if (message.limit != null && message.hasOwnProperty(\"limit\")) if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high))) return \"limit: integer|Long expected\";\n\n              if (message.txs != null && message.hasOwnProperty(\"txs\")) {\n                if (!Array.isArray(message.txs)) return \"txs: array expected\";\n\n                for (var i = 0; i < message.txs.length; ++i) {\n                  var error = $root.cosmos.base.abci.v1beta1.TxResponse.verify(message.txs[i]);\n                  if (error) return \"txs.\" + error;\n                }\n              }\n\n              return null;\n            };\n            /**\n             * Creates a SearchTxsResult message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {cosmos.base.abci.v1beta1.SearchTxsResult} SearchTxsResult\n             */\n\n\n            SearchTxsResult.fromObject = function fromObject(object) {\n              if (object instanceof $root.cosmos.base.abci.v1beta1.SearchTxsResult) return object;\n              var message = new $root.cosmos.base.abci.v1beta1.SearchTxsResult();\n              if (object.totalCount != null) if ($util.Long) (message.totalCount = $util.Long.fromValue(object.totalCount)).unsigned = true;else if (typeof object.totalCount === \"string\") message.totalCount = parseInt(object.totalCount, 10);else if (typeof object.totalCount === \"number\") message.totalCount = object.totalCount;else if (typeof object.totalCount === \"object\") message.totalCount = new $util.LongBits(object.totalCount.low >>> 0, object.totalCount.high >>> 0).toNumber(true);\n              if (object.count != null) if ($util.Long) (message.count = $util.Long.fromValue(object.count)).unsigned = true;else if (typeof object.count === \"string\") message.count = parseInt(object.count, 10);else if (typeof object.count === \"number\") message.count = object.count;else if (typeof object.count === \"object\") message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber(true);\n              if (object.pageNumber != null) if ($util.Long) (message.pageNumber = $util.Long.fromValue(object.pageNumber)).unsigned = true;else if (typeof object.pageNumber === \"string\") message.pageNumber = parseInt(object.pageNumber, 10);else if (typeof object.pageNumber === \"number\") message.pageNumber = object.pageNumber;else if (typeof object.pageNumber === \"object\") message.pageNumber = new $util.LongBits(object.pageNumber.low >>> 0, object.pageNumber.high >>> 0).toNumber(true);\n              if (object.pageTotal != null) if ($util.Long) (message.pageTotal = $util.Long.fromValue(object.pageTotal)).unsigned = true;else if (typeof object.pageTotal === \"string\") message.pageTotal = parseInt(object.pageTotal, 10);else if (typeof object.pageTotal === \"number\") message.pageTotal = object.pageTotal;else if (typeof object.pageTotal === \"object\") message.pageTotal = new $util.LongBits(object.pageTotal.low >>> 0, object.pageTotal.high >>> 0).toNumber(true);\n              if (object.limit != null) if ($util.Long) (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;else if (typeof object.limit === \"string\") message.limit = parseInt(object.limit, 10);else if (typeof object.limit === \"number\") message.limit = object.limit;else if (typeof object.limit === \"object\") message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);\n\n              if (object.txs) {\n                if (!Array.isArray(object.txs)) throw TypeError(\".cosmos.base.abci.v1beta1.SearchTxsResult.txs: array expected\");\n                message.txs = [];\n\n                for (var i = 0; i < object.txs.length; ++i) {\n                  if (typeof object.txs[i] !== \"object\") throw TypeError(\".cosmos.base.abci.v1beta1.SearchTxsResult.txs: object expected\");\n                  message.txs[i] = $root.cosmos.base.abci.v1beta1.TxResponse.fromObject(object.txs[i]);\n                }\n              }\n\n              return message;\n            };\n            /**\n             * Creates a plain object from a SearchTxsResult message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @static\n             * @param {cosmos.base.abci.v1beta1.SearchTxsResult} message SearchTxsResult\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n\n\n            SearchTxsResult.toObject = function toObject(message, options) {\n              if (!options) options = {};\n              var object = {};\n              if (options.arrays || options.defaults) object.txs = [];\n\n              if (options.defaults) {\n                if ($util.Long) {\n                  var long = new $util.Long(0, 0, true);\n                  object.totalCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else object.totalCount = options.longs === String ? \"0\" : 0;\n\n                if ($util.Long) {\n                  var long = new $util.Long(0, 0, true);\n                  object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else object.count = options.longs === String ? \"0\" : 0;\n\n                if ($util.Long) {\n                  var long = new $util.Long(0, 0, true);\n                  object.pageNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else object.pageNumber = options.longs === String ? \"0\" : 0;\n\n                if ($util.Long) {\n                  var long = new $util.Long(0, 0, true);\n                  object.pageTotal = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else object.pageTotal = options.longs === String ? \"0\" : 0;\n\n                if ($util.Long) {\n                  var long = new $util.Long(0, 0, true);\n                  object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else object.limit = options.longs === String ? \"0\" : 0;\n              }\n\n              if (message.totalCount != null && message.hasOwnProperty(\"totalCount\")) if (typeof message.totalCount === \"number\") object.totalCount = options.longs === String ? String(message.totalCount) : message.totalCount;else object.totalCount = options.longs === String ? $util.Long.prototype.toString.call(message.totalCount) : options.longs === Number ? new $util.LongBits(message.totalCount.low >>> 0, message.totalCount.high >>> 0).toNumber(true) : message.totalCount;\n              if (message.count != null && message.hasOwnProperty(\"count\")) if (typeof message.count === \"number\") object.count = options.longs === String ? String(message.count) : message.count;else object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber(true) : message.count;\n              if (message.pageNumber != null && message.hasOwnProperty(\"pageNumber\")) if (typeof message.pageNumber === \"number\") object.pageNumber = options.longs === String ? String(message.pageNumber) : message.pageNumber;else object.pageNumber = options.longs === String ? $util.Long.prototype.toString.call(message.pageNumber) : options.longs === Number ? new $util.LongBits(message.pageNumber.low >>> 0, message.pageNumber.high >>> 0).toNumber(true) : message.pageNumber;\n              if (message.pageTotal != null && message.hasOwnProperty(\"pageTotal\")) if (typeof message.pageTotal === \"number\") object.pageTotal = options.longs === String ? String(message.pageTotal) : message.pageTotal;else object.pageTotal = options.longs === String ? $util.Long.prototype.toString.call(message.pageTotal) : options.longs === Number ? new $util.LongBits(message.pageTotal.low >>> 0, message.pageTotal.high >>> 0).toNumber(true) : message.pageTotal;\n              if (message.limit != null && message.hasOwnProperty(\"limit\")) if (typeof message.limit === \"number\") object.limit = options.longs === String ? String(message.limit) : message.limit;else object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;\n\n              if (message.txs && message.txs.length) {\n                object.txs = [];\n\n                for (var j = 0; j < message.txs.length; ++j) {\n                  object.txs[j] = $root.cosmos.base.abci.v1beta1.TxResponse.toObject(message.txs[j], options);\n                }\n              }\n\n              return object;\n            };\n            /**\n             * Converts this SearchTxsResult to JSON.\n             * @function toJSON\n             * @memberof cosmos.base.abci.v1beta1.SearchTxsResult\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n\n\n            SearchTxsResult.prototype.toJSON = function toJSON() {\n              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return SearchTxsResult;\n          }();\n\n          return v1beta1;\n        }();\n\n        return abci;\n      }();\n\n      return base;\n    }();\n\n    return cosmos;\n  }();\n\n  $root.gogoproto = function () {\n    /**\n     * Namespace gogoproto.\n     * @exports gogoproto\n     * @namespace\n     */\n    var gogoproto = {};\n    return gogoproto;\n  }();\n\n  $root.google = function () {\n    /**\n     * Namespace google.\n     * @exports google\n     * @namespace\n     */\n    var google = {};\n\n    google.protobuf = function () {\n      /**\n       * Namespace protobuf.\n       * @memberof google\n       * @namespace\n       */\n      var protobuf = {};\n\n      protobuf.Any = function () {\n        /**\n         * Properties of an Any.\n         * @memberof google.protobuf\n         * @interface IAny\n         * @property {string|null} [type_url] Any type_url\n         * @property {Uint8Array|null} [value] Any value\n         */\n\n        /**\n         * Constructs a new Any.\n         * @memberof google.protobuf\n         * @classdesc Represents an Any.\n         * @implements IAny\n         * @constructor\n         * @param {google.protobuf.IAny=} [properties] Properties to set\n         */\n        function Any(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Any type_url.\n         * @member {string} type_url\n         * @memberof google.protobuf.Any\n         * @instance\n         */\n\n\n        Any.prototype.type_url = \"\";\n        /**\n         * Any value.\n         * @member {Uint8Array} value\n         * @memberof google.protobuf.Any\n         * @instance\n         */\n\n        Any.prototype.value = $util.newBuffer([]);\n        /**\n         * Creates a new Any instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.Any\n         * @static\n         * @param {google.protobuf.IAny=} [properties] Properties to set\n         * @returns {google.protobuf.Any} Any instance\n         */\n\n        Any.create = function create(properties) {\n          return new Any(properties);\n        };\n        /**\n         * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.Any\n         * @static\n         * @param {google.protobuf.IAny} message Any message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Any.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.type_url != null && Object.hasOwnProperty.call(message, \"type_url\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.type_url);\n          if (message.value != null && Object.hasOwnProperty.call(message, \"value\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).bytes(message.value);\n          return writer;\n        };\n        /**\n         * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.Any\n         * @static\n         * @param {google.protobuf.IAny} message Any message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Any.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an Any message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.Any\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.Any} Any\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Any.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.Any();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.type_url = reader.string();\n                break;\n\n              case 2:\n                message.value = reader.bytes();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an Any message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.Any\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.Any} Any\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Any.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an Any message.\n         * @function verify\n         * @memberof google.protobuf.Any\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Any.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.type_url != null && message.hasOwnProperty(\"type_url\")) if (!$util.isString(message.type_url)) return \"type_url: string expected\";\n          if (message.value != null && message.hasOwnProperty(\"value\")) if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value))) return \"value: buffer expected\";\n          return null;\n        };\n        /**\n         * Creates an Any message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.Any\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.Any} Any\n         */\n\n\n        Any.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.Any) return object;\n          var message = new $root.google.protobuf.Any();\n          if (object.type_url != null) message.type_url = String(object.type_url);\n          if (object.value != null) if (typeof object.value === \"string\") $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);else if (object.value.length) message.value = object.value;\n          return message;\n        };\n        /**\n         * Creates a plain object from an Any message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.Any\n         * @static\n         * @param {google.protobuf.Any} message Any\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Any.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.type_url = \"\";\n            if (options.bytes === String) object.value = \"\";else {\n              object.value = [];\n              if (options.bytes !== Array) object.value = $util.newBuffer(object.value);\n            }\n          }\n\n          if (message.type_url != null && message.hasOwnProperty(\"type_url\")) object.type_url = message.type_url;\n          if (message.value != null && message.hasOwnProperty(\"value\")) object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n          return object;\n        };\n        /**\n         * Converts this Any to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.Any\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Any.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Any;\n      }();\n\n      protobuf.FileDescriptorSet = function () {\n        /**\n         * Properties of a FileDescriptorSet.\n         * @memberof google.protobuf\n         * @interface IFileDescriptorSet\n         * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file\n         */\n\n        /**\n         * Constructs a new FileDescriptorSet.\n         * @memberof google.protobuf\n         * @classdesc Represents a FileDescriptorSet.\n         * @implements IFileDescriptorSet\n         * @constructor\n         * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set\n         */\n        function FileDescriptorSet(properties) {\n          this.file = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * FileDescriptorSet file.\n         * @member {Array.<google.protobuf.IFileDescriptorProto>} file\n         * @memberof google.protobuf.FileDescriptorSet\n         * @instance\n         */\n\n\n        FileDescriptorSet.prototype.file = $util.emptyArray;\n        /**\n         * Creates a new FileDescriptorSet instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.FileDescriptorSet\n         * @static\n         * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set\n         * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance\n         */\n\n        FileDescriptorSet.create = function create(properties) {\n          return new FileDescriptorSet(properties);\n        };\n        /**\n         * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.FileDescriptorSet\n         * @static\n         * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        FileDescriptorSet.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.file != null && message.file.length) for (var i = 0; i < message.file.length; ++i) {\n            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.FileDescriptorSet\n         * @static\n         * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a FileDescriptorSet message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.FileDescriptorSet\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        FileDescriptorSet.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.FileDescriptorSet();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.file && message.file.length)) message.file = [];\n                message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.FileDescriptorSet\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a FileDescriptorSet message.\n         * @function verify\n         * @memberof google.protobuf.FileDescriptorSet\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        FileDescriptorSet.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.file != null && message.hasOwnProperty(\"file\")) {\n            if (!Array.isArray(message.file)) return \"file: array expected\";\n\n            for (var i = 0; i < message.file.length; ++i) {\n              var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);\n              if (error) return \"file.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.FileDescriptorSet\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet\n         */\n\n\n        FileDescriptorSet.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.FileDescriptorSet) return object;\n          var message = new $root.google.protobuf.FileDescriptorSet();\n\n          if (object.file) {\n            if (!Array.isArray(object.file)) throw TypeError(\".google.protobuf.FileDescriptorSet.file: array expected\");\n            message.file = [];\n\n            for (var i = 0; i < object.file.length; ++i) {\n              if (typeof object.file[i] !== \"object\") throw TypeError(\".google.protobuf.FileDescriptorSet.file: object expected\");\n              message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.FileDescriptorSet\n         * @static\n         * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        FileDescriptorSet.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.file = [];\n\n          if (message.file && message.file.length) {\n            object.file = [];\n\n            for (var j = 0; j < message.file.length; ++j) {\n              object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this FileDescriptorSet to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.FileDescriptorSet\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        FileDescriptorSet.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return FileDescriptorSet;\n      }();\n\n      protobuf.FileDescriptorProto = function () {\n        /**\n         * Properties of a FileDescriptorProto.\n         * @memberof google.protobuf\n         * @interface IFileDescriptorProto\n         * @property {string|null} [name] FileDescriptorProto name\n         * @property {string|null} [\"package\"] FileDescriptorProto package\n         * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency\n         * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency\n         * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency\n         * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType\n         * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType\n         * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service\n         * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension\n         * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options\n         * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo\n         * @property {string|null} [syntax] FileDescriptorProto syntax\n         */\n\n        /**\n         * Constructs a new FileDescriptorProto.\n         * @memberof google.protobuf\n         * @classdesc Represents a FileDescriptorProto.\n         * @implements IFileDescriptorProto\n         * @constructor\n         * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set\n         */\n        function FileDescriptorProto(properties) {\n          this.dependency = [];\n          this.publicDependency = [];\n          this.weakDependency = [];\n          this.messageType = [];\n          this.enumType = [];\n          this.service = [];\n          this.extension = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * FileDescriptorProto name.\n         * @member {string} name\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         */\n\n\n        FileDescriptorProto.prototype.name = \"\";\n        /**\n         * FileDescriptorProto package.\n         * @member {string} package\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         */\n\n        FileDescriptorProto.prototype[\"package\"] = \"\";\n        /**\n         * FileDescriptorProto dependency.\n         * @member {Array.<string>} dependency\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         */\n\n        FileDescriptorProto.prototype.dependency = $util.emptyArray;\n        /**\n         * FileDescriptorProto publicDependency.\n         * @member {Array.<number>} publicDependency\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         */\n\n        FileDescriptorProto.prototype.publicDependency = $util.emptyArray;\n        /**\n         * FileDescriptorProto weakDependency.\n         * @member {Array.<number>} weakDependency\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         */\n\n        FileDescriptorProto.prototype.weakDependency = $util.emptyArray;\n        /**\n         * FileDescriptorProto messageType.\n         * @member {Array.<google.protobuf.IDescriptorProto>} messageType\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         */\n\n        FileDescriptorProto.prototype.messageType = $util.emptyArray;\n        /**\n         * FileDescriptorProto enumType.\n         * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         */\n\n        FileDescriptorProto.prototype.enumType = $util.emptyArray;\n        /**\n         * FileDescriptorProto service.\n         * @member {Array.<google.protobuf.IServiceDescriptorProto>} service\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         */\n\n        FileDescriptorProto.prototype.service = $util.emptyArray;\n        /**\n         * FileDescriptorProto extension.\n         * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         */\n\n        FileDescriptorProto.prototype.extension = $util.emptyArray;\n        /**\n         * FileDescriptorProto options.\n         * @member {google.protobuf.IFileOptions|null|undefined} options\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         */\n\n        FileDescriptorProto.prototype.options = null;\n        /**\n         * FileDescriptorProto sourceCodeInfo.\n         * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         */\n\n        FileDescriptorProto.prototype.sourceCodeInfo = null;\n        /**\n         * FileDescriptorProto syntax.\n         * @member {string} syntax\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         */\n\n        FileDescriptorProto.prototype.syntax = \"\";\n        /**\n         * Creates a new FileDescriptorProto instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.FileDescriptorProto\n         * @static\n         * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set\n         * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance\n         */\n\n        FileDescriptorProto.create = function create(properties) {\n          return new FileDescriptorProto(properties);\n        };\n        /**\n         * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.FileDescriptorProto\n         * @static\n         * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        FileDescriptorProto.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.name);\n          if (message[\"package\"] != null && Object.hasOwnProperty.call(message, \"package\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).string(message[\"package\"]);\n          if (message.dependency != null && message.dependency.length) for (var i = 0; i < message.dependency.length; ++i) {\n            writer.uint32(\n            /* id 3, wireType 2 =*/\n            26).string(message.dependency[i]);\n          }\n          if (message.messageType != null && message.messageType.length) for (var i = 0; i < message.messageType.length; ++i) {\n            $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(\n            /* id 4, wireType 2 =*/\n            34).fork()).ldelim();\n          }\n          if (message.enumType != null && message.enumType.length) for (var i = 0; i < message.enumType.length; ++i) {\n            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(\n            /* id 5, wireType 2 =*/\n            42).fork()).ldelim();\n          }\n          if (message.service != null && message.service.length) for (var i = 0; i < message.service.length; ++i) {\n            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(\n            /* id 6, wireType 2 =*/\n            50).fork()).ldelim();\n          }\n          if (message.extension != null && message.extension.length) for (var i = 0; i < message.extension.length; ++i) {\n            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(\n            /* id 7, wireType 2 =*/\n            58).fork()).ldelim();\n          }\n          if (message.options != null && Object.hasOwnProperty.call(message, \"options\")) $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(\n          /* id 8, wireType 2 =*/\n          66).fork()).ldelim();\n          if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, \"sourceCodeInfo\")) $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(\n          /* id 9, wireType 2 =*/\n          74).fork()).ldelim();\n          if (message.publicDependency != null && message.publicDependency.length) for (var i = 0; i < message.publicDependency.length; ++i) {\n            writer.uint32(\n            /* id 10, wireType 0 =*/\n            80).int32(message.publicDependency[i]);\n          }\n          if (message.weakDependency != null && message.weakDependency.length) for (var i = 0; i < message.weakDependency.length; ++i) {\n            writer.uint32(\n            /* id 11, wireType 0 =*/\n            88).int32(message.weakDependency[i]);\n          }\n          if (message.syntax != null && Object.hasOwnProperty.call(message, \"syntax\")) writer.uint32(\n          /* id 12, wireType 2 =*/\n          98).string(message.syntax);\n          return writer;\n        };\n        /**\n         * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.FileDescriptorProto\n         * @static\n         * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a FileDescriptorProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.FileDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        FileDescriptorProto.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.FileDescriptorProto();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.name = reader.string();\n                break;\n\n              case 2:\n                message[\"package\"] = reader.string();\n                break;\n\n              case 3:\n                if (!(message.dependency && message.dependency.length)) message.dependency = [];\n                message.dependency.push(reader.string());\n                break;\n\n              case 10:\n                if (!(message.publicDependency && message.publicDependency.length)) message.publicDependency = [];\n\n                if ((tag & 7) === 2) {\n                  var end2 = reader.uint32() + reader.pos;\n\n                  while (reader.pos < end2) {\n                    message.publicDependency.push(reader.int32());\n                  }\n                } else message.publicDependency.push(reader.int32());\n\n                break;\n\n              case 11:\n                if (!(message.weakDependency && message.weakDependency.length)) message.weakDependency = [];\n\n                if ((tag & 7) === 2) {\n                  var end2 = reader.uint32() + reader.pos;\n\n                  while (reader.pos < end2) {\n                    message.weakDependency.push(reader.int32());\n                  }\n                } else message.weakDependency.push(reader.int32());\n\n                break;\n\n              case 4:\n                if (!(message.messageType && message.messageType.length)) message.messageType = [];\n                message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));\n                break;\n\n              case 5:\n                if (!(message.enumType && message.enumType.length)) message.enumType = [];\n                message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));\n                break;\n\n              case 6:\n                if (!(message.service && message.service.length)) message.service = [];\n                message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));\n                break;\n\n              case 7:\n                if (!(message.extension && message.extension.length)) message.extension = [];\n                message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n                break;\n\n              case 8:\n                message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());\n                break;\n\n              case 9:\n                message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());\n                break;\n\n              case 12:\n                message.syntax = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.FileDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a FileDescriptorProto message.\n         * @function verify\n         * @memberof google.protobuf.FileDescriptorProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        FileDescriptorProto.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.name != null && message.hasOwnProperty(\"name\")) if (!$util.isString(message.name)) return \"name: string expected\";\n          if (message[\"package\"] != null && message.hasOwnProperty(\"package\")) if (!$util.isString(message[\"package\"])) return \"package: string expected\";\n\n          if (message.dependency != null && message.hasOwnProperty(\"dependency\")) {\n            if (!Array.isArray(message.dependency)) return \"dependency: array expected\";\n\n            for (var i = 0; i < message.dependency.length; ++i) {\n              if (!$util.isString(message.dependency[i])) return \"dependency: string[] expected\";\n            }\n          }\n\n          if (message.publicDependency != null && message.hasOwnProperty(\"publicDependency\")) {\n            if (!Array.isArray(message.publicDependency)) return \"publicDependency: array expected\";\n\n            for (var i = 0; i < message.publicDependency.length; ++i) {\n              if (!$util.isInteger(message.publicDependency[i])) return \"publicDependency: integer[] expected\";\n            }\n          }\n\n          if (message.weakDependency != null && message.hasOwnProperty(\"weakDependency\")) {\n            if (!Array.isArray(message.weakDependency)) return \"weakDependency: array expected\";\n\n            for (var i = 0; i < message.weakDependency.length; ++i) {\n              if (!$util.isInteger(message.weakDependency[i])) return \"weakDependency: integer[] expected\";\n            }\n          }\n\n          if (message.messageType != null && message.hasOwnProperty(\"messageType\")) {\n            if (!Array.isArray(message.messageType)) return \"messageType: array expected\";\n\n            for (var i = 0; i < message.messageType.length; ++i) {\n              var error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);\n              if (error) return \"messageType.\" + error;\n            }\n          }\n\n          if (message.enumType != null && message.hasOwnProperty(\"enumType\")) {\n            if (!Array.isArray(message.enumType)) return \"enumType: array expected\";\n\n            for (var i = 0; i < message.enumType.length; ++i) {\n              var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);\n              if (error) return \"enumType.\" + error;\n            }\n          }\n\n          if (message.service != null && message.hasOwnProperty(\"service\")) {\n            if (!Array.isArray(message.service)) return \"service: array expected\";\n\n            for (var i = 0; i < message.service.length; ++i) {\n              var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);\n              if (error) return \"service.\" + error;\n            }\n          }\n\n          if (message.extension != null && message.hasOwnProperty(\"extension\")) {\n            if (!Array.isArray(message.extension)) return \"extension: array expected\";\n\n            for (var i = 0; i < message.extension.length; ++i) {\n              var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);\n              if (error) return \"extension.\" + error;\n            }\n          }\n\n          if (message.options != null && message.hasOwnProperty(\"options\")) {\n            var error = $root.google.protobuf.FileOptions.verify(message.options);\n            if (error) return \"options.\" + error;\n          }\n\n          if (message.sourceCodeInfo != null && message.hasOwnProperty(\"sourceCodeInfo\")) {\n            var error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);\n            if (error) return \"sourceCodeInfo.\" + error;\n          }\n\n          if (message.syntax != null && message.hasOwnProperty(\"syntax\")) if (!$util.isString(message.syntax)) return \"syntax: string expected\";\n          return null;\n        };\n        /**\n         * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.FileDescriptorProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto\n         */\n\n\n        FileDescriptorProto.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.FileDescriptorProto) return object;\n          var message = new $root.google.protobuf.FileDescriptorProto();\n          if (object.name != null) message.name = String(object.name);\n          if (object[\"package\"] != null) message[\"package\"] = String(object[\"package\"]);\n\n          if (object.dependency) {\n            if (!Array.isArray(object.dependency)) throw TypeError(\".google.protobuf.FileDescriptorProto.dependency: array expected\");\n            message.dependency = [];\n\n            for (var i = 0; i < object.dependency.length; ++i) {\n              message.dependency[i] = String(object.dependency[i]);\n            }\n          }\n\n          if (object.publicDependency) {\n            if (!Array.isArray(object.publicDependency)) throw TypeError(\".google.protobuf.FileDescriptorProto.publicDependency: array expected\");\n            message.publicDependency = [];\n\n            for (var i = 0; i < object.publicDependency.length; ++i) {\n              message.publicDependency[i] = object.publicDependency[i] | 0;\n            }\n          }\n\n          if (object.weakDependency) {\n            if (!Array.isArray(object.weakDependency)) throw TypeError(\".google.protobuf.FileDescriptorProto.weakDependency: array expected\");\n            message.weakDependency = [];\n\n            for (var i = 0; i < object.weakDependency.length; ++i) {\n              message.weakDependency[i] = object.weakDependency[i] | 0;\n            }\n          }\n\n          if (object.messageType) {\n            if (!Array.isArray(object.messageType)) throw TypeError(\".google.protobuf.FileDescriptorProto.messageType: array expected\");\n            message.messageType = [];\n\n            for (var i = 0; i < object.messageType.length; ++i) {\n              if (typeof object.messageType[i] !== \"object\") throw TypeError(\".google.protobuf.FileDescriptorProto.messageType: object expected\");\n              message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);\n            }\n          }\n\n          if (object.enumType) {\n            if (!Array.isArray(object.enumType)) throw TypeError(\".google.protobuf.FileDescriptorProto.enumType: array expected\");\n            message.enumType = [];\n\n            for (var i = 0; i < object.enumType.length; ++i) {\n              if (typeof object.enumType[i] !== \"object\") throw TypeError(\".google.protobuf.FileDescriptorProto.enumType: object expected\");\n              message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);\n            }\n          }\n\n          if (object.service) {\n            if (!Array.isArray(object.service)) throw TypeError(\".google.protobuf.FileDescriptorProto.service: array expected\");\n            message.service = [];\n\n            for (var i = 0; i < object.service.length; ++i) {\n              if (typeof object.service[i] !== \"object\") throw TypeError(\".google.protobuf.FileDescriptorProto.service: object expected\");\n              message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);\n            }\n          }\n\n          if (object.extension) {\n            if (!Array.isArray(object.extension)) throw TypeError(\".google.protobuf.FileDescriptorProto.extension: array expected\");\n            message.extension = [];\n\n            for (var i = 0; i < object.extension.length; ++i) {\n              if (typeof object.extension[i] !== \"object\") throw TypeError(\".google.protobuf.FileDescriptorProto.extension: object expected\");\n              message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);\n            }\n          }\n\n          if (object.options != null) {\n            if (typeof object.options !== \"object\") throw TypeError(\".google.protobuf.FileDescriptorProto.options: object expected\");\n            message.options = $root.google.protobuf.FileOptions.fromObject(object.options);\n          }\n\n          if (object.sourceCodeInfo != null) {\n            if (typeof object.sourceCodeInfo !== \"object\") throw TypeError(\".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected\");\n            message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);\n          }\n\n          if (object.syntax != null) message.syntax = String(object.syntax);\n          return message;\n        };\n        /**\n         * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.FileDescriptorProto\n         * @static\n         * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        FileDescriptorProto.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.arrays || options.defaults) {\n            object.dependency = [];\n            object.messageType = [];\n            object.enumType = [];\n            object.service = [];\n            object.extension = [];\n            object.publicDependency = [];\n            object.weakDependency = [];\n          }\n\n          if (options.defaults) {\n            object.name = \"\";\n            object[\"package\"] = \"\";\n            object.options = null;\n            object.sourceCodeInfo = null;\n            object.syntax = \"\";\n          }\n\n          if (message.name != null && message.hasOwnProperty(\"name\")) object.name = message.name;\n          if (message[\"package\"] != null && message.hasOwnProperty(\"package\")) object[\"package\"] = message[\"package\"];\n\n          if (message.dependency && message.dependency.length) {\n            object.dependency = [];\n\n            for (var j = 0; j < message.dependency.length; ++j) {\n              object.dependency[j] = message.dependency[j];\n            }\n          }\n\n          if (message.messageType && message.messageType.length) {\n            object.messageType = [];\n\n            for (var j = 0; j < message.messageType.length; ++j) {\n              object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);\n            }\n          }\n\n          if (message.enumType && message.enumType.length) {\n            object.enumType = [];\n\n            for (var j = 0; j < message.enumType.length; ++j) {\n              object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);\n            }\n          }\n\n          if (message.service && message.service.length) {\n            object.service = [];\n\n            for (var j = 0; j < message.service.length; ++j) {\n              object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);\n            }\n          }\n\n          if (message.extension && message.extension.length) {\n            object.extension = [];\n\n            for (var j = 0; j < message.extension.length; ++j) {\n              object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);\n            }\n          }\n\n          if (message.options != null && message.hasOwnProperty(\"options\")) object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);\n          if (message.sourceCodeInfo != null && message.hasOwnProperty(\"sourceCodeInfo\")) object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);\n\n          if (message.publicDependency && message.publicDependency.length) {\n            object.publicDependency = [];\n\n            for (var j = 0; j < message.publicDependency.length; ++j) {\n              object.publicDependency[j] = message.publicDependency[j];\n            }\n          }\n\n          if (message.weakDependency && message.weakDependency.length) {\n            object.weakDependency = [];\n\n            for (var j = 0; j < message.weakDependency.length; ++j) {\n              object.weakDependency[j] = message.weakDependency[j];\n            }\n          }\n\n          if (message.syntax != null && message.hasOwnProperty(\"syntax\")) object.syntax = message.syntax;\n          return object;\n        };\n        /**\n         * Converts this FileDescriptorProto to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.FileDescriptorProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        FileDescriptorProto.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return FileDescriptorProto;\n      }();\n\n      protobuf.DescriptorProto = function () {\n        /**\n         * Properties of a DescriptorProto.\n         * @memberof google.protobuf\n         * @interface IDescriptorProto\n         * @property {string|null} [name] DescriptorProto name\n         * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field\n         * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension\n         * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType\n         * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType\n         * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange\n         * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl\n         * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options\n         * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange\n         * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName\n         */\n\n        /**\n         * Constructs a new DescriptorProto.\n         * @memberof google.protobuf\n         * @classdesc Represents a DescriptorProto.\n         * @implements IDescriptorProto\n         * @constructor\n         * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set\n         */\n        function DescriptorProto(properties) {\n          this.field = [];\n          this.extension = [];\n          this.nestedType = [];\n          this.enumType = [];\n          this.extensionRange = [];\n          this.oneofDecl = [];\n          this.reservedRange = [];\n          this.reservedName = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * DescriptorProto name.\n         * @member {string} name\n         * @memberof google.protobuf.DescriptorProto\n         * @instance\n         */\n\n\n        DescriptorProto.prototype.name = \"\";\n        /**\n         * DescriptorProto field.\n         * @member {Array.<google.protobuf.IFieldDescriptorProto>} field\n         * @memberof google.protobuf.DescriptorProto\n         * @instance\n         */\n\n        DescriptorProto.prototype.field = $util.emptyArray;\n        /**\n         * DescriptorProto extension.\n         * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension\n         * @memberof google.protobuf.DescriptorProto\n         * @instance\n         */\n\n        DescriptorProto.prototype.extension = $util.emptyArray;\n        /**\n         * DescriptorProto nestedType.\n         * @member {Array.<google.protobuf.IDescriptorProto>} nestedType\n         * @memberof google.protobuf.DescriptorProto\n         * @instance\n         */\n\n        DescriptorProto.prototype.nestedType = $util.emptyArray;\n        /**\n         * DescriptorProto enumType.\n         * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType\n         * @memberof google.protobuf.DescriptorProto\n         * @instance\n         */\n\n        DescriptorProto.prototype.enumType = $util.emptyArray;\n        /**\n         * DescriptorProto extensionRange.\n         * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange\n         * @memberof google.protobuf.DescriptorProto\n         * @instance\n         */\n\n        DescriptorProto.prototype.extensionRange = $util.emptyArray;\n        /**\n         * DescriptorProto oneofDecl.\n         * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl\n         * @memberof google.protobuf.DescriptorProto\n         * @instance\n         */\n\n        DescriptorProto.prototype.oneofDecl = $util.emptyArray;\n        /**\n         * DescriptorProto options.\n         * @member {google.protobuf.IMessageOptions|null|undefined} options\n         * @memberof google.protobuf.DescriptorProto\n         * @instance\n         */\n\n        DescriptorProto.prototype.options = null;\n        /**\n         * DescriptorProto reservedRange.\n         * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange\n         * @memberof google.protobuf.DescriptorProto\n         * @instance\n         */\n\n        DescriptorProto.prototype.reservedRange = $util.emptyArray;\n        /**\n         * DescriptorProto reservedName.\n         * @member {Array.<string>} reservedName\n         * @memberof google.protobuf.DescriptorProto\n         * @instance\n         */\n\n        DescriptorProto.prototype.reservedName = $util.emptyArray;\n        /**\n         * Creates a new DescriptorProto instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.DescriptorProto\n         * @static\n         * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set\n         * @returns {google.protobuf.DescriptorProto} DescriptorProto instance\n         */\n\n        DescriptorProto.create = function create(properties) {\n          return new DescriptorProto(properties);\n        };\n        /**\n         * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.DescriptorProto\n         * @static\n         * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        DescriptorProto.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.name);\n          if (message.field != null && message.field.length) for (var i = 0; i < message.field.length; ++i) {\n            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(\n            /* id 2, wireType 2 =*/\n            18).fork()).ldelim();\n          }\n          if (message.nestedType != null && message.nestedType.length) for (var i = 0; i < message.nestedType.length; ++i) {\n            $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(\n            /* id 3, wireType 2 =*/\n            26).fork()).ldelim();\n          }\n          if (message.enumType != null && message.enumType.length) for (var i = 0; i < message.enumType.length; ++i) {\n            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(\n            /* id 4, wireType 2 =*/\n            34).fork()).ldelim();\n          }\n          if (message.extensionRange != null && message.extensionRange.length) for (var i = 0; i < message.extensionRange.length; ++i) {\n            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(\n            /* id 5, wireType 2 =*/\n            42).fork()).ldelim();\n          }\n          if (message.extension != null && message.extension.length) for (var i = 0; i < message.extension.length; ++i) {\n            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(\n            /* id 6, wireType 2 =*/\n            50).fork()).ldelim();\n          }\n          if (message.options != null && Object.hasOwnProperty.call(message, \"options\")) $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(\n          /* id 7, wireType 2 =*/\n          58).fork()).ldelim();\n          if (message.oneofDecl != null && message.oneofDecl.length) for (var i = 0; i < message.oneofDecl.length; ++i) {\n            $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(\n            /* id 8, wireType 2 =*/\n            66).fork()).ldelim();\n          }\n          if (message.reservedRange != null && message.reservedRange.length) for (var i = 0; i < message.reservedRange.length; ++i) {\n            $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(\n            /* id 9, wireType 2 =*/\n            74).fork()).ldelim();\n          }\n          if (message.reservedName != null && message.reservedName.length) for (var i = 0; i < message.reservedName.length; ++i) {\n            writer.uint32(\n            /* id 10, wireType 2 =*/\n            82).string(message.reservedName[i]);\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.DescriptorProto\n         * @static\n         * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a DescriptorProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.DescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.DescriptorProto} DescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        DescriptorProto.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.DescriptorProto();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.name = reader.string();\n                break;\n\n              case 2:\n                if (!(message.field && message.field.length)) message.field = [];\n                message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n                break;\n\n              case 6:\n                if (!(message.extension && message.extension.length)) message.extension = [];\n                message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n                break;\n\n              case 3:\n                if (!(message.nestedType && message.nestedType.length)) message.nestedType = [];\n                message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));\n                break;\n\n              case 4:\n                if (!(message.enumType && message.enumType.length)) message.enumType = [];\n                message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));\n                break;\n\n              case 5:\n                if (!(message.extensionRange && message.extensionRange.length)) message.extensionRange = [];\n                message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));\n                break;\n\n              case 8:\n                if (!(message.oneofDecl && message.oneofDecl.length)) message.oneofDecl = [];\n                message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));\n                break;\n\n              case 7:\n                message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());\n                break;\n\n              case 9:\n                if (!(message.reservedRange && message.reservedRange.length)) message.reservedRange = [];\n                message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));\n                break;\n\n              case 10:\n                if (!(message.reservedName && message.reservedName.length)) message.reservedName = [];\n                message.reservedName.push(reader.string());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.DescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.DescriptorProto} DescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        DescriptorProto.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a DescriptorProto message.\n         * @function verify\n         * @memberof google.protobuf.DescriptorProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        DescriptorProto.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.name != null && message.hasOwnProperty(\"name\")) if (!$util.isString(message.name)) return \"name: string expected\";\n\n          if (message.field != null && message.hasOwnProperty(\"field\")) {\n            if (!Array.isArray(message.field)) return \"field: array expected\";\n\n            for (var i = 0; i < message.field.length; ++i) {\n              var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);\n              if (error) return \"field.\" + error;\n            }\n          }\n\n          if (message.extension != null && message.hasOwnProperty(\"extension\")) {\n            if (!Array.isArray(message.extension)) return \"extension: array expected\";\n\n            for (var i = 0; i < message.extension.length; ++i) {\n              var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);\n              if (error) return \"extension.\" + error;\n            }\n          }\n\n          if (message.nestedType != null && message.hasOwnProperty(\"nestedType\")) {\n            if (!Array.isArray(message.nestedType)) return \"nestedType: array expected\";\n\n            for (var i = 0; i < message.nestedType.length; ++i) {\n              var error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);\n              if (error) return \"nestedType.\" + error;\n            }\n          }\n\n          if (message.enumType != null && message.hasOwnProperty(\"enumType\")) {\n            if (!Array.isArray(message.enumType)) return \"enumType: array expected\";\n\n            for (var i = 0; i < message.enumType.length; ++i) {\n              var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);\n              if (error) return \"enumType.\" + error;\n            }\n          }\n\n          if (message.extensionRange != null && message.hasOwnProperty(\"extensionRange\")) {\n            if (!Array.isArray(message.extensionRange)) return \"extensionRange: array expected\";\n\n            for (var i = 0; i < message.extensionRange.length; ++i) {\n              var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);\n              if (error) return \"extensionRange.\" + error;\n            }\n          }\n\n          if (message.oneofDecl != null && message.hasOwnProperty(\"oneofDecl\")) {\n            if (!Array.isArray(message.oneofDecl)) return \"oneofDecl: array expected\";\n\n            for (var i = 0; i < message.oneofDecl.length; ++i) {\n              var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);\n              if (error) return \"oneofDecl.\" + error;\n            }\n          }\n\n          if (message.options != null && message.hasOwnProperty(\"options\")) {\n            var error = $root.google.protobuf.MessageOptions.verify(message.options);\n            if (error) return \"options.\" + error;\n          }\n\n          if (message.reservedRange != null && message.hasOwnProperty(\"reservedRange\")) {\n            if (!Array.isArray(message.reservedRange)) return \"reservedRange: array expected\";\n\n            for (var i = 0; i < message.reservedRange.length; ++i) {\n              var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);\n              if (error) return \"reservedRange.\" + error;\n            }\n          }\n\n          if (message.reservedName != null && message.hasOwnProperty(\"reservedName\")) {\n            if (!Array.isArray(message.reservedName)) return \"reservedName: array expected\";\n\n            for (var i = 0; i < message.reservedName.length; ++i) {\n              if (!$util.isString(message.reservedName[i])) return \"reservedName: string[] expected\";\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.DescriptorProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.DescriptorProto} DescriptorProto\n         */\n\n\n        DescriptorProto.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.DescriptorProto) return object;\n          var message = new $root.google.protobuf.DescriptorProto();\n          if (object.name != null) message.name = String(object.name);\n\n          if (object.field) {\n            if (!Array.isArray(object.field)) throw TypeError(\".google.protobuf.DescriptorProto.field: array expected\");\n            message.field = [];\n\n            for (var i = 0; i < object.field.length; ++i) {\n              if (typeof object.field[i] !== \"object\") throw TypeError(\".google.protobuf.DescriptorProto.field: object expected\");\n              message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);\n            }\n          }\n\n          if (object.extension) {\n            if (!Array.isArray(object.extension)) throw TypeError(\".google.protobuf.DescriptorProto.extension: array expected\");\n            message.extension = [];\n\n            for (var i = 0; i < object.extension.length; ++i) {\n              if (typeof object.extension[i] !== \"object\") throw TypeError(\".google.protobuf.DescriptorProto.extension: object expected\");\n              message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);\n            }\n          }\n\n          if (object.nestedType) {\n            if (!Array.isArray(object.nestedType)) throw TypeError(\".google.protobuf.DescriptorProto.nestedType: array expected\");\n            message.nestedType = [];\n\n            for (var i = 0; i < object.nestedType.length; ++i) {\n              if (typeof object.nestedType[i] !== \"object\") throw TypeError(\".google.protobuf.DescriptorProto.nestedType: object expected\");\n              message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);\n            }\n          }\n\n          if (object.enumType) {\n            if (!Array.isArray(object.enumType)) throw TypeError(\".google.protobuf.DescriptorProto.enumType: array expected\");\n            message.enumType = [];\n\n            for (var i = 0; i < object.enumType.length; ++i) {\n              if (typeof object.enumType[i] !== \"object\") throw TypeError(\".google.protobuf.DescriptorProto.enumType: object expected\");\n              message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);\n            }\n          }\n\n          if (object.extensionRange) {\n            if (!Array.isArray(object.extensionRange)) throw TypeError(\".google.protobuf.DescriptorProto.extensionRange: array expected\");\n            message.extensionRange = [];\n\n            for (var i = 0; i < object.extensionRange.length; ++i) {\n              if (typeof object.extensionRange[i] !== \"object\") throw TypeError(\".google.protobuf.DescriptorProto.extensionRange: object expected\");\n              message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);\n            }\n          }\n\n          if (object.oneofDecl) {\n            if (!Array.isArray(object.oneofDecl)) throw TypeError(\".google.protobuf.DescriptorProto.oneofDecl: array expected\");\n            message.oneofDecl = [];\n\n            for (var i = 0; i < object.oneofDecl.length; ++i) {\n              if (typeof object.oneofDecl[i] !== \"object\") throw TypeError(\".google.protobuf.DescriptorProto.oneofDecl: object expected\");\n              message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);\n            }\n          }\n\n          if (object.options != null) {\n            if (typeof object.options !== \"object\") throw TypeError(\".google.protobuf.DescriptorProto.options: object expected\");\n            message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);\n          }\n\n          if (object.reservedRange) {\n            if (!Array.isArray(object.reservedRange)) throw TypeError(\".google.protobuf.DescriptorProto.reservedRange: array expected\");\n            message.reservedRange = [];\n\n            for (var i = 0; i < object.reservedRange.length; ++i) {\n              if (typeof object.reservedRange[i] !== \"object\") throw TypeError(\".google.protobuf.DescriptorProto.reservedRange: object expected\");\n              message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);\n            }\n          }\n\n          if (object.reservedName) {\n            if (!Array.isArray(object.reservedName)) throw TypeError(\".google.protobuf.DescriptorProto.reservedName: array expected\");\n            message.reservedName = [];\n\n            for (var i = 0; i < object.reservedName.length; ++i) {\n              message.reservedName[i] = String(object.reservedName[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.DescriptorProto\n         * @static\n         * @param {google.protobuf.DescriptorProto} message DescriptorProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        DescriptorProto.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.arrays || options.defaults) {\n            object.field = [];\n            object.nestedType = [];\n            object.enumType = [];\n            object.extensionRange = [];\n            object.extension = [];\n            object.oneofDecl = [];\n            object.reservedRange = [];\n            object.reservedName = [];\n          }\n\n          if (options.defaults) {\n            object.name = \"\";\n            object.options = null;\n          }\n\n          if (message.name != null && message.hasOwnProperty(\"name\")) object.name = message.name;\n\n          if (message.field && message.field.length) {\n            object.field = [];\n\n            for (var j = 0; j < message.field.length; ++j) {\n              object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);\n            }\n          }\n\n          if (message.nestedType && message.nestedType.length) {\n            object.nestedType = [];\n\n            for (var j = 0; j < message.nestedType.length; ++j) {\n              object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);\n            }\n          }\n\n          if (message.enumType && message.enumType.length) {\n            object.enumType = [];\n\n            for (var j = 0; j < message.enumType.length; ++j) {\n              object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);\n            }\n          }\n\n          if (message.extensionRange && message.extensionRange.length) {\n            object.extensionRange = [];\n\n            for (var j = 0; j < message.extensionRange.length; ++j) {\n              object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);\n            }\n          }\n\n          if (message.extension && message.extension.length) {\n            object.extension = [];\n\n            for (var j = 0; j < message.extension.length; ++j) {\n              object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);\n            }\n          }\n\n          if (message.options != null && message.hasOwnProperty(\"options\")) object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);\n\n          if (message.oneofDecl && message.oneofDecl.length) {\n            object.oneofDecl = [];\n\n            for (var j = 0; j < message.oneofDecl.length; ++j) {\n              object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);\n            }\n          }\n\n          if (message.reservedRange && message.reservedRange.length) {\n            object.reservedRange = [];\n\n            for (var j = 0; j < message.reservedRange.length; ++j) {\n              object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);\n            }\n          }\n\n          if (message.reservedName && message.reservedName.length) {\n            object.reservedName = [];\n\n            for (var j = 0; j < message.reservedName.length; ++j) {\n              object.reservedName[j] = message.reservedName[j];\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this DescriptorProto to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.DescriptorProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        DescriptorProto.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        DescriptorProto.ExtensionRange = function () {\n          /**\n           * Properties of an ExtensionRange.\n           * @memberof google.protobuf.DescriptorProto\n           * @interface IExtensionRange\n           * @property {number|null} [start] ExtensionRange start\n           * @property {number|null} [end] ExtensionRange end\n           */\n\n          /**\n           * Constructs a new ExtensionRange.\n           * @memberof google.protobuf.DescriptorProto\n           * @classdesc Represents an ExtensionRange.\n           * @implements IExtensionRange\n           * @constructor\n           * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set\n           */\n          function ExtensionRange(properties) {\n            if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n            }\n          }\n          /**\n           * ExtensionRange start.\n           * @member {number} start\n           * @memberof google.protobuf.DescriptorProto.ExtensionRange\n           * @instance\n           */\n\n\n          ExtensionRange.prototype.start = 0;\n          /**\n           * ExtensionRange end.\n           * @member {number} end\n           * @memberof google.protobuf.DescriptorProto.ExtensionRange\n           * @instance\n           */\n\n          ExtensionRange.prototype.end = 0;\n          /**\n           * Creates a new ExtensionRange instance using the specified properties.\n           * @function create\n           * @memberof google.protobuf.DescriptorProto.ExtensionRange\n           * @static\n           * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set\n           * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance\n           */\n\n          ExtensionRange.create = function create(properties) {\n            return new ExtensionRange(properties);\n          };\n          /**\n           * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.\n           * @function encode\n           * @memberof google.protobuf.DescriptorProto.ExtensionRange\n           * @static\n           * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode\n           * @param {$protobuf.Writer} [writer] Writer to encode to\n           * @returns {$protobuf.Writer} Writer\n           */\n\n\n          ExtensionRange.encode = function encode(message, writer) {\n            if (!writer) writer = $Writer.create();\n            if (message.start != null && Object.hasOwnProperty.call(message, \"start\")) writer.uint32(\n            /* id 1, wireType 0 =*/\n            8).int32(message.start);\n            if (message.end != null && Object.hasOwnProperty.call(message, \"end\")) writer.uint32(\n            /* id 2, wireType 0 =*/\n            16).int32(message.end);\n            return writer;\n          };\n          /**\n           * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.\n           * @function encodeDelimited\n           * @memberof google.protobuf.DescriptorProto.ExtensionRange\n           * @static\n           * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode\n           * @param {$protobuf.Writer} [writer] Writer to encode to\n           * @returns {$protobuf.Writer} Writer\n           */\n\n\n          ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          /**\n           * Decodes an ExtensionRange message from the specified reader or buffer.\n           * @function decode\n           * @memberof google.protobuf.DescriptorProto.ExtensionRange\n           * @static\n           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n           * @param {number} [length] Message length if known beforehand\n           * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange\n           * @throws {Error} If the payload is not a reader or valid buffer\n           * @throws {$protobuf.util.ProtocolError} If required fields are missing\n           */\n\n\n          ExtensionRange.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length,\n                message = new $root.google.protobuf.DescriptorProto.ExtensionRange();\n\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n\n              switch (tag >>> 3) {\n                case 1:\n                  message.start = reader.int32();\n                  break;\n\n                case 2:\n                  message.end = reader.int32();\n                  break;\n\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n\n            return message;\n          };\n          /**\n           * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.\n           * @function decodeDelimited\n           * @memberof google.protobuf.DescriptorProto.ExtensionRange\n           * @static\n           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n           * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange\n           * @throws {Error} If the payload is not a reader or valid buffer\n           * @throws {$protobuf.util.ProtocolError} If required fields are missing\n           */\n\n\n          ExtensionRange.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          /**\n           * Verifies an ExtensionRange message.\n           * @function verify\n           * @memberof google.protobuf.DescriptorProto.ExtensionRange\n           * @static\n           * @param {Object.<string,*>} message Plain object to verify\n           * @returns {string|null} `null` if valid, otherwise the reason why it is not\n           */\n\n\n          ExtensionRange.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null) return \"object expected\";\n            if (message.start != null && message.hasOwnProperty(\"start\")) if (!$util.isInteger(message.start)) return \"start: integer expected\";\n            if (message.end != null && message.hasOwnProperty(\"end\")) if (!$util.isInteger(message.end)) return \"end: integer expected\";\n            return null;\n          };\n          /**\n           * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.\n           * @function fromObject\n           * @memberof google.protobuf.DescriptorProto.ExtensionRange\n           * @static\n           * @param {Object.<string,*>} object Plain object\n           * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange\n           */\n\n\n          ExtensionRange.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange) return object;\n            var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();\n            if (object.start != null) message.start = object.start | 0;\n            if (object.end != null) message.end = object.end | 0;\n            return message;\n          };\n          /**\n           * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.\n           * @function toObject\n           * @memberof google.protobuf.DescriptorProto.ExtensionRange\n           * @static\n           * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange\n           * @param {$protobuf.IConversionOptions} [options] Conversion options\n           * @returns {Object.<string,*>} Plain object\n           */\n\n\n          ExtensionRange.toObject = function toObject(message, options) {\n            if (!options) options = {};\n            var object = {};\n\n            if (options.defaults) {\n              object.start = 0;\n              object.end = 0;\n            }\n\n            if (message.start != null && message.hasOwnProperty(\"start\")) object.start = message.start;\n            if (message.end != null && message.hasOwnProperty(\"end\")) object.end = message.end;\n            return object;\n          };\n          /**\n           * Converts this ExtensionRange to JSON.\n           * @function toJSON\n           * @memberof google.protobuf.DescriptorProto.ExtensionRange\n           * @instance\n           * @returns {Object.<string,*>} JSON object\n           */\n\n\n          ExtensionRange.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n\n          return ExtensionRange;\n        }();\n\n        DescriptorProto.ReservedRange = function () {\n          /**\n           * Properties of a ReservedRange.\n           * @memberof google.protobuf.DescriptorProto\n           * @interface IReservedRange\n           * @property {number|null} [start] ReservedRange start\n           * @property {number|null} [end] ReservedRange end\n           */\n\n          /**\n           * Constructs a new ReservedRange.\n           * @memberof google.protobuf.DescriptorProto\n           * @classdesc Represents a ReservedRange.\n           * @implements IReservedRange\n           * @constructor\n           * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set\n           */\n          function ReservedRange(properties) {\n            if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n            }\n          }\n          /**\n           * ReservedRange start.\n           * @member {number} start\n           * @memberof google.protobuf.DescriptorProto.ReservedRange\n           * @instance\n           */\n\n\n          ReservedRange.prototype.start = 0;\n          /**\n           * ReservedRange end.\n           * @member {number} end\n           * @memberof google.protobuf.DescriptorProto.ReservedRange\n           * @instance\n           */\n\n          ReservedRange.prototype.end = 0;\n          /**\n           * Creates a new ReservedRange instance using the specified properties.\n           * @function create\n           * @memberof google.protobuf.DescriptorProto.ReservedRange\n           * @static\n           * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set\n           * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance\n           */\n\n          ReservedRange.create = function create(properties) {\n            return new ReservedRange(properties);\n          };\n          /**\n           * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.\n           * @function encode\n           * @memberof google.protobuf.DescriptorProto.ReservedRange\n           * @static\n           * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode\n           * @param {$protobuf.Writer} [writer] Writer to encode to\n           * @returns {$protobuf.Writer} Writer\n           */\n\n\n          ReservedRange.encode = function encode(message, writer) {\n            if (!writer) writer = $Writer.create();\n            if (message.start != null && Object.hasOwnProperty.call(message, \"start\")) writer.uint32(\n            /* id 1, wireType 0 =*/\n            8).int32(message.start);\n            if (message.end != null && Object.hasOwnProperty.call(message, \"end\")) writer.uint32(\n            /* id 2, wireType 0 =*/\n            16).int32(message.end);\n            return writer;\n          };\n          /**\n           * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.\n           * @function encodeDelimited\n           * @memberof google.protobuf.DescriptorProto.ReservedRange\n           * @static\n           * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode\n           * @param {$protobuf.Writer} [writer] Writer to encode to\n           * @returns {$protobuf.Writer} Writer\n           */\n\n\n          ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          /**\n           * Decodes a ReservedRange message from the specified reader or buffer.\n           * @function decode\n           * @memberof google.protobuf.DescriptorProto.ReservedRange\n           * @static\n           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n           * @param {number} [length] Message length if known beforehand\n           * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange\n           * @throws {Error} If the payload is not a reader or valid buffer\n           * @throws {$protobuf.util.ProtocolError} If required fields are missing\n           */\n\n\n          ReservedRange.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length,\n                message = new $root.google.protobuf.DescriptorProto.ReservedRange();\n\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n\n              switch (tag >>> 3) {\n                case 1:\n                  message.start = reader.int32();\n                  break;\n\n                case 2:\n                  message.end = reader.int32();\n                  break;\n\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n\n            return message;\n          };\n          /**\n           * Decodes a ReservedRange message from the specified reader or buffer, length delimited.\n           * @function decodeDelimited\n           * @memberof google.protobuf.DescriptorProto.ReservedRange\n           * @static\n           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n           * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange\n           * @throws {Error} If the payload is not a reader or valid buffer\n           * @throws {$protobuf.util.ProtocolError} If required fields are missing\n           */\n\n\n          ReservedRange.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          /**\n           * Verifies a ReservedRange message.\n           * @function verify\n           * @memberof google.protobuf.DescriptorProto.ReservedRange\n           * @static\n           * @param {Object.<string,*>} message Plain object to verify\n           * @returns {string|null} `null` if valid, otherwise the reason why it is not\n           */\n\n\n          ReservedRange.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null) return \"object expected\";\n            if (message.start != null && message.hasOwnProperty(\"start\")) if (!$util.isInteger(message.start)) return \"start: integer expected\";\n            if (message.end != null && message.hasOwnProperty(\"end\")) if (!$util.isInteger(message.end)) return \"end: integer expected\";\n            return null;\n          };\n          /**\n           * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.\n           * @function fromObject\n           * @memberof google.protobuf.DescriptorProto.ReservedRange\n           * @static\n           * @param {Object.<string,*>} object Plain object\n           * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange\n           */\n\n\n          ReservedRange.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange) return object;\n            var message = new $root.google.protobuf.DescriptorProto.ReservedRange();\n            if (object.start != null) message.start = object.start | 0;\n            if (object.end != null) message.end = object.end | 0;\n            return message;\n          };\n          /**\n           * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.\n           * @function toObject\n           * @memberof google.protobuf.DescriptorProto.ReservedRange\n           * @static\n           * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange\n           * @param {$protobuf.IConversionOptions} [options] Conversion options\n           * @returns {Object.<string,*>} Plain object\n           */\n\n\n          ReservedRange.toObject = function toObject(message, options) {\n            if (!options) options = {};\n            var object = {};\n\n            if (options.defaults) {\n              object.start = 0;\n              object.end = 0;\n            }\n\n            if (message.start != null && message.hasOwnProperty(\"start\")) object.start = message.start;\n            if (message.end != null && message.hasOwnProperty(\"end\")) object.end = message.end;\n            return object;\n          };\n          /**\n           * Converts this ReservedRange to JSON.\n           * @function toJSON\n           * @memberof google.protobuf.DescriptorProto.ReservedRange\n           * @instance\n           * @returns {Object.<string,*>} JSON object\n           */\n\n\n          ReservedRange.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n\n          return ReservedRange;\n        }();\n\n        return DescriptorProto;\n      }();\n\n      protobuf.FieldDescriptorProto = function () {\n        /**\n         * Properties of a FieldDescriptorProto.\n         * @memberof google.protobuf\n         * @interface IFieldDescriptorProto\n         * @property {string|null} [name] FieldDescriptorProto name\n         * @property {number|null} [number] FieldDescriptorProto number\n         * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label\n         * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type\n         * @property {string|null} [typeName] FieldDescriptorProto typeName\n         * @property {string|null} [extendee] FieldDescriptorProto extendee\n         * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue\n         * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex\n         * @property {string|null} [jsonName] FieldDescriptorProto jsonName\n         * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options\n         */\n\n        /**\n         * Constructs a new FieldDescriptorProto.\n         * @memberof google.protobuf\n         * @classdesc Represents a FieldDescriptorProto.\n         * @implements IFieldDescriptorProto\n         * @constructor\n         * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set\n         */\n        function FieldDescriptorProto(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * FieldDescriptorProto name.\n         * @member {string} name\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @instance\n         */\n\n\n        FieldDescriptorProto.prototype.name = \"\";\n        /**\n         * FieldDescriptorProto number.\n         * @member {number} number\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @instance\n         */\n\n        FieldDescriptorProto.prototype.number = 0;\n        /**\n         * FieldDescriptorProto label.\n         * @member {google.protobuf.FieldDescriptorProto.Label} label\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @instance\n         */\n\n        FieldDescriptorProto.prototype.label = 1;\n        /**\n         * FieldDescriptorProto type.\n         * @member {google.protobuf.FieldDescriptorProto.Type} type\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @instance\n         */\n\n        FieldDescriptorProto.prototype.type = 1;\n        /**\n         * FieldDescriptorProto typeName.\n         * @member {string} typeName\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @instance\n         */\n\n        FieldDescriptorProto.prototype.typeName = \"\";\n        /**\n         * FieldDescriptorProto extendee.\n         * @member {string} extendee\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @instance\n         */\n\n        FieldDescriptorProto.prototype.extendee = \"\";\n        /**\n         * FieldDescriptorProto defaultValue.\n         * @member {string} defaultValue\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @instance\n         */\n\n        FieldDescriptorProto.prototype.defaultValue = \"\";\n        /**\n         * FieldDescriptorProto oneofIndex.\n         * @member {number} oneofIndex\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @instance\n         */\n\n        FieldDescriptorProto.prototype.oneofIndex = 0;\n        /**\n         * FieldDescriptorProto jsonName.\n         * @member {string} jsonName\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @instance\n         */\n\n        FieldDescriptorProto.prototype.jsonName = \"\";\n        /**\n         * FieldDescriptorProto options.\n         * @member {google.protobuf.IFieldOptions|null|undefined} options\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @instance\n         */\n\n        FieldDescriptorProto.prototype.options = null;\n        /**\n         * Creates a new FieldDescriptorProto instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @static\n         * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set\n         * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance\n         */\n\n        FieldDescriptorProto.create = function create(properties) {\n          return new FieldDescriptorProto(properties);\n        };\n        /**\n         * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @static\n         * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        FieldDescriptorProto.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.name);\n          if (message.extendee != null && Object.hasOwnProperty.call(message, \"extendee\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).string(message.extendee);\n          if (message.number != null && Object.hasOwnProperty.call(message, \"number\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).int32(message.number);\n          if (message.label != null && Object.hasOwnProperty.call(message, \"label\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).int32(message.label);\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\")) writer.uint32(\n          /* id 5, wireType 0 =*/\n          40).int32(message.type);\n          if (message.typeName != null && Object.hasOwnProperty.call(message, \"typeName\")) writer.uint32(\n          /* id 6, wireType 2 =*/\n          50).string(message.typeName);\n          if (message.defaultValue != null && Object.hasOwnProperty.call(message, \"defaultValue\")) writer.uint32(\n          /* id 7, wireType 2 =*/\n          58).string(message.defaultValue);\n          if (message.options != null && Object.hasOwnProperty.call(message, \"options\")) $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(\n          /* id 8, wireType 2 =*/\n          66).fork()).ldelim();\n          if (message.oneofIndex != null && Object.hasOwnProperty.call(message, \"oneofIndex\")) writer.uint32(\n          /* id 9, wireType 0 =*/\n          72).int32(message.oneofIndex);\n          if (message.jsonName != null && Object.hasOwnProperty.call(message, \"jsonName\")) writer.uint32(\n          /* id 10, wireType 2 =*/\n          82).string(message.jsonName);\n          return writer;\n        };\n        /**\n         * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @static\n         * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a FieldDescriptorProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        FieldDescriptorProto.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.FieldDescriptorProto();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.name = reader.string();\n                break;\n\n              case 3:\n                message.number = reader.int32();\n                break;\n\n              case 4:\n                message.label = reader.int32();\n                break;\n\n              case 5:\n                message.type = reader.int32();\n                break;\n\n              case 6:\n                message.typeName = reader.string();\n                break;\n\n              case 2:\n                message.extendee = reader.string();\n                break;\n\n              case 7:\n                message.defaultValue = reader.string();\n                break;\n\n              case 9:\n                message.oneofIndex = reader.int32();\n                break;\n\n              case 10:\n                message.jsonName = reader.string();\n                break;\n\n              case 8:\n                message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a FieldDescriptorProto message.\n         * @function verify\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        FieldDescriptorProto.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.name != null && message.hasOwnProperty(\"name\")) if (!$util.isString(message.name)) return \"name: string expected\";\n          if (message.number != null && message.hasOwnProperty(\"number\")) if (!$util.isInteger(message.number)) return \"number: integer expected\";\n          if (message.label != null && message.hasOwnProperty(\"label\")) switch (message.label) {\n            default:\n              return \"label: enum value expected\";\n\n            case 1:\n            case 2:\n            case 3:\n              break;\n          }\n          if (message.type != null && message.hasOwnProperty(\"type\")) switch (message.type) {\n            default:\n              return \"type: enum value expected\";\n\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n            case 16:\n            case 17:\n            case 18:\n              break;\n          }\n          if (message.typeName != null && message.hasOwnProperty(\"typeName\")) if (!$util.isString(message.typeName)) return \"typeName: string expected\";\n          if (message.extendee != null && message.hasOwnProperty(\"extendee\")) if (!$util.isString(message.extendee)) return \"extendee: string expected\";\n          if (message.defaultValue != null && message.hasOwnProperty(\"defaultValue\")) if (!$util.isString(message.defaultValue)) return \"defaultValue: string expected\";\n          if (message.oneofIndex != null && message.hasOwnProperty(\"oneofIndex\")) if (!$util.isInteger(message.oneofIndex)) return \"oneofIndex: integer expected\";\n          if (message.jsonName != null && message.hasOwnProperty(\"jsonName\")) if (!$util.isString(message.jsonName)) return \"jsonName: string expected\";\n\n          if (message.options != null && message.hasOwnProperty(\"options\")) {\n            var error = $root.google.protobuf.FieldOptions.verify(message.options);\n            if (error) return \"options.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto\n         */\n\n\n        FieldDescriptorProto.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.FieldDescriptorProto) return object;\n          var message = new $root.google.protobuf.FieldDescriptorProto();\n          if (object.name != null) message.name = String(object.name);\n          if (object.number != null) message.number = object.number | 0;\n\n          switch (object.label) {\n            case \"LABEL_OPTIONAL\":\n            case 1:\n              message.label = 1;\n              break;\n\n            case \"LABEL_REQUIRED\":\n            case 2:\n              message.label = 2;\n              break;\n\n            case \"LABEL_REPEATED\":\n            case 3:\n              message.label = 3;\n              break;\n          }\n\n          switch (object.type) {\n            case \"TYPE_DOUBLE\":\n            case 1:\n              message.type = 1;\n              break;\n\n            case \"TYPE_FLOAT\":\n            case 2:\n              message.type = 2;\n              break;\n\n            case \"TYPE_INT64\":\n            case 3:\n              message.type = 3;\n              break;\n\n            case \"TYPE_UINT64\":\n            case 4:\n              message.type = 4;\n              break;\n\n            case \"TYPE_INT32\":\n            case 5:\n              message.type = 5;\n              break;\n\n            case \"TYPE_FIXED64\":\n            case 6:\n              message.type = 6;\n              break;\n\n            case \"TYPE_FIXED32\":\n            case 7:\n              message.type = 7;\n              break;\n\n            case \"TYPE_BOOL\":\n            case 8:\n              message.type = 8;\n              break;\n\n            case \"TYPE_STRING\":\n            case 9:\n              message.type = 9;\n              break;\n\n            case \"TYPE_GROUP\":\n            case 10:\n              message.type = 10;\n              break;\n\n            case \"TYPE_MESSAGE\":\n            case 11:\n              message.type = 11;\n              break;\n\n            case \"TYPE_BYTES\":\n            case 12:\n              message.type = 12;\n              break;\n\n            case \"TYPE_UINT32\":\n            case 13:\n              message.type = 13;\n              break;\n\n            case \"TYPE_ENUM\":\n            case 14:\n              message.type = 14;\n              break;\n\n            case \"TYPE_SFIXED32\":\n            case 15:\n              message.type = 15;\n              break;\n\n            case \"TYPE_SFIXED64\":\n            case 16:\n              message.type = 16;\n              break;\n\n            case \"TYPE_SINT32\":\n            case 17:\n              message.type = 17;\n              break;\n\n            case \"TYPE_SINT64\":\n            case 18:\n              message.type = 18;\n              break;\n          }\n\n          if (object.typeName != null) message.typeName = String(object.typeName);\n          if (object.extendee != null) message.extendee = String(object.extendee);\n          if (object.defaultValue != null) message.defaultValue = String(object.defaultValue);\n          if (object.oneofIndex != null) message.oneofIndex = object.oneofIndex | 0;\n          if (object.jsonName != null) message.jsonName = String(object.jsonName);\n\n          if (object.options != null) {\n            if (typeof object.options !== \"object\") throw TypeError(\".google.protobuf.FieldDescriptorProto.options: object expected\");\n            message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @static\n         * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        FieldDescriptorProto.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.name = \"\";\n            object.extendee = \"\";\n            object.number = 0;\n            object.label = options.enums === String ? \"LABEL_OPTIONAL\" : 1;\n            object.type = options.enums === String ? \"TYPE_DOUBLE\" : 1;\n            object.typeName = \"\";\n            object.defaultValue = \"\";\n            object.options = null;\n            object.oneofIndex = 0;\n            object.jsonName = \"\";\n          }\n\n          if (message.name != null && message.hasOwnProperty(\"name\")) object.name = message.name;\n          if (message.extendee != null && message.hasOwnProperty(\"extendee\")) object.extendee = message.extendee;\n          if (message.number != null && message.hasOwnProperty(\"number\")) object.number = message.number;\n          if (message.label != null && message.hasOwnProperty(\"label\")) object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;\n          if (message.type != null && message.hasOwnProperty(\"type\")) object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;\n          if (message.typeName != null && message.hasOwnProperty(\"typeName\")) object.typeName = message.typeName;\n          if (message.defaultValue != null && message.hasOwnProperty(\"defaultValue\")) object.defaultValue = message.defaultValue;\n          if (message.options != null && message.hasOwnProperty(\"options\")) object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);\n          if (message.oneofIndex != null && message.hasOwnProperty(\"oneofIndex\")) object.oneofIndex = message.oneofIndex;\n          if (message.jsonName != null && message.hasOwnProperty(\"jsonName\")) object.jsonName = message.jsonName;\n          return object;\n        };\n        /**\n         * Converts this FieldDescriptorProto to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.FieldDescriptorProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        FieldDescriptorProto.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        /**\n         * Type enum.\n         * @name google.protobuf.FieldDescriptorProto.Type\n         * @enum {number}\n         * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value\n         * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value\n         * @property {number} TYPE_INT64=3 TYPE_INT64 value\n         * @property {number} TYPE_UINT64=4 TYPE_UINT64 value\n         * @property {number} TYPE_INT32=5 TYPE_INT32 value\n         * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value\n         * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value\n         * @property {number} TYPE_BOOL=8 TYPE_BOOL value\n         * @property {number} TYPE_STRING=9 TYPE_STRING value\n         * @property {number} TYPE_GROUP=10 TYPE_GROUP value\n         * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value\n         * @property {number} TYPE_BYTES=12 TYPE_BYTES value\n         * @property {number} TYPE_UINT32=13 TYPE_UINT32 value\n         * @property {number} TYPE_ENUM=14 TYPE_ENUM value\n         * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value\n         * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value\n         * @property {number} TYPE_SINT32=17 TYPE_SINT32 value\n         * @property {number} TYPE_SINT64=18 TYPE_SINT64 value\n         */\n\n\n        FieldDescriptorProto.Type = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[1] = \"TYPE_DOUBLE\"] = 1;\n          values[valuesById[2] = \"TYPE_FLOAT\"] = 2;\n          values[valuesById[3] = \"TYPE_INT64\"] = 3;\n          values[valuesById[4] = \"TYPE_UINT64\"] = 4;\n          values[valuesById[5] = \"TYPE_INT32\"] = 5;\n          values[valuesById[6] = \"TYPE_FIXED64\"] = 6;\n          values[valuesById[7] = \"TYPE_FIXED32\"] = 7;\n          values[valuesById[8] = \"TYPE_BOOL\"] = 8;\n          values[valuesById[9] = \"TYPE_STRING\"] = 9;\n          values[valuesById[10] = \"TYPE_GROUP\"] = 10;\n          values[valuesById[11] = \"TYPE_MESSAGE\"] = 11;\n          values[valuesById[12] = \"TYPE_BYTES\"] = 12;\n          values[valuesById[13] = \"TYPE_UINT32\"] = 13;\n          values[valuesById[14] = \"TYPE_ENUM\"] = 14;\n          values[valuesById[15] = \"TYPE_SFIXED32\"] = 15;\n          values[valuesById[16] = \"TYPE_SFIXED64\"] = 16;\n          values[valuesById[17] = \"TYPE_SINT32\"] = 17;\n          values[valuesById[18] = \"TYPE_SINT64\"] = 18;\n          return values;\n        }();\n        /**\n         * Label enum.\n         * @name google.protobuf.FieldDescriptorProto.Label\n         * @enum {number}\n         * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value\n         * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value\n         * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value\n         */\n\n\n        FieldDescriptorProto.Label = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[1] = \"LABEL_OPTIONAL\"] = 1;\n          values[valuesById[2] = \"LABEL_REQUIRED\"] = 2;\n          values[valuesById[3] = \"LABEL_REPEATED\"] = 3;\n          return values;\n        }();\n\n        return FieldDescriptorProto;\n      }();\n\n      protobuf.OneofDescriptorProto = function () {\n        /**\n         * Properties of an OneofDescriptorProto.\n         * @memberof google.protobuf\n         * @interface IOneofDescriptorProto\n         * @property {string|null} [name] OneofDescriptorProto name\n         * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options\n         */\n\n        /**\n         * Constructs a new OneofDescriptorProto.\n         * @memberof google.protobuf\n         * @classdesc Represents an OneofDescriptorProto.\n         * @implements IOneofDescriptorProto\n         * @constructor\n         * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set\n         */\n        function OneofDescriptorProto(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * OneofDescriptorProto name.\n         * @member {string} name\n         * @memberof google.protobuf.OneofDescriptorProto\n         * @instance\n         */\n\n\n        OneofDescriptorProto.prototype.name = \"\";\n        /**\n         * OneofDescriptorProto options.\n         * @member {google.protobuf.IOneofOptions|null|undefined} options\n         * @memberof google.protobuf.OneofDescriptorProto\n         * @instance\n         */\n\n        OneofDescriptorProto.prototype.options = null;\n        /**\n         * Creates a new OneofDescriptorProto instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.OneofDescriptorProto\n         * @static\n         * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set\n         * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance\n         */\n\n        OneofDescriptorProto.create = function create(properties) {\n          return new OneofDescriptorProto(properties);\n        };\n        /**\n         * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.OneofDescriptorProto\n         * @static\n         * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        OneofDescriptorProto.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.name);\n          if (message.options != null && Object.hasOwnProperty.call(message, \"options\")) $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.OneofDescriptorProto\n         * @static\n         * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an OneofDescriptorProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.OneofDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        OneofDescriptorProto.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.OneofDescriptorProto();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.name = reader.string();\n                break;\n\n              case 2:\n                message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.OneofDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an OneofDescriptorProto message.\n         * @function verify\n         * @memberof google.protobuf.OneofDescriptorProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        OneofDescriptorProto.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.name != null && message.hasOwnProperty(\"name\")) if (!$util.isString(message.name)) return \"name: string expected\";\n\n          if (message.options != null && message.hasOwnProperty(\"options\")) {\n            var error = $root.google.protobuf.OneofOptions.verify(message.options);\n            if (error) return \"options.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.OneofDescriptorProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto\n         */\n\n\n        OneofDescriptorProto.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.OneofDescriptorProto) return object;\n          var message = new $root.google.protobuf.OneofDescriptorProto();\n          if (object.name != null) message.name = String(object.name);\n\n          if (object.options != null) {\n            if (typeof object.options !== \"object\") throw TypeError(\".google.protobuf.OneofDescriptorProto.options: object expected\");\n            message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.OneofDescriptorProto\n         * @static\n         * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        OneofDescriptorProto.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.name = \"\";\n            object.options = null;\n          }\n\n          if (message.name != null && message.hasOwnProperty(\"name\")) object.name = message.name;\n          if (message.options != null && message.hasOwnProperty(\"options\")) object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);\n          return object;\n        };\n        /**\n         * Converts this OneofDescriptorProto to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.OneofDescriptorProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        OneofDescriptorProto.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return OneofDescriptorProto;\n      }();\n\n      protobuf.EnumDescriptorProto = function () {\n        /**\n         * Properties of an EnumDescriptorProto.\n         * @memberof google.protobuf\n         * @interface IEnumDescriptorProto\n         * @property {string|null} [name] EnumDescriptorProto name\n         * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value\n         * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options\n         */\n\n        /**\n         * Constructs a new EnumDescriptorProto.\n         * @memberof google.protobuf\n         * @classdesc Represents an EnumDescriptorProto.\n         * @implements IEnumDescriptorProto\n         * @constructor\n         * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set\n         */\n        function EnumDescriptorProto(properties) {\n          this.value = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * EnumDescriptorProto name.\n         * @member {string} name\n         * @memberof google.protobuf.EnumDescriptorProto\n         * @instance\n         */\n\n\n        EnumDescriptorProto.prototype.name = \"\";\n        /**\n         * EnumDescriptorProto value.\n         * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value\n         * @memberof google.protobuf.EnumDescriptorProto\n         * @instance\n         */\n\n        EnumDescriptorProto.prototype.value = $util.emptyArray;\n        /**\n         * EnumDescriptorProto options.\n         * @member {google.protobuf.IEnumOptions|null|undefined} options\n         * @memberof google.protobuf.EnumDescriptorProto\n         * @instance\n         */\n\n        EnumDescriptorProto.prototype.options = null;\n        /**\n         * Creates a new EnumDescriptorProto instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.EnumDescriptorProto\n         * @static\n         * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set\n         * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance\n         */\n\n        EnumDescriptorProto.create = function create(properties) {\n          return new EnumDescriptorProto(properties);\n        };\n        /**\n         * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.EnumDescriptorProto\n         * @static\n         * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EnumDescriptorProto.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.name);\n          if (message.value != null && message.value.length) for (var i = 0; i < message.value.length; ++i) {\n            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(\n            /* id 2, wireType 2 =*/\n            18).fork()).ldelim();\n          }\n          if (message.options != null && Object.hasOwnProperty.call(message, \"options\")) $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.EnumDescriptorProto\n         * @static\n         * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an EnumDescriptorProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.EnumDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EnumDescriptorProto.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.EnumDescriptorProto();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.name = reader.string();\n                break;\n\n              case 2:\n                if (!(message.value && message.value.length)) message.value = [];\n                message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));\n                break;\n\n              case 3:\n                message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.EnumDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an EnumDescriptorProto message.\n         * @function verify\n         * @memberof google.protobuf.EnumDescriptorProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        EnumDescriptorProto.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.name != null && message.hasOwnProperty(\"name\")) if (!$util.isString(message.name)) return \"name: string expected\";\n\n          if (message.value != null && message.hasOwnProperty(\"value\")) {\n            if (!Array.isArray(message.value)) return \"value: array expected\";\n\n            for (var i = 0; i < message.value.length; ++i) {\n              var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);\n              if (error) return \"value.\" + error;\n            }\n          }\n\n          if (message.options != null && message.hasOwnProperty(\"options\")) {\n            var error = $root.google.protobuf.EnumOptions.verify(message.options);\n            if (error) return \"options.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.EnumDescriptorProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto\n         */\n\n\n        EnumDescriptorProto.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.EnumDescriptorProto) return object;\n          var message = new $root.google.protobuf.EnumDescriptorProto();\n          if (object.name != null) message.name = String(object.name);\n\n          if (object.value) {\n            if (!Array.isArray(object.value)) throw TypeError(\".google.protobuf.EnumDescriptorProto.value: array expected\");\n            message.value = [];\n\n            for (var i = 0; i < object.value.length; ++i) {\n              if (typeof object.value[i] !== \"object\") throw TypeError(\".google.protobuf.EnumDescriptorProto.value: object expected\");\n              message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);\n            }\n          }\n\n          if (object.options != null) {\n            if (typeof object.options !== \"object\") throw TypeError(\".google.protobuf.EnumDescriptorProto.options: object expected\");\n            message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.EnumDescriptorProto\n         * @static\n         * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        EnumDescriptorProto.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.value = [];\n\n          if (options.defaults) {\n            object.name = \"\";\n            object.options = null;\n          }\n\n          if (message.name != null && message.hasOwnProperty(\"name\")) object.name = message.name;\n\n          if (message.value && message.value.length) {\n            object.value = [];\n\n            for (var j = 0; j < message.value.length; ++j) {\n              object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);\n            }\n          }\n\n          if (message.options != null && message.hasOwnProperty(\"options\")) object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);\n          return object;\n        };\n        /**\n         * Converts this EnumDescriptorProto to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.EnumDescriptorProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        EnumDescriptorProto.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return EnumDescriptorProto;\n      }();\n\n      protobuf.EnumValueDescriptorProto = function () {\n        /**\n         * Properties of an EnumValueDescriptorProto.\n         * @memberof google.protobuf\n         * @interface IEnumValueDescriptorProto\n         * @property {string|null} [name] EnumValueDescriptorProto name\n         * @property {number|null} [number] EnumValueDescriptorProto number\n         * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options\n         */\n\n        /**\n         * Constructs a new EnumValueDescriptorProto.\n         * @memberof google.protobuf\n         * @classdesc Represents an EnumValueDescriptorProto.\n         * @implements IEnumValueDescriptorProto\n         * @constructor\n         * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set\n         */\n        function EnumValueDescriptorProto(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * EnumValueDescriptorProto name.\n         * @member {string} name\n         * @memberof google.protobuf.EnumValueDescriptorProto\n         * @instance\n         */\n\n\n        EnumValueDescriptorProto.prototype.name = \"\";\n        /**\n         * EnumValueDescriptorProto number.\n         * @member {number} number\n         * @memberof google.protobuf.EnumValueDescriptorProto\n         * @instance\n         */\n\n        EnumValueDescriptorProto.prototype.number = 0;\n        /**\n         * EnumValueDescriptorProto options.\n         * @member {google.protobuf.IEnumValueOptions|null|undefined} options\n         * @memberof google.protobuf.EnumValueDescriptorProto\n         * @instance\n         */\n\n        EnumValueDescriptorProto.prototype.options = null;\n        /**\n         * Creates a new EnumValueDescriptorProto instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.EnumValueDescriptorProto\n         * @static\n         * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set\n         * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance\n         */\n\n        EnumValueDescriptorProto.create = function create(properties) {\n          return new EnumValueDescriptorProto(properties);\n        };\n        /**\n         * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.EnumValueDescriptorProto\n         * @static\n         * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EnumValueDescriptorProto.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.name);\n          if (message.number != null && Object.hasOwnProperty.call(message, \"number\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.number);\n          if (message.options != null && Object.hasOwnProperty.call(message, \"options\")) $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.EnumValueDescriptorProto\n         * @static\n         * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.EnumValueDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EnumValueDescriptorProto.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.EnumValueDescriptorProto();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.name = reader.string();\n                break;\n\n              case 2:\n                message.number = reader.int32();\n                break;\n\n              case 3:\n                message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.EnumValueDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an EnumValueDescriptorProto message.\n         * @function verify\n         * @memberof google.protobuf.EnumValueDescriptorProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        EnumValueDescriptorProto.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.name != null && message.hasOwnProperty(\"name\")) if (!$util.isString(message.name)) return \"name: string expected\";\n          if (message.number != null && message.hasOwnProperty(\"number\")) if (!$util.isInteger(message.number)) return \"number: integer expected\";\n\n          if (message.options != null && message.hasOwnProperty(\"options\")) {\n            var error = $root.google.protobuf.EnumValueOptions.verify(message.options);\n            if (error) return \"options.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.EnumValueDescriptorProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto\n         */\n\n\n        EnumValueDescriptorProto.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.EnumValueDescriptorProto) return object;\n          var message = new $root.google.protobuf.EnumValueDescriptorProto();\n          if (object.name != null) message.name = String(object.name);\n          if (object.number != null) message.number = object.number | 0;\n\n          if (object.options != null) {\n            if (typeof object.options !== \"object\") throw TypeError(\".google.protobuf.EnumValueDescriptorProto.options: object expected\");\n            message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.EnumValueDescriptorProto\n         * @static\n         * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        EnumValueDescriptorProto.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.name = \"\";\n            object.number = 0;\n            object.options = null;\n          }\n\n          if (message.name != null && message.hasOwnProperty(\"name\")) object.name = message.name;\n          if (message.number != null && message.hasOwnProperty(\"number\")) object.number = message.number;\n          if (message.options != null && message.hasOwnProperty(\"options\")) object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);\n          return object;\n        };\n        /**\n         * Converts this EnumValueDescriptorProto to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.EnumValueDescriptorProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        EnumValueDescriptorProto.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return EnumValueDescriptorProto;\n      }();\n\n      protobuf.ServiceDescriptorProto = function () {\n        /**\n         * Properties of a ServiceDescriptorProto.\n         * @memberof google.protobuf\n         * @interface IServiceDescriptorProto\n         * @property {string|null} [name] ServiceDescriptorProto name\n         * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method\n         * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options\n         */\n\n        /**\n         * Constructs a new ServiceDescriptorProto.\n         * @memberof google.protobuf\n         * @classdesc Represents a ServiceDescriptorProto.\n         * @implements IServiceDescriptorProto\n         * @constructor\n         * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set\n         */\n        function ServiceDescriptorProto(properties) {\n          this.method = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ServiceDescriptorProto name.\n         * @member {string} name\n         * @memberof google.protobuf.ServiceDescriptorProto\n         * @instance\n         */\n\n\n        ServiceDescriptorProto.prototype.name = \"\";\n        /**\n         * ServiceDescriptorProto method.\n         * @member {Array.<google.protobuf.IMethodDescriptorProto>} method\n         * @memberof google.protobuf.ServiceDescriptorProto\n         * @instance\n         */\n\n        ServiceDescriptorProto.prototype.method = $util.emptyArray;\n        /**\n         * ServiceDescriptorProto options.\n         * @member {google.protobuf.IServiceOptions|null|undefined} options\n         * @memberof google.protobuf.ServiceDescriptorProto\n         * @instance\n         */\n\n        ServiceDescriptorProto.prototype.options = null;\n        /**\n         * Creates a new ServiceDescriptorProto instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.ServiceDescriptorProto\n         * @static\n         * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set\n         * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance\n         */\n\n        ServiceDescriptorProto.create = function create(properties) {\n          return new ServiceDescriptorProto(properties);\n        };\n        /**\n         * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.ServiceDescriptorProto\n         * @static\n         * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ServiceDescriptorProto.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.name);\n          if (message.method != null && message.method.length) for (var i = 0; i < message.method.length; ++i) {\n            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(\n            /* id 2, wireType 2 =*/\n            18).fork()).ldelim();\n          }\n          if (message.options != null && Object.hasOwnProperty.call(message, \"options\")) $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).fork()).ldelim();\n          return writer;\n        };\n        /**\n         * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.ServiceDescriptorProto\n         * @static\n         * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ServiceDescriptorProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.ServiceDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ServiceDescriptorProto.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.ServiceDescriptorProto();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.name = reader.string();\n                break;\n\n              case 2:\n                if (!(message.method && message.method.length)) message.method = [];\n                message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));\n                break;\n\n              case 3:\n                message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.ServiceDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ServiceDescriptorProto message.\n         * @function verify\n         * @memberof google.protobuf.ServiceDescriptorProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ServiceDescriptorProto.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.name != null && message.hasOwnProperty(\"name\")) if (!$util.isString(message.name)) return \"name: string expected\";\n\n          if (message.method != null && message.hasOwnProperty(\"method\")) {\n            if (!Array.isArray(message.method)) return \"method: array expected\";\n\n            for (var i = 0; i < message.method.length; ++i) {\n              var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);\n              if (error) return \"method.\" + error;\n            }\n          }\n\n          if (message.options != null && message.hasOwnProperty(\"options\")) {\n            var error = $root.google.protobuf.ServiceOptions.verify(message.options);\n            if (error) return \"options.\" + error;\n          }\n\n          return null;\n        };\n        /**\n         * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.ServiceDescriptorProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto\n         */\n\n\n        ServiceDescriptorProto.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.ServiceDescriptorProto) return object;\n          var message = new $root.google.protobuf.ServiceDescriptorProto();\n          if (object.name != null) message.name = String(object.name);\n\n          if (object.method) {\n            if (!Array.isArray(object.method)) throw TypeError(\".google.protobuf.ServiceDescriptorProto.method: array expected\");\n            message.method = [];\n\n            for (var i = 0; i < object.method.length; ++i) {\n              if (typeof object.method[i] !== \"object\") throw TypeError(\".google.protobuf.ServiceDescriptorProto.method: object expected\");\n              message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);\n            }\n          }\n\n          if (object.options != null) {\n            if (typeof object.options !== \"object\") throw TypeError(\".google.protobuf.ServiceDescriptorProto.options: object expected\");\n            message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.ServiceDescriptorProto\n         * @static\n         * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ServiceDescriptorProto.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.method = [];\n\n          if (options.defaults) {\n            object.name = \"\";\n            object.options = null;\n          }\n\n          if (message.name != null && message.hasOwnProperty(\"name\")) object.name = message.name;\n\n          if (message.method && message.method.length) {\n            object.method = [];\n\n            for (var j = 0; j < message.method.length; ++j) {\n              object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);\n            }\n          }\n\n          if (message.options != null && message.hasOwnProperty(\"options\")) object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);\n          return object;\n        };\n        /**\n         * Converts this ServiceDescriptorProto to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.ServiceDescriptorProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ServiceDescriptorProto.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ServiceDescriptorProto;\n      }();\n\n      protobuf.MethodDescriptorProto = function () {\n        /**\n         * Properties of a MethodDescriptorProto.\n         * @memberof google.protobuf\n         * @interface IMethodDescriptorProto\n         * @property {string|null} [name] MethodDescriptorProto name\n         * @property {string|null} [inputType] MethodDescriptorProto inputType\n         * @property {string|null} [outputType] MethodDescriptorProto outputType\n         * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options\n         * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming\n         * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming\n         */\n\n        /**\n         * Constructs a new MethodDescriptorProto.\n         * @memberof google.protobuf\n         * @classdesc Represents a MethodDescriptorProto.\n         * @implements IMethodDescriptorProto\n         * @constructor\n         * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set\n         */\n        function MethodDescriptorProto(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * MethodDescriptorProto name.\n         * @member {string} name\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @instance\n         */\n\n\n        MethodDescriptorProto.prototype.name = \"\";\n        /**\n         * MethodDescriptorProto inputType.\n         * @member {string} inputType\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @instance\n         */\n\n        MethodDescriptorProto.prototype.inputType = \"\";\n        /**\n         * MethodDescriptorProto outputType.\n         * @member {string} outputType\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @instance\n         */\n\n        MethodDescriptorProto.prototype.outputType = \"\";\n        /**\n         * MethodDescriptorProto options.\n         * @member {google.protobuf.IMethodOptions|null|undefined} options\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @instance\n         */\n\n        MethodDescriptorProto.prototype.options = null;\n        /**\n         * MethodDescriptorProto clientStreaming.\n         * @member {boolean} clientStreaming\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @instance\n         */\n\n        MethodDescriptorProto.prototype.clientStreaming = false;\n        /**\n         * MethodDescriptorProto serverStreaming.\n         * @member {boolean} serverStreaming\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @instance\n         */\n\n        MethodDescriptorProto.prototype.serverStreaming = false;\n        /**\n         * Creates a new MethodDescriptorProto instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @static\n         * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set\n         * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance\n         */\n\n        MethodDescriptorProto.create = function create(properties) {\n          return new MethodDescriptorProto(properties);\n        };\n        /**\n         * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @static\n         * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        MethodDescriptorProto.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.name);\n          if (message.inputType != null && Object.hasOwnProperty.call(message, \"inputType\")) writer.uint32(\n          /* id 2, wireType 2 =*/\n          18).string(message.inputType);\n          if (message.outputType != null && Object.hasOwnProperty.call(message, \"outputType\")) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).string(message.outputType);\n          if (message.options != null && Object.hasOwnProperty.call(message, \"options\")) $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).fork()).ldelim();\n          if (message.clientStreaming != null && Object.hasOwnProperty.call(message, \"clientStreaming\")) writer.uint32(\n          /* id 5, wireType 0 =*/\n          40).bool(message.clientStreaming);\n          if (message.serverStreaming != null && Object.hasOwnProperty.call(message, \"serverStreaming\")) writer.uint32(\n          /* id 6, wireType 0 =*/\n          48).bool(message.serverStreaming);\n          return writer;\n        };\n        /**\n         * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @static\n         * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a MethodDescriptorProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        MethodDescriptorProto.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.MethodDescriptorProto();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.name = reader.string();\n                break;\n\n              case 2:\n                message.inputType = reader.string();\n                break;\n\n              case 3:\n                message.outputType = reader.string();\n                break;\n\n              case 4:\n                message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());\n                break;\n\n              case 5:\n                message.clientStreaming = reader.bool();\n                break;\n\n              case 6:\n                message.serverStreaming = reader.bool();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a MethodDescriptorProto message.\n         * @function verify\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        MethodDescriptorProto.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.name != null && message.hasOwnProperty(\"name\")) if (!$util.isString(message.name)) return \"name: string expected\";\n          if (message.inputType != null && message.hasOwnProperty(\"inputType\")) if (!$util.isString(message.inputType)) return \"inputType: string expected\";\n          if (message.outputType != null && message.hasOwnProperty(\"outputType\")) if (!$util.isString(message.outputType)) return \"outputType: string expected\";\n\n          if (message.options != null && message.hasOwnProperty(\"options\")) {\n            var error = $root.google.protobuf.MethodOptions.verify(message.options);\n            if (error) return \"options.\" + error;\n          }\n\n          if (message.clientStreaming != null && message.hasOwnProperty(\"clientStreaming\")) if (typeof message.clientStreaming !== \"boolean\") return \"clientStreaming: boolean expected\";\n          if (message.serverStreaming != null && message.hasOwnProperty(\"serverStreaming\")) if (typeof message.serverStreaming !== \"boolean\") return \"serverStreaming: boolean expected\";\n          return null;\n        };\n        /**\n         * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto\n         */\n\n\n        MethodDescriptorProto.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.MethodDescriptorProto) return object;\n          var message = new $root.google.protobuf.MethodDescriptorProto();\n          if (object.name != null) message.name = String(object.name);\n          if (object.inputType != null) message.inputType = String(object.inputType);\n          if (object.outputType != null) message.outputType = String(object.outputType);\n\n          if (object.options != null) {\n            if (typeof object.options !== \"object\") throw TypeError(\".google.protobuf.MethodDescriptorProto.options: object expected\");\n            message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);\n          }\n\n          if (object.clientStreaming != null) message.clientStreaming = Boolean(object.clientStreaming);\n          if (object.serverStreaming != null) message.serverStreaming = Boolean(object.serverStreaming);\n          return message;\n        };\n        /**\n         * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @static\n         * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        MethodDescriptorProto.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.name = \"\";\n            object.inputType = \"\";\n            object.outputType = \"\";\n            object.options = null;\n            object.clientStreaming = false;\n            object.serverStreaming = false;\n          }\n\n          if (message.name != null && message.hasOwnProperty(\"name\")) object.name = message.name;\n          if (message.inputType != null && message.hasOwnProperty(\"inputType\")) object.inputType = message.inputType;\n          if (message.outputType != null && message.hasOwnProperty(\"outputType\")) object.outputType = message.outputType;\n          if (message.options != null && message.hasOwnProperty(\"options\")) object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);\n          if (message.clientStreaming != null && message.hasOwnProperty(\"clientStreaming\")) object.clientStreaming = message.clientStreaming;\n          if (message.serverStreaming != null && message.hasOwnProperty(\"serverStreaming\")) object.serverStreaming = message.serverStreaming;\n          return object;\n        };\n        /**\n         * Converts this MethodDescriptorProto to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.MethodDescriptorProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        MethodDescriptorProto.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return MethodDescriptorProto;\n      }();\n\n      protobuf.FileOptions = function () {\n        /**\n         * Properties of a FileOptions.\n         * @memberof google.protobuf\n         * @interface IFileOptions\n         * @property {string|null} [javaPackage] FileOptions javaPackage\n         * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname\n         * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles\n         * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash\n         * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8\n         * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor\n         * @property {string|null} [goPackage] FileOptions goPackage\n         * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices\n         * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices\n         * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices\n         * @property {boolean|null} [deprecated] FileOptions deprecated\n         * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas\n         * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix\n         * @property {string|null} [csharpNamespace] FileOptions csharpNamespace\n         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption\n         * @property {boolean|null} [\".gogoproto.goprotoGettersAll\"] FileOptions .gogoproto.goprotoGettersAll\n         * @property {boolean|null} [\".gogoproto.goprotoEnumPrefixAll\"] FileOptions .gogoproto.goprotoEnumPrefixAll\n         * @property {boolean|null} [\".gogoproto.goprotoStringerAll\"] FileOptions .gogoproto.goprotoStringerAll\n         * @property {boolean|null} [\".gogoproto.verboseEqualAll\"] FileOptions .gogoproto.verboseEqualAll\n         * @property {boolean|null} [\".gogoproto.faceAll\"] FileOptions .gogoproto.faceAll\n         * @property {boolean|null} [\".gogoproto.gostringAll\"] FileOptions .gogoproto.gostringAll\n         * @property {boolean|null} [\".gogoproto.populateAll\"] FileOptions .gogoproto.populateAll\n         * @property {boolean|null} [\".gogoproto.stringerAll\"] FileOptions .gogoproto.stringerAll\n         * @property {boolean|null} [\".gogoproto.onlyoneAll\"] FileOptions .gogoproto.onlyoneAll\n         * @property {boolean|null} [\".gogoproto.equalAll\"] FileOptions .gogoproto.equalAll\n         * @property {boolean|null} [\".gogoproto.descriptionAll\"] FileOptions .gogoproto.descriptionAll\n         * @property {boolean|null} [\".gogoproto.testgenAll\"] FileOptions .gogoproto.testgenAll\n         * @property {boolean|null} [\".gogoproto.benchgenAll\"] FileOptions .gogoproto.benchgenAll\n         * @property {boolean|null} [\".gogoproto.marshalerAll\"] FileOptions .gogoproto.marshalerAll\n         * @property {boolean|null} [\".gogoproto.unmarshalerAll\"] FileOptions .gogoproto.unmarshalerAll\n         * @property {boolean|null} [\".gogoproto.stableMarshalerAll\"] FileOptions .gogoproto.stableMarshalerAll\n         * @property {boolean|null} [\".gogoproto.sizerAll\"] FileOptions .gogoproto.sizerAll\n         * @property {boolean|null} [\".gogoproto.goprotoEnumStringerAll\"] FileOptions .gogoproto.goprotoEnumStringerAll\n         * @property {boolean|null} [\".gogoproto.enumStringerAll\"] FileOptions .gogoproto.enumStringerAll\n         * @property {boolean|null} [\".gogoproto.unsafeMarshalerAll\"] FileOptions .gogoproto.unsafeMarshalerAll\n         * @property {boolean|null} [\".gogoproto.unsafeUnmarshalerAll\"] FileOptions .gogoproto.unsafeUnmarshalerAll\n         * @property {boolean|null} [\".gogoproto.goprotoExtensionsMapAll\"] FileOptions .gogoproto.goprotoExtensionsMapAll\n         * @property {boolean|null} [\".gogoproto.goprotoUnrecognizedAll\"] FileOptions .gogoproto.goprotoUnrecognizedAll\n         * @property {boolean|null} [\".gogoproto.gogoprotoImport\"] FileOptions .gogoproto.gogoprotoImport\n         * @property {boolean|null} [\".gogoproto.protosizerAll\"] FileOptions .gogoproto.protosizerAll\n         * @property {boolean|null} [\".gogoproto.compareAll\"] FileOptions .gogoproto.compareAll\n         * @property {boolean|null} [\".gogoproto.typedeclAll\"] FileOptions .gogoproto.typedeclAll\n         * @property {boolean|null} [\".gogoproto.enumdeclAll\"] FileOptions .gogoproto.enumdeclAll\n         * @property {boolean|null} [\".gogoproto.goprotoRegistration\"] FileOptions .gogoproto.goprotoRegistration\n         * @property {boolean|null} [\".gogoproto.messagenameAll\"] FileOptions .gogoproto.messagenameAll\n         * @property {boolean|null} [\".gogoproto.goprotoSizecacheAll\"] FileOptions .gogoproto.goprotoSizecacheAll\n         * @property {boolean|null} [\".gogoproto.goprotoUnkeyedAll\"] FileOptions .gogoproto.goprotoUnkeyedAll\n         */\n\n        /**\n         * Constructs a new FileOptions.\n         * @memberof google.protobuf\n         * @classdesc Represents a FileOptions.\n         * @implements IFileOptions\n         * @constructor\n         * @param {google.protobuf.IFileOptions=} [properties] Properties to set\n         */\n        function FileOptions(properties) {\n          this.uninterpretedOption = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * FileOptions javaPackage.\n         * @member {string} javaPackage\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n\n        FileOptions.prototype.javaPackage = \"\";\n        /**\n         * FileOptions javaOuterClassname.\n         * @member {string} javaOuterClassname\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.javaOuterClassname = \"\";\n        /**\n         * FileOptions javaMultipleFiles.\n         * @member {boolean} javaMultipleFiles\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.javaMultipleFiles = false;\n        /**\n         * FileOptions javaGenerateEqualsAndHash.\n         * @member {boolean} javaGenerateEqualsAndHash\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.javaGenerateEqualsAndHash = false;\n        /**\n         * FileOptions javaStringCheckUtf8.\n         * @member {boolean} javaStringCheckUtf8\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.javaStringCheckUtf8 = false;\n        /**\n         * FileOptions optimizeFor.\n         * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.optimizeFor = 1;\n        /**\n         * FileOptions goPackage.\n         * @member {string} goPackage\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.goPackage = \"\";\n        /**\n         * FileOptions ccGenericServices.\n         * @member {boolean} ccGenericServices\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.ccGenericServices = false;\n        /**\n         * FileOptions javaGenericServices.\n         * @member {boolean} javaGenericServices\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.javaGenericServices = false;\n        /**\n         * FileOptions pyGenericServices.\n         * @member {boolean} pyGenericServices\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.pyGenericServices = false;\n        /**\n         * FileOptions deprecated.\n         * @member {boolean} deprecated\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.deprecated = false;\n        /**\n         * FileOptions ccEnableArenas.\n         * @member {boolean} ccEnableArenas\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.ccEnableArenas = false;\n        /**\n         * FileOptions objcClassPrefix.\n         * @member {string} objcClassPrefix\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.objcClassPrefix = \"\";\n        /**\n         * FileOptions csharpNamespace.\n         * @member {string} csharpNamespace\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.csharpNamespace = \"\";\n        /**\n         * FileOptions uninterpretedOption.\n         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype.uninterpretedOption = $util.emptyArray;\n        /**\n         * FileOptions .gogoproto.goprotoGettersAll.\n         * @member {boolean} .gogoproto.goprotoGettersAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.goprotoGettersAll\"] = false;\n        /**\n         * FileOptions .gogoproto.goprotoEnumPrefixAll.\n         * @member {boolean} .gogoproto.goprotoEnumPrefixAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.goprotoEnumPrefixAll\"] = false;\n        /**\n         * FileOptions .gogoproto.goprotoStringerAll.\n         * @member {boolean} .gogoproto.goprotoStringerAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.goprotoStringerAll\"] = false;\n        /**\n         * FileOptions .gogoproto.verboseEqualAll.\n         * @member {boolean} .gogoproto.verboseEqualAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.verboseEqualAll\"] = false;\n        /**\n         * FileOptions .gogoproto.faceAll.\n         * @member {boolean} .gogoproto.faceAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.faceAll\"] = false;\n        /**\n         * FileOptions .gogoproto.gostringAll.\n         * @member {boolean} .gogoproto.gostringAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.gostringAll\"] = false;\n        /**\n         * FileOptions .gogoproto.populateAll.\n         * @member {boolean} .gogoproto.populateAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.populateAll\"] = false;\n        /**\n         * FileOptions .gogoproto.stringerAll.\n         * @member {boolean} .gogoproto.stringerAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.stringerAll\"] = false;\n        /**\n         * FileOptions .gogoproto.onlyoneAll.\n         * @member {boolean} .gogoproto.onlyoneAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.onlyoneAll\"] = false;\n        /**\n         * FileOptions .gogoproto.equalAll.\n         * @member {boolean} .gogoproto.equalAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.equalAll\"] = false;\n        /**\n         * FileOptions .gogoproto.descriptionAll.\n         * @member {boolean} .gogoproto.descriptionAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.descriptionAll\"] = false;\n        /**\n         * FileOptions .gogoproto.testgenAll.\n         * @member {boolean} .gogoproto.testgenAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.testgenAll\"] = false;\n        /**\n         * FileOptions .gogoproto.benchgenAll.\n         * @member {boolean} .gogoproto.benchgenAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.benchgenAll\"] = false;\n        /**\n         * FileOptions .gogoproto.marshalerAll.\n         * @member {boolean} .gogoproto.marshalerAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.marshalerAll\"] = false;\n        /**\n         * FileOptions .gogoproto.unmarshalerAll.\n         * @member {boolean} .gogoproto.unmarshalerAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.unmarshalerAll\"] = false;\n        /**\n         * FileOptions .gogoproto.stableMarshalerAll.\n         * @member {boolean} .gogoproto.stableMarshalerAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.stableMarshalerAll\"] = false;\n        /**\n         * FileOptions .gogoproto.sizerAll.\n         * @member {boolean} .gogoproto.sizerAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.sizerAll\"] = false;\n        /**\n         * FileOptions .gogoproto.goprotoEnumStringerAll.\n         * @member {boolean} .gogoproto.goprotoEnumStringerAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.goprotoEnumStringerAll\"] = false;\n        /**\n         * FileOptions .gogoproto.enumStringerAll.\n         * @member {boolean} .gogoproto.enumStringerAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.enumStringerAll\"] = false;\n        /**\n         * FileOptions .gogoproto.unsafeMarshalerAll.\n         * @member {boolean} .gogoproto.unsafeMarshalerAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.unsafeMarshalerAll\"] = false;\n        /**\n         * FileOptions .gogoproto.unsafeUnmarshalerAll.\n         * @member {boolean} .gogoproto.unsafeUnmarshalerAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.unsafeUnmarshalerAll\"] = false;\n        /**\n         * FileOptions .gogoproto.goprotoExtensionsMapAll.\n         * @member {boolean} .gogoproto.goprotoExtensionsMapAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.goprotoExtensionsMapAll\"] = false;\n        /**\n         * FileOptions .gogoproto.goprotoUnrecognizedAll.\n         * @member {boolean} .gogoproto.goprotoUnrecognizedAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.goprotoUnrecognizedAll\"] = false;\n        /**\n         * FileOptions .gogoproto.gogoprotoImport.\n         * @member {boolean} .gogoproto.gogoprotoImport\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.gogoprotoImport\"] = false;\n        /**\n         * FileOptions .gogoproto.protosizerAll.\n         * @member {boolean} .gogoproto.protosizerAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.protosizerAll\"] = false;\n        /**\n         * FileOptions .gogoproto.compareAll.\n         * @member {boolean} .gogoproto.compareAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.compareAll\"] = false;\n        /**\n         * FileOptions .gogoproto.typedeclAll.\n         * @member {boolean} .gogoproto.typedeclAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.typedeclAll\"] = false;\n        /**\n         * FileOptions .gogoproto.enumdeclAll.\n         * @member {boolean} .gogoproto.enumdeclAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.enumdeclAll\"] = false;\n        /**\n         * FileOptions .gogoproto.goprotoRegistration.\n         * @member {boolean} .gogoproto.goprotoRegistration\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.goprotoRegistration\"] = false;\n        /**\n         * FileOptions .gogoproto.messagenameAll.\n         * @member {boolean} .gogoproto.messagenameAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.messagenameAll\"] = false;\n        /**\n         * FileOptions .gogoproto.goprotoSizecacheAll.\n         * @member {boolean} .gogoproto.goprotoSizecacheAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.goprotoSizecacheAll\"] = false;\n        /**\n         * FileOptions .gogoproto.goprotoUnkeyedAll.\n         * @member {boolean} .gogoproto.goprotoUnkeyedAll\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         */\n\n        FileOptions.prototype[\".gogoproto.goprotoUnkeyedAll\"] = false;\n        /**\n         * Creates a new FileOptions instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.FileOptions\n         * @static\n         * @param {google.protobuf.IFileOptions=} [properties] Properties to set\n         * @returns {google.protobuf.FileOptions} FileOptions instance\n         */\n\n        FileOptions.create = function create(properties) {\n          return new FileOptions(properties);\n        };\n        /**\n         * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.FileOptions\n         * @static\n         * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        FileOptions.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.javaPackage != null && Object.hasOwnProperty.call(message, \"javaPackage\")) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.javaPackage);\n          if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, \"javaOuterClassname\")) writer.uint32(\n          /* id 8, wireType 2 =*/\n          66).string(message.javaOuterClassname);\n          if (message.optimizeFor != null && Object.hasOwnProperty.call(message, \"optimizeFor\")) writer.uint32(\n          /* id 9, wireType 0 =*/\n          72).int32(message.optimizeFor);\n          if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, \"javaMultipleFiles\")) writer.uint32(\n          /* id 10, wireType 0 =*/\n          80).bool(message.javaMultipleFiles);\n          if (message.goPackage != null && Object.hasOwnProperty.call(message, \"goPackage\")) writer.uint32(\n          /* id 11, wireType 2 =*/\n          90).string(message.goPackage);\n          if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, \"ccGenericServices\")) writer.uint32(\n          /* id 16, wireType 0 =*/\n          128).bool(message.ccGenericServices);\n          if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, \"javaGenericServices\")) writer.uint32(\n          /* id 17, wireType 0 =*/\n          136).bool(message.javaGenericServices);\n          if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, \"pyGenericServices\")) writer.uint32(\n          /* id 18, wireType 0 =*/\n          144).bool(message.pyGenericServices);\n          if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, \"javaGenerateEqualsAndHash\")) writer.uint32(\n          /* id 20, wireType 0 =*/\n          160).bool(message.javaGenerateEqualsAndHash);\n          if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\")) writer.uint32(\n          /* id 23, wireType 0 =*/\n          184).bool(message.deprecated);\n          if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, \"javaStringCheckUtf8\")) writer.uint32(\n          /* id 27, wireType 0 =*/\n          216).bool(message.javaStringCheckUtf8);\n          if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, \"ccEnableArenas\")) writer.uint32(\n          /* id 31, wireType 0 =*/\n          248).bool(message.ccEnableArenas);\n          if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, \"objcClassPrefix\")) writer.uint32(\n          /* id 36, wireType 2 =*/\n          290).string(message.objcClassPrefix);\n          if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, \"csharpNamespace\")) writer.uint32(\n          /* id 37, wireType 2 =*/\n          298).string(message.csharpNamespace);\n          if (message.uninterpretedOption != null && message.uninterpretedOption.length) for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(\n            /* id 999, wireType 2 =*/\n            7994).fork()).ldelim();\n          }\n          if (message[\".gogoproto.goprotoGettersAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoGettersAll\")) writer.uint32(\n          /* id 63001, wireType 0 =*/\n          504008).bool(message[\".gogoproto.goprotoGettersAll\"]);\n          if (message[\".gogoproto.goprotoEnumPrefixAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoEnumPrefixAll\")) writer.uint32(\n          /* id 63002, wireType 0 =*/\n          504016).bool(message[\".gogoproto.goprotoEnumPrefixAll\"]);\n          if (message[\".gogoproto.goprotoStringerAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoStringerAll\")) writer.uint32(\n          /* id 63003, wireType 0 =*/\n          504024).bool(message[\".gogoproto.goprotoStringerAll\"]);\n          if (message[\".gogoproto.verboseEqualAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.verboseEqualAll\")) writer.uint32(\n          /* id 63004, wireType 0 =*/\n          504032).bool(message[\".gogoproto.verboseEqualAll\"]);\n          if (message[\".gogoproto.faceAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.faceAll\")) writer.uint32(\n          /* id 63005, wireType 0 =*/\n          504040).bool(message[\".gogoproto.faceAll\"]);\n          if (message[\".gogoproto.gostringAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.gostringAll\")) writer.uint32(\n          /* id 63006, wireType 0 =*/\n          504048).bool(message[\".gogoproto.gostringAll\"]);\n          if (message[\".gogoproto.populateAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.populateAll\")) writer.uint32(\n          /* id 63007, wireType 0 =*/\n          504056).bool(message[\".gogoproto.populateAll\"]);\n          if (message[\".gogoproto.stringerAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.stringerAll\")) writer.uint32(\n          /* id 63008, wireType 0 =*/\n          504064).bool(message[\".gogoproto.stringerAll\"]);\n          if (message[\".gogoproto.onlyoneAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.onlyoneAll\")) writer.uint32(\n          /* id 63009, wireType 0 =*/\n          504072).bool(message[\".gogoproto.onlyoneAll\"]);\n          if (message[\".gogoproto.equalAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.equalAll\")) writer.uint32(\n          /* id 63013, wireType 0 =*/\n          504104).bool(message[\".gogoproto.equalAll\"]);\n          if (message[\".gogoproto.descriptionAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.descriptionAll\")) writer.uint32(\n          /* id 63014, wireType 0 =*/\n          504112).bool(message[\".gogoproto.descriptionAll\"]);\n          if (message[\".gogoproto.testgenAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.testgenAll\")) writer.uint32(\n          /* id 63015, wireType 0 =*/\n          504120).bool(message[\".gogoproto.testgenAll\"]);\n          if (message[\".gogoproto.benchgenAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.benchgenAll\")) writer.uint32(\n          /* id 63016, wireType 0 =*/\n          504128).bool(message[\".gogoproto.benchgenAll\"]);\n          if (message[\".gogoproto.marshalerAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.marshalerAll\")) writer.uint32(\n          /* id 63017, wireType 0 =*/\n          504136).bool(message[\".gogoproto.marshalerAll\"]);\n          if (message[\".gogoproto.unmarshalerAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.unmarshalerAll\")) writer.uint32(\n          /* id 63018, wireType 0 =*/\n          504144).bool(message[\".gogoproto.unmarshalerAll\"]);\n          if (message[\".gogoproto.stableMarshalerAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.stableMarshalerAll\")) writer.uint32(\n          /* id 63019, wireType 0 =*/\n          504152).bool(message[\".gogoproto.stableMarshalerAll\"]);\n          if (message[\".gogoproto.sizerAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.sizerAll\")) writer.uint32(\n          /* id 63020, wireType 0 =*/\n          504160).bool(message[\".gogoproto.sizerAll\"]);\n          if (message[\".gogoproto.goprotoEnumStringerAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoEnumStringerAll\")) writer.uint32(\n          /* id 63021, wireType 0 =*/\n          504168).bool(message[\".gogoproto.goprotoEnumStringerAll\"]);\n          if (message[\".gogoproto.enumStringerAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.enumStringerAll\")) writer.uint32(\n          /* id 63022, wireType 0 =*/\n          504176).bool(message[\".gogoproto.enumStringerAll\"]);\n          if (message[\".gogoproto.unsafeMarshalerAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.unsafeMarshalerAll\")) writer.uint32(\n          /* id 63023, wireType 0 =*/\n          504184).bool(message[\".gogoproto.unsafeMarshalerAll\"]);\n          if (message[\".gogoproto.unsafeUnmarshalerAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.unsafeUnmarshalerAll\")) writer.uint32(\n          /* id 63024, wireType 0 =*/\n          504192).bool(message[\".gogoproto.unsafeUnmarshalerAll\"]);\n          if (message[\".gogoproto.goprotoExtensionsMapAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoExtensionsMapAll\")) writer.uint32(\n          /* id 63025, wireType 0 =*/\n          504200).bool(message[\".gogoproto.goprotoExtensionsMapAll\"]);\n          if (message[\".gogoproto.goprotoUnrecognizedAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoUnrecognizedAll\")) writer.uint32(\n          /* id 63026, wireType 0 =*/\n          504208).bool(message[\".gogoproto.goprotoUnrecognizedAll\"]);\n          if (message[\".gogoproto.gogoprotoImport\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.gogoprotoImport\")) writer.uint32(\n          /* id 63027, wireType 0 =*/\n          504216).bool(message[\".gogoproto.gogoprotoImport\"]);\n          if (message[\".gogoproto.protosizerAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.protosizerAll\")) writer.uint32(\n          /* id 63028, wireType 0 =*/\n          504224).bool(message[\".gogoproto.protosizerAll\"]);\n          if (message[\".gogoproto.compareAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.compareAll\")) writer.uint32(\n          /* id 63029, wireType 0 =*/\n          504232).bool(message[\".gogoproto.compareAll\"]);\n          if (message[\".gogoproto.typedeclAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.typedeclAll\")) writer.uint32(\n          /* id 63030, wireType 0 =*/\n          504240).bool(message[\".gogoproto.typedeclAll\"]);\n          if (message[\".gogoproto.enumdeclAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.enumdeclAll\")) writer.uint32(\n          /* id 63031, wireType 0 =*/\n          504248).bool(message[\".gogoproto.enumdeclAll\"]);\n          if (message[\".gogoproto.goprotoRegistration\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoRegistration\")) writer.uint32(\n          /* id 63032, wireType 0 =*/\n          504256).bool(message[\".gogoproto.goprotoRegistration\"]);\n          if (message[\".gogoproto.messagenameAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.messagenameAll\")) writer.uint32(\n          /* id 63033, wireType 0 =*/\n          504264).bool(message[\".gogoproto.messagenameAll\"]);\n          if (message[\".gogoproto.goprotoSizecacheAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoSizecacheAll\")) writer.uint32(\n          /* id 63034, wireType 0 =*/\n          504272).bool(message[\".gogoproto.goprotoSizecacheAll\"]);\n          if (message[\".gogoproto.goprotoUnkeyedAll\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoUnkeyedAll\")) writer.uint32(\n          /* id 63035, wireType 0 =*/\n          504280).bool(message[\".gogoproto.goprotoUnkeyedAll\"]);\n          return writer;\n        };\n        /**\n         * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.FileOptions\n         * @static\n         * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        FileOptions.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a FileOptions message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.FileOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.FileOptions} FileOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        FileOptions.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.FileOptions();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.javaPackage = reader.string();\n                break;\n\n              case 8:\n                message.javaOuterClassname = reader.string();\n                break;\n\n              case 10:\n                message.javaMultipleFiles = reader.bool();\n                break;\n\n              case 20:\n                message.javaGenerateEqualsAndHash = reader.bool();\n                break;\n\n              case 27:\n                message.javaStringCheckUtf8 = reader.bool();\n                break;\n\n              case 9:\n                message.optimizeFor = reader.int32();\n                break;\n\n              case 11:\n                message.goPackage = reader.string();\n                break;\n\n              case 16:\n                message.ccGenericServices = reader.bool();\n                break;\n\n              case 17:\n                message.javaGenericServices = reader.bool();\n                break;\n\n              case 18:\n                message.pyGenericServices = reader.bool();\n                break;\n\n              case 23:\n                message.deprecated = reader.bool();\n                break;\n\n              case 31:\n                message.ccEnableArenas = reader.bool();\n                break;\n\n              case 36:\n                message.objcClassPrefix = reader.string();\n                break;\n\n              case 37:\n                message.csharpNamespace = reader.string();\n                break;\n\n              case 999:\n                if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                break;\n\n              case 63001:\n                message[\".gogoproto.goprotoGettersAll\"] = reader.bool();\n                break;\n\n              case 63002:\n                message[\".gogoproto.goprotoEnumPrefixAll\"] = reader.bool();\n                break;\n\n              case 63003:\n                message[\".gogoproto.goprotoStringerAll\"] = reader.bool();\n                break;\n\n              case 63004:\n                message[\".gogoproto.verboseEqualAll\"] = reader.bool();\n                break;\n\n              case 63005:\n                message[\".gogoproto.faceAll\"] = reader.bool();\n                break;\n\n              case 63006:\n                message[\".gogoproto.gostringAll\"] = reader.bool();\n                break;\n\n              case 63007:\n                message[\".gogoproto.populateAll\"] = reader.bool();\n                break;\n\n              case 63008:\n                message[\".gogoproto.stringerAll\"] = reader.bool();\n                break;\n\n              case 63009:\n                message[\".gogoproto.onlyoneAll\"] = reader.bool();\n                break;\n\n              case 63013:\n                message[\".gogoproto.equalAll\"] = reader.bool();\n                break;\n\n              case 63014:\n                message[\".gogoproto.descriptionAll\"] = reader.bool();\n                break;\n\n              case 63015:\n                message[\".gogoproto.testgenAll\"] = reader.bool();\n                break;\n\n              case 63016:\n                message[\".gogoproto.benchgenAll\"] = reader.bool();\n                break;\n\n              case 63017:\n                message[\".gogoproto.marshalerAll\"] = reader.bool();\n                break;\n\n              case 63018:\n                message[\".gogoproto.unmarshalerAll\"] = reader.bool();\n                break;\n\n              case 63019:\n                message[\".gogoproto.stableMarshalerAll\"] = reader.bool();\n                break;\n\n              case 63020:\n                message[\".gogoproto.sizerAll\"] = reader.bool();\n                break;\n\n              case 63021:\n                message[\".gogoproto.goprotoEnumStringerAll\"] = reader.bool();\n                break;\n\n              case 63022:\n                message[\".gogoproto.enumStringerAll\"] = reader.bool();\n                break;\n\n              case 63023:\n                message[\".gogoproto.unsafeMarshalerAll\"] = reader.bool();\n                break;\n\n              case 63024:\n                message[\".gogoproto.unsafeUnmarshalerAll\"] = reader.bool();\n                break;\n\n              case 63025:\n                message[\".gogoproto.goprotoExtensionsMapAll\"] = reader.bool();\n                break;\n\n              case 63026:\n                message[\".gogoproto.goprotoUnrecognizedAll\"] = reader.bool();\n                break;\n\n              case 63027:\n                message[\".gogoproto.gogoprotoImport\"] = reader.bool();\n                break;\n\n              case 63028:\n                message[\".gogoproto.protosizerAll\"] = reader.bool();\n                break;\n\n              case 63029:\n                message[\".gogoproto.compareAll\"] = reader.bool();\n                break;\n\n              case 63030:\n                message[\".gogoproto.typedeclAll\"] = reader.bool();\n                break;\n\n              case 63031:\n                message[\".gogoproto.enumdeclAll\"] = reader.bool();\n                break;\n\n              case 63032:\n                message[\".gogoproto.goprotoRegistration\"] = reader.bool();\n                break;\n\n              case 63033:\n                message[\".gogoproto.messagenameAll\"] = reader.bool();\n                break;\n\n              case 63034:\n                message[\".gogoproto.goprotoSizecacheAll\"] = reader.bool();\n                break;\n\n              case 63035:\n                message[\".gogoproto.goprotoUnkeyedAll\"] = reader.bool();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a FileOptions message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.FileOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.FileOptions} FileOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        FileOptions.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a FileOptions message.\n         * @function verify\n         * @memberof google.protobuf.FileOptions\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        FileOptions.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.javaPackage != null && message.hasOwnProperty(\"javaPackage\")) if (!$util.isString(message.javaPackage)) return \"javaPackage: string expected\";\n          if (message.javaOuterClassname != null && message.hasOwnProperty(\"javaOuterClassname\")) if (!$util.isString(message.javaOuterClassname)) return \"javaOuterClassname: string expected\";\n          if (message.javaMultipleFiles != null && message.hasOwnProperty(\"javaMultipleFiles\")) if (typeof message.javaMultipleFiles !== \"boolean\") return \"javaMultipleFiles: boolean expected\";\n          if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty(\"javaGenerateEqualsAndHash\")) if (typeof message.javaGenerateEqualsAndHash !== \"boolean\") return \"javaGenerateEqualsAndHash: boolean expected\";\n          if (message.javaStringCheckUtf8 != null && message.hasOwnProperty(\"javaStringCheckUtf8\")) if (typeof message.javaStringCheckUtf8 !== \"boolean\") return \"javaStringCheckUtf8: boolean expected\";\n          if (message.optimizeFor != null && message.hasOwnProperty(\"optimizeFor\")) switch (message.optimizeFor) {\n            default:\n              return \"optimizeFor: enum value expected\";\n\n            case 1:\n            case 2:\n            case 3:\n              break;\n          }\n          if (message.goPackage != null && message.hasOwnProperty(\"goPackage\")) if (!$util.isString(message.goPackage)) return \"goPackage: string expected\";\n          if (message.ccGenericServices != null && message.hasOwnProperty(\"ccGenericServices\")) if (typeof message.ccGenericServices !== \"boolean\") return \"ccGenericServices: boolean expected\";\n          if (message.javaGenericServices != null && message.hasOwnProperty(\"javaGenericServices\")) if (typeof message.javaGenericServices !== \"boolean\") return \"javaGenericServices: boolean expected\";\n          if (message.pyGenericServices != null && message.hasOwnProperty(\"pyGenericServices\")) if (typeof message.pyGenericServices !== \"boolean\") return \"pyGenericServices: boolean expected\";\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) if (typeof message.deprecated !== \"boolean\") return \"deprecated: boolean expected\";\n          if (message.ccEnableArenas != null && message.hasOwnProperty(\"ccEnableArenas\")) if (typeof message.ccEnableArenas !== \"boolean\") return \"ccEnableArenas: boolean expected\";\n          if (message.objcClassPrefix != null && message.hasOwnProperty(\"objcClassPrefix\")) if (!$util.isString(message.objcClassPrefix)) return \"objcClassPrefix: string expected\";\n          if (message.csharpNamespace != null && message.hasOwnProperty(\"csharpNamespace\")) if (!$util.isString(message.csharpNamespace)) return \"csharpNamespace: string expected\";\n\n          if (message.uninterpretedOption != null && message.hasOwnProperty(\"uninterpretedOption\")) {\n            if (!Array.isArray(message.uninterpretedOption)) return \"uninterpretedOption: array expected\";\n\n            for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);\n              if (error) return \"uninterpretedOption.\" + error;\n            }\n          }\n\n          if (message[\".gogoproto.goprotoGettersAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoGettersAll\")) if (typeof message[\".gogoproto.goprotoGettersAll\"] !== \"boolean\") return \".gogoproto.goprotoGettersAll: boolean expected\";\n          if (message[\".gogoproto.goprotoEnumPrefixAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoEnumPrefixAll\")) if (typeof message[\".gogoproto.goprotoEnumPrefixAll\"] !== \"boolean\") return \".gogoproto.goprotoEnumPrefixAll: boolean expected\";\n          if (message[\".gogoproto.goprotoStringerAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoStringerAll\")) if (typeof message[\".gogoproto.goprotoStringerAll\"] !== \"boolean\") return \".gogoproto.goprotoStringerAll: boolean expected\";\n          if (message[\".gogoproto.verboseEqualAll\"] != null && message.hasOwnProperty(\".gogoproto.verboseEqualAll\")) if (typeof message[\".gogoproto.verboseEqualAll\"] !== \"boolean\") return \".gogoproto.verboseEqualAll: boolean expected\";\n          if (message[\".gogoproto.faceAll\"] != null && message.hasOwnProperty(\".gogoproto.faceAll\")) if (typeof message[\".gogoproto.faceAll\"] !== \"boolean\") return \".gogoproto.faceAll: boolean expected\";\n          if (message[\".gogoproto.gostringAll\"] != null && message.hasOwnProperty(\".gogoproto.gostringAll\")) if (typeof message[\".gogoproto.gostringAll\"] !== \"boolean\") return \".gogoproto.gostringAll: boolean expected\";\n          if (message[\".gogoproto.populateAll\"] != null && message.hasOwnProperty(\".gogoproto.populateAll\")) if (typeof message[\".gogoproto.populateAll\"] !== \"boolean\") return \".gogoproto.populateAll: boolean expected\";\n          if (message[\".gogoproto.stringerAll\"] != null && message.hasOwnProperty(\".gogoproto.stringerAll\")) if (typeof message[\".gogoproto.stringerAll\"] !== \"boolean\") return \".gogoproto.stringerAll: boolean expected\";\n          if (message[\".gogoproto.onlyoneAll\"] != null && message.hasOwnProperty(\".gogoproto.onlyoneAll\")) if (typeof message[\".gogoproto.onlyoneAll\"] !== \"boolean\") return \".gogoproto.onlyoneAll: boolean expected\";\n          if (message[\".gogoproto.equalAll\"] != null && message.hasOwnProperty(\".gogoproto.equalAll\")) if (typeof message[\".gogoproto.equalAll\"] !== \"boolean\") return \".gogoproto.equalAll: boolean expected\";\n          if (message[\".gogoproto.descriptionAll\"] != null && message.hasOwnProperty(\".gogoproto.descriptionAll\")) if (typeof message[\".gogoproto.descriptionAll\"] !== \"boolean\") return \".gogoproto.descriptionAll: boolean expected\";\n          if (message[\".gogoproto.testgenAll\"] != null && message.hasOwnProperty(\".gogoproto.testgenAll\")) if (typeof message[\".gogoproto.testgenAll\"] !== \"boolean\") return \".gogoproto.testgenAll: boolean expected\";\n          if (message[\".gogoproto.benchgenAll\"] != null && message.hasOwnProperty(\".gogoproto.benchgenAll\")) if (typeof message[\".gogoproto.benchgenAll\"] !== \"boolean\") return \".gogoproto.benchgenAll: boolean expected\";\n          if (message[\".gogoproto.marshalerAll\"] != null && message.hasOwnProperty(\".gogoproto.marshalerAll\")) if (typeof message[\".gogoproto.marshalerAll\"] !== \"boolean\") return \".gogoproto.marshalerAll: boolean expected\";\n          if (message[\".gogoproto.unmarshalerAll\"] != null && message.hasOwnProperty(\".gogoproto.unmarshalerAll\")) if (typeof message[\".gogoproto.unmarshalerAll\"] !== \"boolean\") return \".gogoproto.unmarshalerAll: boolean expected\";\n          if (message[\".gogoproto.stableMarshalerAll\"] != null && message.hasOwnProperty(\".gogoproto.stableMarshalerAll\")) if (typeof message[\".gogoproto.stableMarshalerAll\"] !== \"boolean\") return \".gogoproto.stableMarshalerAll: boolean expected\";\n          if (message[\".gogoproto.sizerAll\"] != null && message.hasOwnProperty(\".gogoproto.sizerAll\")) if (typeof message[\".gogoproto.sizerAll\"] !== \"boolean\") return \".gogoproto.sizerAll: boolean expected\";\n          if (message[\".gogoproto.goprotoEnumStringerAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoEnumStringerAll\")) if (typeof message[\".gogoproto.goprotoEnumStringerAll\"] !== \"boolean\") return \".gogoproto.goprotoEnumStringerAll: boolean expected\";\n          if (message[\".gogoproto.enumStringerAll\"] != null && message.hasOwnProperty(\".gogoproto.enumStringerAll\")) if (typeof message[\".gogoproto.enumStringerAll\"] !== \"boolean\") return \".gogoproto.enumStringerAll: boolean expected\";\n          if (message[\".gogoproto.unsafeMarshalerAll\"] != null && message.hasOwnProperty(\".gogoproto.unsafeMarshalerAll\")) if (typeof message[\".gogoproto.unsafeMarshalerAll\"] !== \"boolean\") return \".gogoproto.unsafeMarshalerAll: boolean expected\";\n          if (message[\".gogoproto.unsafeUnmarshalerAll\"] != null && message.hasOwnProperty(\".gogoproto.unsafeUnmarshalerAll\")) if (typeof message[\".gogoproto.unsafeUnmarshalerAll\"] !== \"boolean\") return \".gogoproto.unsafeUnmarshalerAll: boolean expected\";\n          if (message[\".gogoproto.goprotoExtensionsMapAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoExtensionsMapAll\")) if (typeof message[\".gogoproto.goprotoExtensionsMapAll\"] !== \"boolean\") return \".gogoproto.goprotoExtensionsMapAll: boolean expected\";\n          if (message[\".gogoproto.goprotoUnrecognizedAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoUnrecognizedAll\")) if (typeof message[\".gogoproto.goprotoUnrecognizedAll\"] !== \"boolean\") return \".gogoproto.goprotoUnrecognizedAll: boolean expected\";\n          if (message[\".gogoproto.gogoprotoImport\"] != null && message.hasOwnProperty(\".gogoproto.gogoprotoImport\")) if (typeof message[\".gogoproto.gogoprotoImport\"] !== \"boolean\") return \".gogoproto.gogoprotoImport: boolean expected\";\n          if (message[\".gogoproto.protosizerAll\"] != null && message.hasOwnProperty(\".gogoproto.protosizerAll\")) if (typeof message[\".gogoproto.protosizerAll\"] !== \"boolean\") return \".gogoproto.protosizerAll: boolean expected\";\n          if (message[\".gogoproto.compareAll\"] != null && message.hasOwnProperty(\".gogoproto.compareAll\")) if (typeof message[\".gogoproto.compareAll\"] !== \"boolean\") return \".gogoproto.compareAll: boolean expected\";\n          if (message[\".gogoproto.typedeclAll\"] != null && message.hasOwnProperty(\".gogoproto.typedeclAll\")) if (typeof message[\".gogoproto.typedeclAll\"] !== \"boolean\") return \".gogoproto.typedeclAll: boolean expected\";\n          if (message[\".gogoproto.enumdeclAll\"] != null && message.hasOwnProperty(\".gogoproto.enumdeclAll\")) if (typeof message[\".gogoproto.enumdeclAll\"] !== \"boolean\") return \".gogoproto.enumdeclAll: boolean expected\";\n          if (message[\".gogoproto.goprotoRegistration\"] != null && message.hasOwnProperty(\".gogoproto.goprotoRegistration\")) if (typeof message[\".gogoproto.goprotoRegistration\"] !== \"boolean\") return \".gogoproto.goprotoRegistration: boolean expected\";\n          if (message[\".gogoproto.messagenameAll\"] != null && message.hasOwnProperty(\".gogoproto.messagenameAll\")) if (typeof message[\".gogoproto.messagenameAll\"] !== \"boolean\") return \".gogoproto.messagenameAll: boolean expected\";\n          if (message[\".gogoproto.goprotoSizecacheAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoSizecacheAll\")) if (typeof message[\".gogoproto.goprotoSizecacheAll\"] !== \"boolean\") return \".gogoproto.goprotoSizecacheAll: boolean expected\";\n          if (message[\".gogoproto.goprotoUnkeyedAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoUnkeyedAll\")) if (typeof message[\".gogoproto.goprotoUnkeyedAll\"] !== \"boolean\") return \".gogoproto.goprotoUnkeyedAll: boolean expected\";\n          return null;\n        };\n        /**\n         * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.FileOptions\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.FileOptions} FileOptions\n         */\n\n\n        FileOptions.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.FileOptions) return object;\n          var message = new $root.google.protobuf.FileOptions();\n          if (object.javaPackage != null) message.javaPackage = String(object.javaPackage);\n          if (object.javaOuterClassname != null) message.javaOuterClassname = String(object.javaOuterClassname);\n          if (object.javaMultipleFiles != null) message.javaMultipleFiles = Boolean(object.javaMultipleFiles);\n          if (object.javaGenerateEqualsAndHash != null) message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);\n          if (object.javaStringCheckUtf8 != null) message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);\n\n          switch (object.optimizeFor) {\n            case \"SPEED\":\n            case 1:\n              message.optimizeFor = 1;\n              break;\n\n            case \"CODE_SIZE\":\n            case 2:\n              message.optimizeFor = 2;\n              break;\n\n            case \"LITE_RUNTIME\":\n            case 3:\n              message.optimizeFor = 3;\n              break;\n          }\n\n          if (object.goPackage != null) message.goPackage = String(object.goPackage);\n          if (object.ccGenericServices != null) message.ccGenericServices = Boolean(object.ccGenericServices);\n          if (object.javaGenericServices != null) message.javaGenericServices = Boolean(object.javaGenericServices);\n          if (object.pyGenericServices != null) message.pyGenericServices = Boolean(object.pyGenericServices);\n          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);\n          if (object.ccEnableArenas != null) message.ccEnableArenas = Boolean(object.ccEnableArenas);\n          if (object.objcClassPrefix != null) message.objcClassPrefix = String(object.objcClassPrefix);\n          if (object.csharpNamespace != null) message.csharpNamespace = String(object.csharpNamespace);\n\n          if (object.uninterpretedOption) {\n            if (!Array.isArray(object.uninterpretedOption)) throw TypeError(\".google.protobuf.FileOptions.uninterpretedOption: array expected\");\n            message.uninterpretedOption = [];\n\n            for (var i = 0; i < object.uninterpretedOption.length; ++i) {\n              if (typeof object.uninterpretedOption[i] !== \"object\") throw TypeError(\".google.protobuf.FileOptions.uninterpretedOption: object expected\");\n              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);\n            }\n          }\n\n          if (object[\".gogoproto.goprotoGettersAll\"] != null) message[\".gogoproto.goprotoGettersAll\"] = Boolean(object[\".gogoproto.goprotoGettersAll\"]);\n          if (object[\".gogoproto.goprotoEnumPrefixAll\"] != null) message[\".gogoproto.goprotoEnumPrefixAll\"] = Boolean(object[\".gogoproto.goprotoEnumPrefixAll\"]);\n          if (object[\".gogoproto.goprotoStringerAll\"] != null) message[\".gogoproto.goprotoStringerAll\"] = Boolean(object[\".gogoproto.goprotoStringerAll\"]);\n          if (object[\".gogoproto.verboseEqualAll\"] != null) message[\".gogoproto.verboseEqualAll\"] = Boolean(object[\".gogoproto.verboseEqualAll\"]);\n          if (object[\".gogoproto.faceAll\"] != null) message[\".gogoproto.faceAll\"] = Boolean(object[\".gogoproto.faceAll\"]);\n          if (object[\".gogoproto.gostringAll\"] != null) message[\".gogoproto.gostringAll\"] = Boolean(object[\".gogoproto.gostringAll\"]);\n          if (object[\".gogoproto.populateAll\"] != null) message[\".gogoproto.populateAll\"] = Boolean(object[\".gogoproto.populateAll\"]);\n          if (object[\".gogoproto.stringerAll\"] != null) message[\".gogoproto.stringerAll\"] = Boolean(object[\".gogoproto.stringerAll\"]);\n          if (object[\".gogoproto.onlyoneAll\"] != null) message[\".gogoproto.onlyoneAll\"] = Boolean(object[\".gogoproto.onlyoneAll\"]);\n          if (object[\".gogoproto.equalAll\"] != null) message[\".gogoproto.equalAll\"] = Boolean(object[\".gogoproto.equalAll\"]);\n          if (object[\".gogoproto.descriptionAll\"] != null) message[\".gogoproto.descriptionAll\"] = Boolean(object[\".gogoproto.descriptionAll\"]);\n          if (object[\".gogoproto.testgenAll\"] != null) message[\".gogoproto.testgenAll\"] = Boolean(object[\".gogoproto.testgenAll\"]);\n          if (object[\".gogoproto.benchgenAll\"] != null) message[\".gogoproto.benchgenAll\"] = Boolean(object[\".gogoproto.benchgenAll\"]);\n          if (object[\".gogoproto.marshalerAll\"] != null) message[\".gogoproto.marshalerAll\"] = Boolean(object[\".gogoproto.marshalerAll\"]);\n          if (object[\".gogoproto.unmarshalerAll\"] != null) message[\".gogoproto.unmarshalerAll\"] = Boolean(object[\".gogoproto.unmarshalerAll\"]);\n          if (object[\".gogoproto.stableMarshalerAll\"] != null) message[\".gogoproto.stableMarshalerAll\"] = Boolean(object[\".gogoproto.stableMarshalerAll\"]);\n          if (object[\".gogoproto.sizerAll\"] != null) message[\".gogoproto.sizerAll\"] = Boolean(object[\".gogoproto.sizerAll\"]);\n          if (object[\".gogoproto.goprotoEnumStringerAll\"] != null) message[\".gogoproto.goprotoEnumStringerAll\"] = Boolean(object[\".gogoproto.goprotoEnumStringerAll\"]);\n          if (object[\".gogoproto.enumStringerAll\"] != null) message[\".gogoproto.enumStringerAll\"] = Boolean(object[\".gogoproto.enumStringerAll\"]);\n          if (object[\".gogoproto.unsafeMarshalerAll\"] != null) message[\".gogoproto.unsafeMarshalerAll\"] = Boolean(object[\".gogoproto.unsafeMarshalerAll\"]);\n          if (object[\".gogoproto.unsafeUnmarshalerAll\"] != null) message[\".gogoproto.unsafeUnmarshalerAll\"] = Boolean(object[\".gogoproto.unsafeUnmarshalerAll\"]);\n          if (object[\".gogoproto.goprotoExtensionsMapAll\"] != null) message[\".gogoproto.goprotoExtensionsMapAll\"] = Boolean(object[\".gogoproto.goprotoExtensionsMapAll\"]);\n          if (object[\".gogoproto.goprotoUnrecognizedAll\"] != null) message[\".gogoproto.goprotoUnrecognizedAll\"] = Boolean(object[\".gogoproto.goprotoUnrecognizedAll\"]);\n          if (object[\".gogoproto.gogoprotoImport\"] != null) message[\".gogoproto.gogoprotoImport\"] = Boolean(object[\".gogoproto.gogoprotoImport\"]);\n          if (object[\".gogoproto.protosizerAll\"] != null) message[\".gogoproto.protosizerAll\"] = Boolean(object[\".gogoproto.protosizerAll\"]);\n          if (object[\".gogoproto.compareAll\"] != null) message[\".gogoproto.compareAll\"] = Boolean(object[\".gogoproto.compareAll\"]);\n          if (object[\".gogoproto.typedeclAll\"] != null) message[\".gogoproto.typedeclAll\"] = Boolean(object[\".gogoproto.typedeclAll\"]);\n          if (object[\".gogoproto.enumdeclAll\"] != null) message[\".gogoproto.enumdeclAll\"] = Boolean(object[\".gogoproto.enumdeclAll\"]);\n          if (object[\".gogoproto.goprotoRegistration\"] != null) message[\".gogoproto.goprotoRegistration\"] = Boolean(object[\".gogoproto.goprotoRegistration\"]);\n          if (object[\".gogoproto.messagenameAll\"] != null) message[\".gogoproto.messagenameAll\"] = Boolean(object[\".gogoproto.messagenameAll\"]);\n          if (object[\".gogoproto.goprotoSizecacheAll\"] != null) message[\".gogoproto.goprotoSizecacheAll\"] = Boolean(object[\".gogoproto.goprotoSizecacheAll\"]);\n          if (object[\".gogoproto.goprotoUnkeyedAll\"] != null) message[\".gogoproto.goprotoUnkeyedAll\"] = Boolean(object[\".gogoproto.goprotoUnkeyedAll\"]);\n          return message;\n        };\n        /**\n         * Creates a plain object from a FileOptions message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.FileOptions\n         * @static\n         * @param {google.protobuf.FileOptions} message FileOptions\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        FileOptions.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.uninterpretedOption = [];\n\n          if (options.defaults) {\n            object.javaPackage = \"\";\n            object.javaOuterClassname = \"\";\n            object.optimizeFor = options.enums === String ? \"SPEED\" : 1;\n            object.javaMultipleFiles = false;\n            object.goPackage = \"\";\n            object.ccGenericServices = false;\n            object.javaGenericServices = false;\n            object.pyGenericServices = false;\n            object.javaGenerateEqualsAndHash = false;\n            object.deprecated = false;\n            object.javaStringCheckUtf8 = false;\n            object.ccEnableArenas = false;\n            object.objcClassPrefix = \"\";\n            object.csharpNamespace = \"\";\n            object[\".gogoproto.goprotoGettersAll\"] = false;\n            object[\".gogoproto.goprotoEnumPrefixAll\"] = false;\n            object[\".gogoproto.goprotoStringerAll\"] = false;\n            object[\".gogoproto.verboseEqualAll\"] = false;\n            object[\".gogoproto.faceAll\"] = false;\n            object[\".gogoproto.gostringAll\"] = false;\n            object[\".gogoproto.populateAll\"] = false;\n            object[\".gogoproto.stringerAll\"] = false;\n            object[\".gogoproto.onlyoneAll\"] = false;\n            object[\".gogoproto.equalAll\"] = false;\n            object[\".gogoproto.descriptionAll\"] = false;\n            object[\".gogoproto.testgenAll\"] = false;\n            object[\".gogoproto.benchgenAll\"] = false;\n            object[\".gogoproto.marshalerAll\"] = false;\n            object[\".gogoproto.unmarshalerAll\"] = false;\n            object[\".gogoproto.stableMarshalerAll\"] = false;\n            object[\".gogoproto.sizerAll\"] = false;\n            object[\".gogoproto.goprotoEnumStringerAll\"] = false;\n            object[\".gogoproto.enumStringerAll\"] = false;\n            object[\".gogoproto.unsafeMarshalerAll\"] = false;\n            object[\".gogoproto.unsafeUnmarshalerAll\"] = false;\n            object[\".gogoproto.goprotoExtensionsMapAll\"] = false;\n            object[\".gogoproto.goprotoUnrecognizedAll\"] = false;\n            object[\".gogoproto.gogoprotoImport\"] = false;\n            object[\".gogoproto.protosizerAll\"] = false;\n            object[\".gogoproto.compareAll\"] = false;\n            object[\".gogoproto.typedeclAll\"] = false;\n            object[\".gogoproto.enumdeclAll\"] = false;\n            object[\".gogoproto.goprotoRegistration\"] = false;\n            object[\".gogoproto.messagenameAll\"] = false;\n            object[\".gogoproto.goprotoSizecacheAll\"] = false;\n            object[\".gogoproto.goprotoUnkeyedAll\"] = false;\n          }\n\n          if (message.javaPackage != null && message.hasOwnProperty(\"javaPackage\")) object.javaPackage = message.javaPackage;\n          if (message.javaOuterClassname != null && message.hasOwnProperty(\"javaOuterClassname\")) object.javaOuterClassname = message.javaOuterClassname;\n          if (message.optimizeFor != null && message.hasOwnProperty(\"optimizeFor\")) object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;\n          if (message.javaMultipleFiles != null && message.hasOwnProperty(\"javaMultipleFiles\")) object.javaMultipleFiles = message.javaMultipleFiles;\n          if (message.goPackage != null && message.hasOwnProperty(\"goPackage\")) object.goPackage = message.goPackage;\n          if (message.ccGenericServices != null && message.hasOwnProperty(\"ccGenericServices\")) object.ccGenericServices = message.ccGenericServices;\n          if (message.javaGenericServices != null && message.hasOwnProperty(\"javaGenericServices\")) object.javaGenericServices = message.javaGenericServices;\n          if (message.pyGenericServices != null && message.hasOwnProperty(\"pyGenericServices\")) object.pyGenericServices = message.pyGenericServices;\n          if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty(\"javaGenerateEqualsAndHash\")) object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) object.deprecated = message.deprecated;\n          if (message.javaStringCheckUtf8 != null && message.hasOwnProperty(\"javaStringCheckUtf8\")) object.javaStringCheckUtf8 = message.javaStringCheckUtf8;\n          if (message.ccEnableArenas != null && message.hasOwnProperty(\"ccEnableArenas\")) object.ccEnableArenas = message.ccEnableArenas;\n          if (message.objcClassPrefix != null && message.hasOwnProperty(\"objcClassPrefix\")) object.objcClassPrefix = message.objcClassPrefix;\n          if (message.csharpNamespace != null && message.hasOwnProperty(\"csharpNamespace\")) object.csharpNamespace = message.csharpNamespace;\n\n          if (message.uninterpretedOption && message.uninterpretedOption.length) {\n            object.uninterpretedOption = [];\n\n            for (var j = 0; j < message.uninterpretedOption.length; ++j) {\n              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);\n            }\n          }\n\n          if (message[\".gogoproto.goprotoGettersAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoGettersAll\")) object[\".gogoproto.goprotoGettersAll\"] = message[\".gogoproto.goprotoGettersAll\"];\n          if (message[\".gogoproto.goprotoEnumPrefixAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoEnumPrefixAll\")) object[\".gogoproto.goprotoEnumPrefixAll\"] = message[\".gogoproto.goprotoEnumPrefixAll\"];\n          if (message[\".gogoproto.goprotoStringerAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoStringerAll\")) object[\".gogoproto.goprotoStringerAll\"] = message[\".gogoproto.goprotoStringerAll\"];\n          if (message[\".gogoproto.verboseEqualAll\"] != null && message.hasOwnProperty(\".gogoproto.verboseEqualAll\")) object[\".gogoproto.verboseEqualAll\"] = message[\".gogoproto.verboseEqualAll\"];\n          if (message[\".gogoproto.faceAll\"] != null && message.hasOwnProperty(\".gogoproto.faceAll\")) object[\".gogoproto.faceAll\"] = message[\".gogoproto.faceAll\"];\n          if (message[\".gogoproto.gostringAll\"] != null && message.hasOwnProperty(\".gogoproto.gostringAll\")) object[\".gogoproto.gostringAll\"] = message[\".gogoproto.gostringAll\"];\n          if (message[\".gogoproto.populateAll\"] != null && message.hasOwnProperty(\".gogoproto.populateAll\")) object[\".gogoproto.populateAll\"] = message[\".gogoproto.populateAll\"];\n          if (message[\".gogoproto.stringerAll\"] != null && message.hasOwnProperty(\".gogoproto.stringerAll\")) object[\".gogoproto.stringerAll\"] = message[\".gogoproto.stringerAll\"];\n          if (message[\".gogoproto.onlyoneAll\"] != null && message.hasOwnProperty(\".gogoproto.onlyoneAll\")) object[\".gogoproto.onlyoneAll\"] = message[\".gogoproto.onlyoneAll\"];\n          if (message[\".gogoproto.equalAll\"] != null && message.hasOwnProperty(\".gogoproto.equalAll\")) object[\".gogoproto.equalAll\"] = message[\".gogoproto.equalAll\"];\n          if (message[\".gogoproto.descriptionAll\"] != null && message.hasOwnProperty(\".gogoproto.descriptionAll\")) object[\".gogoproto.descriptionAll\"] = message[\".gogoproto.descriptionAll\"];\n          if (message[\".gogoproto.testgenAll\"] != null && message.hasOwnProperty(\".gogoproto.testgenAll\")) object[\".gogoproto.testgenAll\"] = message[\".gogoproto.testgenAll\"];\n          if (message[\".gogoproto.benchgenAll\"] != null && message.hasOwnProperty(\".gogoproto.benchgenAll\")) object[\".gogoproto.benchgenAll\"] = message[\".gogoproto.benchgenAll\"];\n          if (message[\".gogoproto.marshalerAll\"] != null && message.hasOwnProperty(\".gogoproto.marshalerAll\")) object[\".gogoproto.marshalerAll\"] = message[\".gogoproto.marshalerAll\"];\n          if (message[\".gogoproto.unmarshalerAll\"] != null && message.hasOwnProperty(\".gogoproto.unmarshalerAll\")) object[\".gogoproto.unmarshalerAll\"] = message[\".gogoproto.unmarshalerAll\"];\n          if (message[\".gogoproto.stableMarshalerAll\"] != null && message.hasOwnProperty(\".gogoproto.stableMarshalerAll\")) object[\".gogoproto.stableMarshalerAll\"] = message[\".gogoproto.stableMarshalerAll\"];\n          if (message[\".gogoproto.sizerAll\"] != null && message.hasOwnProperty(\".gogoproto.sizerAll\")) object[\".gogoproto.sizerAll\"] = message[\".gogoproto.sizerAll\"];\n          if (message[\".gogoproto.goprotoEnumStringerAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoEnumStringerAll\")) object[\".gogoproto.goprotoEnumStringerAll\"] = message[\".gogoproto.goprotoEnumStringerAll\"];\n          if (message[\".gogoproto.enumStringerAll\"] != null && message.hasOwnProperty(\".gogoproto.enumStringerAll\")) object[\".gogoproto.enumStringerAll\"] = message[\".gogoproto.enumStringerAll\"];\n          if (message[\".gogoproto.unsafeMarshalerAll\"] != null && message.hasOwnProperty(\".gogoproto.unsafeMarshalerAll\")) object[\".gogoproto.unsafeMarshalerAll\"] = message[\".gogoproto.unsafeMarshalerAll\"];\n          if (message[\".gogoproto.unsafeUnmarshalerAll\"] != null && message.hasOwnProperty(\".gogoproto.unsafeUnmarshalerAll\")) object[\".gogoproto.unsafeUnmarshalerAll\"] = message[\".gogoproto.unsafeUnmarshalerAll\"];\n          if (message[\".gogoproto.goprotoExtensionsMapAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoExtensionsMapAll\")) object[\".gogoproto.goprotoExtensionsMapAll\"] = message[\".gogoproto.goprotoExtensionsMapAll\"];\n          if (message[\".gogoproto.goprotoUnrecognizedAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoUnrecognizedAll\")) object[\".gogoproto.goprotoUnrecognizedAll\"] = message[\".gogoproto.goprotoUnrecognizedAll\"];\n          if (message[\".gogoproto.gogoprotoImport\"] != null && message.hasOwnProperty(\".gogoproto.gogoprotoImport\")) object[\".gogoproto.gogoprotoImport\"] = message[\".gogoproto.gogoprotoImport\"];\n          if (message[\".gogoproto.protosizerAll\"] != null && message.hasOwnProperty(\".gogoproto.protosizerAll\")) object[\".gogoproto.protosizerAll\"] = message[\".gogoproto.protosizerAll\"];\n          if (message[\".gogoproto.compareAll\"] != null && message.hasOwnProperty(\".gogoproto.compareAll\")) object[\".gogoproto.compareAll\"] = message[\".gogoproto.compareAll\"];\n          if (message[\".gogoproto.typedeclAll\"] != null && message.hasOwnProperty(\".gogoproto.typedeclAll\")) object[\".gogoproto.typedeclAll\"] = message[\".gogoproto.typedeclAll\"];\n          if (message[\".gogoproto.enumdeclAll\"] != null && message.hasOwnProperty(\".gogoproto.enumdeclAll\")) object[\".gogoproto.enumdeclAll\"] = message[\".gogoproto.enumdeclAll\"];\n          if (message[\".gogoproto.goprotoRegistration\"] != null && message.hasOwnProperty(\".gogoproto.goprotoRegistration\")) object[\".gogoproto.goprotoRegistration\"] = message[\".gogoproto.goprotoRegistration\"];\n          if (message[\".gogoproto.messagenameAll\"] != null && message.hasOwnProperty(\".gogoproto.messagenameAll\")) object[\".gogoproto.messagenameAll\"] = message[\".gogoproto.messagenameAll\"];\n          if (message[\".gogoproto.goprotoSizecacheAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoSizecacheAll\")) object[\".gogoproto.goprotoSizecacheAll\"] = message[\".gogoproto.goprotoSizecacheAll\"];\n          if (message[\".gogoproto.goprotoUnkeyedAll\"] != null && message.hasOwnProperty(\".gogoproto.goprotoUnkeyedAll\")) object[\".gogoproto.goprotoUnkeyedAll\"] = message[\".gogoproto.goprotoUnkeyedAll\"];\n          return object;\n        };\n        /**\n         * Converts this FileOptions to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.FileOptions\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        FileOptions.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        /**\n         * OptimizeMode enum.\n         * @name google.protobuf.FileOptions.OptimizeMode\n         * @enum {number}\n         * @property {number} SPEED=1 SPEED value\n         * @property {number} CODE_SIZE=2 CODE_SIZE value\n         * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value\n         */\n\n\n        FileOptions.OptimizeMode = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[1] = \"SPEED\"] = 1;\n          values[valuesById[2] = \"CODE_SIZE\"] = 2;\n          values[valuesById[3] = \"LITE_RUNTIME\"] = 3;\n          return values;\n        }();\n\n        return FileOptions;\n      }();\n\n      protobuf.MessageOptions = function () {\n        /**\n         * Properties of a MessageOptions.\n         * @memberof google.protobuf\n         * @interface IMessageOptions\n         * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat\n         * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor\n         * @property {boolean|null} [deprecated] MessageOptions deprecated\n         * @property {boolean|null} [mapEntry] MessageOptions mapEntry\n         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption\n         * @property {boolean|null} [\".gogoproto.goprotoGetters\"] MessageOptions .gogoproto.goprotoGetters\n         * @property {boolean|null} [\".gogoproto.goprotoStringer\"] MessageOptions .gogoproto.goprotoStringer\n         * @property {boolean|null} [\".gogoproto.verboseEqual\"] MessageOptions .gogoproto.verboseEqual\n         * @property {boolean|null} [\".gogoproto.face\"] MessageOptions .gogoproto.face\n         * @property {boolean|null} [\".gogoproto.gostring\"] MessageOptions .gogoproto.gostring\n         * @property {boolean|null} [\".gogoproto.populate\"] MessageOptions .gogoproto.populate\n         * @property {boolean|null} [\".gogoproto.stringer\"] MessageOptions .gogoproto.stringer\n         * @property {boolean|null} [\".gogoproto.onlyone\"] MessageOptions .gogoproto.onlyone\n         * @property {boolean|null} [\".gogoproto.equal\"] MessageOptions .gogoproto.equal\n         * @property {boolean|null} [\".gogoproto.description\"] MessageOptions .gogoproto.description\n         * @property {boolean|null} [\".gogoproto.testgen\"] MessageOptions .gogoproto.testgen\n         * @property {boolean|null} [\".gogoproto.benchgen\"] MessageOptions .gogoproto.benchgen\n         * @property {boolean|null} [\".gogoproto.marshaler\"] MessageOptions .gogoproto.marshaler\n         * @property {boolean|null} [\".gogoproto.unmarshaler\"] MessageOptions .gogoproto.unmarshaler\n         * @property {boolean|null} [\".gogoproto.stableMarshaler\"] MessageOptions .gogoproto.stableMarshaler\n         * @property {boolean|null} [\".gogoproto.sizer\"] MessageOptions .gogoproto.sizer\n         * @property {boolean|null} [\".gogoproto.unsafeMarshaler\"] MessageOptions .gogoproto.unsafeMarshaler\n         * @property {boolean|null} [\".gogoproto.unsafeUnmarshaler\"] MessageOptions .gogoproto.unsafeUnmarshaler\n         * @property {boolean|null} [\".gogoproto.goprotoExtensionsMap\"] MessageOptions .gogoproto.goprotoExtensionsMap\n         * @property {boolean|null} [\".gogoproto.goprotoUnrecognized\"] MessageOptions .gogoproto.goprotoUnrecognized\n         * @property {boolean|null} [\".gogoproto.protosizer\"] MessageOptions .gogoproto.protosizer\n         * @property {boolean|null} [\".gogoproto.compare\"] MessageOptions .gogoproto.compare\n         * @property {boolean|null} [\".gogoproto.typedecl\"] MessageOptions .gogoproto.typedecl\n         * @property {boolean|null} [\".gogoproto.messagename\"] MessageOptions .gogoproto.messagename\n         * @property {boolean|null} [\".gogoproto.goprotoSizecache\"] MessageOptions .gogoproto.goprotoSizecache\n         * @property {boolean|null} [\".gogoproto.goprotoUnkeyed\"] MessageOptions .gogoproto.goprotoUnkeyed\n         */\n\n        /**\n         * Constructs a new MessageOptions.\n         * @memberof google.protobuf\n         * @classdesc Represents a MessageOptions.\n         * @implements IMessageOptions\n         * @constructor\n         * @param {google.protobuf.IMessageOptions=} [properties] Properties to set\n         */\n        function MessageOptions(properties) {\n          this.uninterpretedOption = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * MessageOptions messageSetWireFormat.\n         * @member {boolean} messageSetWireFormat\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n\n        MessageOptions.prototype.messageSetWireFormat = false;\n        /**\n         * MessageOptions noStandardDescriptorAccessor.\n         * @member {boolean} noStandardDescriptorAccessor\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype.noStandardDescriptorAccessor = false;\n        /**\n         * MessageOptions deprecated.\n         * @member {boolean} deprecated\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype.deprecated = false;\n        /**\n         * MessageOptions mapEntry.\n         * @member {boolean} mapEntry\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype.mapEntry = false;\n        /**\n         * MessageOptions uninterpretedOption.\n         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype.uninterpretedOption = $util.emptyArray;\n        /**\n         * MessageOptions .gogoproto.goprotoGetters.\n         * @member {boolean} .gogoproto.goprotoGetters\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.goprotoGetters\"] = false;\n        /**\n         * MessageOptions .gogoproto.goprotoStringer.\n         * @member {boolean} .gogoproto.goprotoStringer\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.goprotoStringer\"] = false;\n        /**\n         * MessageOptions .gogoproto.verboseEqual.\n         * @member {boolean} .gogoproto.verboseEqual\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.verboseEqual\"] = false;\n        /**\n         * MessageOptions .gogoproto.face.\n         * @member {boolean} .gogoproto.face\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.face\"] = false;\n        /**\n         * MessageOptions .gogoproto.gostring.\n         * @member {boolean} .gogoproto.gostring\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.gostring\"] = false;\n        /**\n         * MessageOptions .gogoproto.populate.\n         * @member {boolean} .gogoproto.populate\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.populate\"] = false;\n        /**\n         * MessageOptions .gogoproto.stringer.\n         * @member {boolean} .gogoproto.stringer\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.stringer\"] = false;\n        /**\n         * MessageOptions .gogoproto.onlyone.\n         * @member {boolean} .gogoproto.onlyone\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.onlyone\"] = false;\n        /**\n         * MessageOptions .gogoproto.equal.\n         * @member {boolean} .gogoproto.equal\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.equal\"] = false;\n        /**\n         * MessageOptions .gogoproto.description.\n         * @member {boolean} .gogoproto.description\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.description\"] = false;\n        /**\n         * MessageOptions .gogoproto.testgen.\n         * @member {boolean} .gogoproto.testgen\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.testgen\"] = false;\n        /**\n         * MessageOptions .gogoproto.benchgen.\n         * @member {boolean} .gogoproto.benchgen\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.benchgen\"] = false;\n        /**\n         * MessageOptions .gogoproto.marshaler.\n         * @member {boolean} .gogoproto.marshaler\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.marshaler\"] = false;\n        /**\n         * MessageOptions .gogoproto.unmarshaler.\n         * @member {boolean} .gogoproto.unmarshaler\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.unmarshaler\"] = false;\n        /**\n         * MessageOptions .gogoproto.stableMarshaler.\n         * @member {boolean} .gogoproto.stableMarshaler\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.stableMarshaler\"] = false;\n        /**\n         * MessageOptions .gogoproto.sizer.\n         * @member {boolean} .gogoproto.sizer\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.sizer\"] = false;\n        /**\n         * MessageOptions .gogoproto.unsafeMarshaler.\n         * @member {boolean} .gogoproto.unsafeMarshaler\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.unsafeMarshaler\"] = false;\n        /**\n         * MessageOptions .gogoproto.unsafeUnmarshaler.\n         * @member {boolean} .gogoproto.unsafeUnmarshaler\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.unsafeUnmarshaler\"] = false;\n        /**\n         * MessageOptions .gogoproto.goprotoExtensionsMap.\n         * @member {boolean} .gogoproto.goprotoExtensionsMap\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.goprotoExtensionsMap\"] = false;\n        /**\n         * MessageOptions .gogoproto.goprotoUnrecognized.\n         * @member {boolean} .gogoproto.goprotoUnrecognized\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.goprotoUnrecognized\"] = false;\n        /**\n         * MessageOptions .gogoproto.protosizer.\n         * @member {boolean} .gogoproto.protosizer\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.protosizer\"] = false;\n        /**\n         * MessageOptions .gogoproto.compare.\n         * @member {boolean} .gogoproto.compare\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.compare\"] = false;\n        /**\n         * MessageOptions .gogoproto.typedecl.\n         * @member {boolean} .gogoproto.typedecl\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.typedecl\"] = false;\n        /**\n         * MessageOptions .gogoproto.messagename.\n         * @member {boolean} .gogoproto.messagename\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.messagename\"] = false;\n        /**\n         * MessageOptions .gogoproto.goprotoSizecache.\n         * @member {boolean} .gogoproto.goprotoSizecache\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.goprotoSizecache\"] = false;\n        /**\n         * MessageOptions .gogoproto.goprotoUnkeyed.\n         * @member {boolean} .gogoproto.goprotoUnkeyed\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         */\n\n        MessageOptions.prototype[\".gogoproto.goprotoUnkeyed\"] = false;\n        /**\n         * Creates a new MessageOptions instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.MessageOptions\n         * @static\n         * @param {google.protobuf.IMessageOptions=} [properties] Properties to set\n         * @returns {google.protobuf.MessageOptions} MessageOptions instance\n         */\n\n        MessageOptions.create = function create(properties) {\n          return new MessageOptions(properties);\n        };\n        /**\n         * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.MessageOptions\n         * @static\n         * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        MessageOptions.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, \"messageSetWireFormat\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).bool(message.messageSetWireFormat);\n          if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, \"noStandardDescriptorAccessor\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).bool(message.noStandardDescriptorAccessor);\n          if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).bool(message.deprecated);\n          if (message.mapEntry != null && Object.hasOwnProperty.call(message, \"mapEntry\")) writer.uint32(\n          /* id 7, wireType 0 =*/\n          56).bool(message.mapEntry);\n          if (message.uninterpretedOption != null && message.uninterpretedOption.length) for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(\n            /* id 999, wireType 2 =*/\n            7994).fork()).ldelim();\n          }\n          if (message[\".gogoproto.goprotoGetters\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoGetters\")) writer.uint32(\n          /* id 64001, wireType 0 =*/\n          512008).bool(message[\".gogoproto.goprotoGetters\"]);\n          if (message[\".gogoproto.goprotoStringer\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoStringer\")) writer.uint32(\n          /* id 64003, wireType 0 =*/\n          512024).bool(message[\".gogoproto.goprotoStringer\"]);\n          if (message[\".gogoproto.verboseEqual\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.verboseEqual\")) writer.uint32(\n          /* id 64004, wireType 0 =*/\n          512032).bool(message[\".gogoproto.verboseEqual\"]);\n          if (message[\".gogoproto.face\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.face\")) writer.uint32(\n          /* id 64005, wireType 0 =*/\n          512040).bool(message[\".gogoproto.face\"]);\n          if (message[\".gogoproto.gostring\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.gostring\")) writer.uint32(\n          /* id 64006, wireType 0 =*/\n          512048).bool(message[\".gogoproto.gostring\"]);\n          if (message[\".gogoproto.populate\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.populate\")) writer.uint32(\n          /* id 64007, wireType 0 =*/\n          512056).bool(message[\".gogoproto.populate\"]);\n          if (message[\".gogoproto.onlyone\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.onlyone\")) writer.uint32(\n          /* id 64009, wireType 0 =*/\n          512072).bool(message[\".gogoproto.onlyone\"]);\n          if (message[\".gogoproto.equal\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.equal\")) writer.uint32(\n          /* id 64013, wireType 0 =*/\n          512104).bool(message[\".gogoproto.equal\"]);\n          if (message[\".gogoproto.description\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.description\")) writer.uint32(\n          /* id 64014, wireType 0 =*/\n          512112).bool(message[\".gogoproto.description\"]);\n          if (message[\".gogoproto.testgen\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.testgen\")) writer.uint32(\n          /* id 64015, wireType 0 =*/\n          512120).bool(message[\".gogoproto.testgen\"]);\n          if (message[\".gogoproto.benchgen\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.benchgen\")) writer.uint32(\n          /* id 64016, wireType 0 =*/\n          512128).bool(message[\".gogoproto.benchgen\"]);\n          if (message[\".gogoproto.marshaler\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.marshaler\")) writer.uint32(\n          /* id 64017, wireType 0 =*/\n          512136).bool(message[\".gogoproto.marshaler\"]);\n          if (message[\".gogoproto.unmarshaler\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.unmarshaler\")) writer.uint32(\n          /* id 64018, wireType 0 =*/\n          512144).bool(message[\".gogoproto.unmarshaler\"]);\n          if (message[\".gogoproto.stableMarshaler\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.stableMarshaler\")) writer.uint32(\n          /* id 64019, wireType 0 =*/\n          512152).bool(message[\".gogoproto.stableMarshaler\"]);\n          if (message[\".gogoproto.sizer\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.sizer\")) writer.uint32(\n          /* id 64020, wireType 0 =*/\n          512160).bool(message[\".gogoproto.sizer\"]);\n          if (message[\".gogoproto.unsafeMarshaler\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.unsafeMarshaler\")) writer.uint32(\n          /* id 64023, wireType 0 =*/\n          512184).bool(message[\".gogoproto.unsafeMarshaler\"]);\n          if (message[\".gogoproto.unsafeUnmarshaler\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.unsafeUnmarshaler\")) writer.uint32(\n          /* id 64024, wireType 0 =*/\n          512192).bool(message[\".gogoproto.unsafeUnmarshaler\"]);\n          if (message[\".gogoproto.goprotoExtensionsMap\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoExtensionsMap\")) writer.uint32(\n          /* id 64025, wireType 0 =*/\n          512200).bool(message[\".gogoproto.goprotoExtensionsMap\"]);\n          if (message[\".gogoproto.goprotoUnrecognized\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoUnrecognized\")) writer.uint32(\n          /* id 64026, wireType 0 =*/\n          512208).bool(message[\".gogoproto.goprotoUnrecognized\"]);\n          if (message[\".gogoproto.protosizer\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.protosizer\")) writer.uint32(\n          /* id 64028, wireType 0 =*/\n          512224).bool(message[\".gogoproto.protosizer\"]);\n          if (message[\".gogoproto.compare\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.compare\")) writer.uint32(\n          /* id 64029, wireType 0 =*/\n          512232).bool(message[\".gogoproto.compare\"]);\n          if (message[\".gogoproto.typedecl\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.typedecl\")) writer.uint32(\n          /* id 64030, wireType 0 =*/\n          512240).bool(message[\".gogoproto.typedecl\"]);\n          if (message[\".gogoproto.messagename\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.messagename\")) writer.uint32(\n          /* id 64033, wireType 0 =*/\n          512264).bool(message[\".gogoproto.messagename\"]);\n          if (message[\".gogoproto.goprotoSizecache\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoSizecache\")) writer.uint32(\n          /* id 64034, wireType 0 =*/\n          512272).bool(message[\".gogoproto.goprotoSizecache\"]);\n          if (message[\".gogoproto.goprotoUnkeyed\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoUnkeyed\")) writer.uint32(\n          /* id 64035, wireType 0 =*/\n          512280).bool(message[\".gogoproto.goprotoUnkeyed\"]);\n          if (message[\".gogoproto.stringer\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.stringer\")) writer.uint32(\n          /* id 67008, wireType 0 =*/\n          536064).bool(message[\".gogoproto.stringer\"]);\n          return writer;\n        };\n        /**\n         * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.MessageOptions\n         * @static\n         * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a MessageOptions message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.MessageOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.MessageOptions} MessageOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        MessageOptions.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.MessageOptions();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.messageSetWireFormat = reader.bool();\n                break;\n\n              case 2:\n                message.noStandardDescriptorAccessor = reader.bool();\n                break;\n\n              case 3:\n                message.deprecated = reader.bool();\n                break;\n\n              case 7:\n                message.mapEntry = reader.bool();\n                break;\n\n              case 999:\n                if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                break;\n\n              case 64001:\n                message[\".gogoproto.goprotoGetters\"] = reader.bool();\n                break;\n\n              case 64003:\n                message[\".gogoproto.goprotoStringer\"] = reader.bool();\n                break;\n\n              case 64004:\n                message[\".gogoproto.verboseEqual\"] = reader.bool();\n                break;\n\n              case 64005:\n                message[\".gogoproto.face\"] = reader.bool();\n                break;\n\n              case 64006:\n                message[\".gogoproto.gostring\"] = reader.bool();\n                break;\n\n              case 64007:\n                message[\".gogoproto.populate\"] = reader.bool();\n                break;\n\n              case 67008:\n                message[\".gogoproto.stringer\"] = reader.bool();\n                break;\n\n              case 64009:\n                message[\".gogoproto.onlyone\"] = reader.bool();\n                break;\n\n              case 64013:\n                message[\".gogoproto.equal\"] = reader.bool();\n                break;\n\n              case 64014:\n                message[\".gogoproto.description\"] = reader.bool();\n                break;\n\n              case 64015:\n                message[\".gogoproto.testgen\"] = reader.bool();\n                break;\n\n              case 64016:\n                message[\".gogoproto.benchgen\"] = reader.bool();\n                break;\n\n              case 64017:\n                message[\".gogoproto.marshaler\"] = reader.bool();\n                break;\n\n              case 64018:\n                message[\".gogoproto.unmarshaler\"] = reader.bool();\n                break;\n\n              case 64019:\n                message[\".gogoproto.stableMarshaler\"] = reader.bool();\n                break;\n\n              case 64020:\n                message[\".gogoproto.sizer\"] = reader.bool();\n                break;\n\n              case 64023:\n                message[\".gogoproto.unsafeMarshaler\"] = reader.bool();\n                break;\n\n              case 64024:\n                message[\".gogoproto.unsafeUnmarshaler\"] = reader.bool();\n                break;\n\n              case 64025:\n                message[\".gogoproto.goprotoExtensionsMap\"] = reader.bool();\n                break;\n\n              case 64026:\n                message[\".gogoproto.goprotoUnrecognized\"] = reader.bool();\n                break;\n\n              case 64028:\n                message[\".gogoproto.protosizer\"] = reader.bool();\n                break;\n\n              case 64029:\n                message[\".gogoproto.compare\"] = reader.bool();\n                break;\n\n              case 64030:\n                message[\".gogoproto.typedecl\"] = reader.bool();\n                break;\n\n              case 64033:\n                message[\".gogoproto.messagename\"] = reader.bool();\n                break;\n\n              case 64034:\n                message[\".gogoproto.goprotoSizecache\"] = reader.bool();\n                break;\n\n              case 64035:\n                message[\".gogoproto.goprotoUnkeyed\"] = reader.bool();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a MessageOptions message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.MessageOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.MessageOptions} MessageOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        MessageOptions.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a MessageOptions message.\n         * @function verify\n         * @memberof google.protobuf.MessageOptions\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        MessageOptions.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.messageSetWireFormat != null && message.hasOwnProperty(\"messageSetWireFormat\")) if (typeof message.messageSetWireFormat !== \"boolean\") return \"messageSetWireFormat: boolean expected\";\n          if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty(\"noStandardDescriptorAccessor\")) if (typeof message.noStandardDescriptorAccessor !== \"boolean\") return \"noStandardDescriptorAccessor: boolean expected\";\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) if (typeof message.deprecated !== \"boolean\") return \"deprecated: boolean expected\";\n          if (message.mapEntry != null && message.hasOwnProperty(\"mapEntry\")) if (typeof message.mapEntry !== \"boolean\") return \"mapEntry: boolean expected\";\n\n          if (message.uninterpretedOption != null && message.hasOwnProperty(\"uninterpretedOption\")) {\n            if (!Array.isArray(message.uninterpretedOption)) return \"uninterpretedOption: array expected\";\n\n            for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);\n              if (error) return \"uninterpretedOption.\" + error;\n            }\n          }\n\n          if (message[\".gogoproto.goprotoGetters\"] != null && message.hasOwnProperty(\".gogoproto.goprotoGetters\")) if (typeof message[\".gogoproto.goprotoGetters\"] !== \"boolean\") return \".gogoproto.goprotoGetters: boolean expected\";\n          if (message[\".gogoproto.goprotoStringer\"] != null && message.hasOwnProperty(\".gogoproto.goprotoStringer\")) if (typeof message[\".gogoproto.goprotoStringer\"] !== \"boolean\") return \".gogoproto.goprotoStringer: boolean expected\";\n          if (message[\".gogoproto.verboseEqual\"] != null && message.hasOwnProperty(\".gogoproto.verboseEqual\")) if (typeof message[\".gogoproto.verboseEqual\"] !== \"boolean\") return \".gogoproto.verboseEqual: boolean expected\";\n          if (message[\".gogoproto.face\"] != null && message.hasOwnProperty(\".gogoproto.face\")) if (typeof message[\".gogoproto.face\"] !== \"boolean\") return \".gogoproto.face: boolean expected\";\n          if (message[\".gogoproto.gostring\"] != null && message.hasOwnProperty(\".gogoproto.gostring\")) if (typeof message[\".gogoproto.gostring\"] !== \"boolean\") return \".gogoproto.gostring: boolean expected\";\n          if (message[\".gogoproto.populate\"] != null && message.hasOwnProperty(\".gogoproto.populate\")) if (typeof message[\".gogoproto.populate\"] !== \"boolean\") return \".gogoproto.populate: boolean expected\";\n          if (message[\".gogoproto.stringer\"] != null && message.hasOwnProperty(\".gogoproto.stringer\")) if (typeof message[\".gogoproto.stringer\"] !== \"boolean\") return \".gogoproto.stringer: boolean expected\";\n          if (message[\".gogoproto.onlyone\"] != null && message.hasOwnProperty(\".gogoproto.onlyone\")) if (typeof message[\".gogoproto.onlyone\"] !== \"boolean\") return \".gogoproto.onlyone: boolean expected\";\n          if (message[\".gogoproto.equal\"] != null && message.hasOwnProperty(\".gogoproto.equal\")) if (typeof message[\".gogoproto.equal\"] !== \"boolean\") return \".gogoproto.equal: boolean expected\";\n          if (message[\".gogoproto.description\"] != null && message.hasOwnProperty(\".gogoproto.description\")) if (typeof message[\".gogoproto.description\"] !== \"boolean\") return \".gogoproto.description: boolean expected\";\n          if (message[\".gogoproto.testgen\"] != null && message.hasOwnProperty(\".gogoproto.testgen\")) if (typeof message[\".gogoproto.testgen\"] !== \"boolean\") return \".gogoproto.testgen: boolean expected\";\n          if (message[\".gogoproto.benchgen\"] != null && message.hasOwnProperty(\".gogoproto.benchgen\")) if (typeof message[\".gogoproto.benchgen\"] !== \"boolean\") return \".gogoproto.benchgen: boolean expected\";\n          if (message[\".gogoproto.marshaler\"] != null && message.hasOwnProperty(\".gogoproto.marshaler\")) if (typeof message[\".gogoproto.marshaler\"] !== \"boolean\") return \".gogoproto.marshaler: boolean expected\";\n          if (message[\".gogoproto.unmarshaler\"] != null && message.hasOwnProperty(\".gogoproto.unmarshaler\")) if (typeof message[\".gogoproto.unmarshaler\"] !== \"boolean\") return \".gogoproto.unmarshaler: boolean expected\";\n          if (message[\".gogoproto.stableMarshaler\"] != null && message.hasOwnProperty(\".gogoproto.stableMarshaler\")) if (typeof message[\".gogoproto.stableMarshaler\"] !== \"boolean\") return \".gogoproto.stableMarshaler: boolean expected\";\n          if (message[\".gogoproto.sizer\"] != null && message.hasOwnProperty(\".gogoproto.sizer\")) if (typeof message[\".gogoproto.sizer\"] !== \"boolean\") return \".gogoproto.sizer: boolean expected\";\n          if (message[\".gogoproto.unsafeMarshaler\"] != null && message.hasOwnProperty(\".gogoproto.unsafeMarshaler\")) if (typeof message[\".gogoproto.unsafeMarshaler\"] !== \"boolean\") return \".gogoproto.unsafeMarshaler: boolean expected\";\n          if (message[\".gogoproto.unsafeUnmarshaler\"] != null && message.hasOwnProperty(\".gogoproto.unsafeUnmarshaler\")) if (typeof message[\".gogoproto.unsafeUnmarshaler\"] !== \"boolean\") return \".gogoproto.unsafeUnmarshaler: boolean expected\";\n          if (message[\".gogoproto.goprotoExtensionsMap\"] != null && message.hasOwnProperty(\".gogoproto.goprotoExtensionsMap\")) if (typeof message[\".gogoproto.goprotoExtensionsMap\"] !== \"boolean\") return \".gogoproto.goprotoExtensionsMap: boolean expected\";\n          if (message[\".gogoproto.goprotoUnrecognized\"] != null && message.hasOwnProperty(\".gogoproto.goprotoUnrecognized\")) if (typeof message[\".gogoproto.goprotoUnrecognized\"] !== \"boolean\") return \".gogoproto.goprotoUnrecognized: boolean expected\";\n          if (message[\".gogoproto.protosizer\"] != null && message.hasOwnProperty(\".gogoproto.protosizer\")) if (typeof message[\".gogoproto.protosizer\"] !== \"boolean\") return \".gogoproto.protosizer: boolean expected\";\n          if (message[\".gogoproto.compare\"] != null && message.hasOwnProperty(\".gogoproto.compare\")) if (typeof message[\".gogoproto.compare\"] !== \"boolean\") return \".gogoproto.compare: boolean expected\";\n          if (message[\".gogoproto.typedecl\"] != null && message.hasOwnProperty(\".gogoproto.typedecl\")) if (typeof message[\".gogoproto.typedecl\"] !== \"boolean\") return \".gogoproto.typedecl: boolean expected\";\n          if (message[\".gogoproto.messagename\"] != null && message.hasOwnProperty(\".gogoproto.messagename\")) if (typeof message[\".gogoproto.messagename\"] !== \"boolean\") return \".gogoproto.messagename: boolean expected\";\n          if (message[\".gogoproto.goprotoSizecache\"] != null && message.hasOwnProperty(\".gogoproto.goprotoSizecache\")) if (typeof message[\".gogoproto.goprotoSizecache\"] !== \"boolean\") return \".gogoproto.goprotoSizecache: boolean expected\";\n          if (message[\".gogoproto.goprotoUnkeyed\"] != null && message.hasOwnProperty(\".gogoproto.goprotoUnkeyed\")) if (typeof message[\".gogoproto.goprotoUnkeyed\"] !== \"boolean\") return \".gogoproto.goprotoUnkeyed: boolean expected\";\n          return null;\n        };\n        /**\n         * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.MessageOptions\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.MessageOptions} MessageOptions\n         */\n\n\n        MessageOptions.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.MessageOptions) return object;\n          var message = new $root.google.protobuf.MessageOptions();\n          if (object.messageSetWireFormat != null) message.messageSetWireFormat = Boolean(object.messageSetWireFormat);\n          if (object.noStandardDescriptorAccessor != null) message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);\n          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);\n          if (object.mapEntry != null) message.mapEntry = Boolean(object.mapEntry);\n\n          if (object.uninterpretedOption) {\n            if (!Array.isArray(object.uninterpretedOption)) throw TypeError(\".google.protobuf.MessageOptions.uninterpretedOption: array expected\");\n            message.uninterpretedOption = [];\n\n            for (var i = 0; i < object.uninterpretedOption.length; ++i) {\n              if (typeof object.uninterpretedOption[i] !== \"object\") throw TypeError(\".google.protobuf.MessageOptions.uninterpretedOption: object expected\");\n              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);\n            }\n          }\n\n          if (object[\".gogoproto.goprotoGetters\"] != null) message[\".gogoproto.goprotoGetters\"] = Boolean(object[\".gogoproto.goprotoGetters\"]);\n          if (object[\".gogoproto.goprotoStringer\"] != null) message[\".gogoproto.goprotoStringer\"] = Boolean(object[\".gogoproto.goprotoStringer\"]);\n          if (object[\".gogoproto.verboseEqual\"] != null) message[\".gogoproto.verboseEqual\"] = Boolean(object[\".gogoproto.verboseEqual\"]);\n          if (object[\".gogoproto.face\"] != null) message[\".gogoproto.face\"] = Boolean(object[\".gogoproto.face\"]);\n          if (object[\".gogoproto.gostring\"] != null) message[\".gogoproto.gostring\"] = Boolean(object[\".gogoproto.gostring\"]);\n          if (object[\".gogoproto.populate\"] != null) message[\".gogoproto.populate\"] = Boolean(object[\".gogoproto.populate\"]);\n          if (object[\".gogoproto.stringer\"] != null) message[\".gogoproto.stringer\"] = Boolean(object[\".gogoproto.stringer\"]);\n          if (object[\".gogoproto.onlyone\"] != null) message[\".gogoproto.onlyone\"] = Boolean(object[\".gogoproto.onlyone\"]);\n          if (object[\".gogoproto.equal\"] != null) message[\".gogoproto.equal\"] = Boolean(object[\".gogoproto.equal\"]);\n          if (object[\".gogoproto.description\"] != null) message[\".gogoproto.description\"] = Boolean(object[\".gogoproto.description\"]);\n          if (object[\".gogoproto.testgen\"] != null) message[\".gogoproto.testgen\"] = Boolean(object[\".gogoproto.testgen\"]);\n          if (object[\".gogoproto.benchgen\"] != null) message[\".gogoproto.benchgen\"] = Boolean(object[\".gogoproto.benchgen\"]);\n          if (object[\".gogoproto.marshaler\"] != null) message[\".gogoproto.marshaler\"] = Boolean(object[\".gogoproto.marshaler\"]);\n          if (object[\".gogoproto.unmarshaler\"] != null) message[\".gogoproto.unmarshaler\"] = Boolean(object[\".gogoproto.unmarshaler\"]);\n          if (object[\".gogoproto.stableMarshaler\"] != null) message[\".gogoproto.stableMarshaler\"] = Boolean(object[\".gogoproto.stableMarshaler\"]);\n          if (object[\".gogoproto.sizer\"] != null) message[\".gogoproto.sizer\"] = Boolean(object[\".gogoproto.sizer\"]);\n          if (object[\".gogoproto.unsafeMarshaler\"] != null) message[\".gogoproto.unsafeMarshaler\"] = Boolean(object[\".gogoproto.unsafeMarshaler\"]);\n          if (object[\".gogoproto.unsafeUnmarshaler\"] != null) message[\".gogoproto.unsafeUnmarshaler\"] = Boolean(object[\".gogoproto.unsafeUnmarshaler\"]);\n          if (object[\".gogoproto.goprotoExtensionsMap\"] != null) message[\".gogoproto.goprotoExtensionsMap\"] = Boolean(object[\".gogoproto.goprotoExtensionsMap\"]);\n          if (object[\".gogoproto.goprotoUnrecognized\"] != null) message[\".gogoproto.goprotoUnrecognized\"] = Boolean(object[\".gogoproto.goprotoUnrecognized\"]);\n          if (object[\".gogoproto.protosizer\"] != null) message[\".gogoproto.protosizer\"] = Boolean(object[\".gogoproto.protosizer\"]);\n          if (object[\".gogoproto.compare\"] != null) message[\".gogoproto.compare\"] = Boolean(object[\".gogoproto.compare\"]);\n          if (object[\".gogoproto.typedecl\"] != null) message[\".gogoproto.typedecl\"] = Boolean(object[\".gogoproto.typedecl\"]);\n          if (object[\".gogoproto.messagename\"] != null) message[\".gogoproto.messagename\"] = Boolean(object[\".gogoproto.messagename\"]);\n          if (object[\".gogoproto.goprotoSizecache\"] != null) message[\".gogoproto.goprotoSizecache\"] = Boolean(object[\".gogoproto.goprotoSizecache\"]);\n          if (object[\".gogoproto.goprotoUnkeyed\"] != null) message[\".gogoproto.goprotoUnkeyed\"] = Boolean(object[\".gogoproto.goprotoUnkeyed\"]);\n          return message;\n        };\n        /**\n         * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.MessageOptions\n         * @static\n         * @param {google.protobuf.MessageOptions} message MessageOptions\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        MessageOptions.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.uninterpretedOption = [];\n\n          if (options.defaults) {\n            object.messageSetWireFormat = false;\n            object.noStandardDescriptorAccessor = false;\n            object.deprecated = false;\n            object.mapEntry = false;\n            object[\".gogoproto.goprotoGetters\"] = false;\n            object[\".gogoproto.goprotoStringer\"] = false;\n            object[\".gogoproto.verboseEqual\"] = false;\n            object[\".gogoproto.face\"] = false;\n            object[\".gogoproto.gostring\"] = false;\n            object[\".gogoproto.populate\"] = false;\n            object[\".gogoproto.onlyone\"] = false;\n            object[\".gogoproto.equal\"] = false;\n            object[\".gogoproto.description\"] = false;\n            object[\".gogoproto.testgen\"] = false;\n            object[\".gogoproto.benchgen\"] = false;\n            object[\".gogoproto.marshaler\"] = false;\n            object[\".gogoproto.unmarshaler\"] = false;\n            object[\".gogoproto.stableMarshaler\"] = false;\n            object[\".gogoproto.sizer\"] = false;\n            object[\".gogoproto.unsafeMarshaler\"] = false;\n            object[\".gogoproto.unsafeUnmarshaler\"] = false;\n            object[\".gogoproto.goprotoExtensionsMap\"] = false;\n            object[\".gogoproto.goprotoUnrecognized\"] = false;\n            object[\".gogoproto.protosizer\"] = false;\n            object[\".gogoproto.compare\"] = false;\n            object[\".gogoproto.typedecl\"] = false;\n            object[\".gogoproto.messagename\"] = false;\n            object[\".gogoproto.goprotoSizecache\"] = false;\n            object[\".gogoproto.goprotoUnkeyed\"] = false;\n            object[\".gogoproto.stringer\"] = false;\n          }\n\n          if (message.messageSetWireFormat != null && message.hasOwnProperty(\"messageSetWireFormat\")) object.messageSetWireFormat = message.messageSetWireFormat;\n          if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty(\"noStandardDescriptorAccessor\")) object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) object.deprecated = message.deprecated;\n          if (message.mapEntry != null && message.hasOwnProperty(\"mapEntry\")) object.mapEntry = message.mapEntry;\n\n          if (message.uninterpretedOption && message.uninterpretedOption.length) {\n            object.uninterpretedOption = [];\n\n            for (var j = 0; j < message.uninterpretedOption.length; ++j) {\n              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);\n            }\n          }\n\n          if (message[\".gogoproto.goprotoGetters\"] != null && message.hasOwnProperty(\".gogoproto.goprotoGetters\")) object[\".gogoproto.goprotoGetters\"] = message[\".gogoproto.goprotoGetters\"];\n          if (message[\".gogoproto.goprotoStringer\"] != null && message.hasOwnProperty(\".gogoproto.goprotoStringer\")) object[\".gogoproto.goprotoStringer\"] = message[\".gogoproto.goprotoStringer\"];\n          if (message[\".gogoproto.verboseEqual\"] != null && message.hasOwnProperty(\".gogoproto.verboseEqual\")) object[\".gogoproto.verboseEqual\"] = message[\".gogoproto.verboseEqual\"];\n          if (message[\".gogoproto.face\"] != null && message.hasOwnProperty(\".gogoproto.face\")) object[\".gogoproto.face\"] = message[\".gogoproto.face\"];\n          if (message[\".gogoproto.gostring\"] != null && message.hasOwnProperty(\".gogoproto.gostring\")) object[\".gogoproto.gostring\"] = message[\".gogoproto.gostring\"];\n          if (message[\".gogoproto.populate\"] != null && message.hasOwnProperty(\".gogoproto.populate\")) object[\".gogoproto.populate\"] = message[\".gogoproto.populate\"];\n          if (message[\".gogoproto.onlyone\"] != null && message.hasOwnProperty(\".gogoproto.onlyone\")) object[\".gogoproto.onlyone\"] = message[\".gogoproto.onlyone\"];\n          if (message[\".gogoproto.equal\"] != null && message.hasOwnProperty(\".gogoproto.equal\")) object[\".gogoproto.equal\"] = message[\".gogoproto.equal\"];\n          if (message[\".gogoproto.description\"] != null && message.hasOwnProperty(\".gogoproto.description\")) object[\".gogoproto.description\"] = message[\".gogoproto.description\"];\n          if (message[\".gogoproto.testgen\"] != null && message.hasOwnProperty(\".gogoproto.testgen\")) object[\".gogoproto.testgen\"] = message[\".gogoproto.testgen\"];\n          if (message[\".gogoproto.benchgen\"] != null && message.hasOwnProperty(\".gogoproto.benchgen\")) object[\".gogoproto.benchgen\"] = message[\".gogoproto.benchgen\"];\n          if (message[\".gogoproto.marshaler\"] != null && message.hasOwnProperty(\".gogoproto.marshaler\")) object[\".gogoproto.marshaler\"] = message[\".gogoproto.marshaler\"];\n          if (message[\".gogoproto.unmarshaler\"] != null && message.hasOwnProperty(\".gogoproto.unmarshaler\")) object[\".gogoproto.unmarshaler\"] = message[\".gogoproto.unmarshaler\"];\n          if (message[\".gogoproto.stableMarshaler\"] != null && message.hasOwnProperty(\".gogoproto.stableMarshaler\")) object[\".gogoproto.stableMarshaler\"] = message[\".gogoproto.stableMarshaler\"];\n          if (message[\".gogoproto.sizer\"] != null && message.hasOwnProperty(\".gogoproto.sizer\")) object[\".gogoproto.sizer\"] = message[\".gogoproto.sizer\"];\n          if (message[\".gogoproto.unsafeMarshaler\"] != null && message.hasOwnProperty(\".gogoproto.unsafeMarshaler\")) object[\".gogoproto.unsafeMarshaler\"] = message[\".gogoproto.unsafeMarshaler\"];\n          if (message[\".gogoproto.unsafeUnmarshaler\"] != null && message.hasOwnProperty(\".gogoproto.unsafeUnmarshaler\")) object[\".gogoproto.unsafeUnmarshaler\"] = message[\".gogoproto.unsafeUnmarshaler\"];\n          if (message[\".gogoproto.goprotoExtensionsMap\"] != null && message.hasOwnProperty(\".gogoproto.goprotoExtensionsMap\")) object[\".gogoproto.goprotoExtensionsMap\"] = message[\".gogoproto.goprotoExtensionsMap\"];\n          if (message[\".gogoproto.goprotoUnrecognized\"] != null && message.hasOwnProperty(\".gogoproto.goprotoUnrecognized\")) object[\".gogoproto.goprotoUnrecognized\"] = message[\".gogoproto.goprotoUnrecognized\"];\n          if (message[\".gogoproto.protosizer\"] != null && message.hasOwnProperty(\".gogoproto.protosizer\")) object[\".gogoproto.protosizer\"] = message[\".gogoproto.protosizer\"];\n          if (message[\".gogoproto.compare\"] != null && message.hasOwnProperty(\".gogoproto.compare\")) object[\".gogoproto.compare\"] = message[\".gogoproto.compare\"];\n          if (message[\".gogoproto.typedecl\"] != null && message.hasOwnProperty(\".gogoproto.typedecl\")) object[\".gogoproto.typedecl\"] = message[\".gogoproto.typedecl\"];\n          if (message[\".gogoproto.messagename\"] != null && message.hasOwnProperty(\".gogoproto.messagename\")) object[\".gogoproto.messagename\"] = message[\".gogoproto.messagename\"];\n          if (message[\".gogoproto.goprotoSizecache\"] != null && message.hasOwnProperty(\".gogoproto.goprotoSizecache\")) object[\".gogoproto.goprotoSizecache\"] = message[\".gogoproto.goprotoSizecache\"];\n          if (message[\".gogoproto.goprotoUnkeyed\"] != null && message.hasOwnProperty(\".gogoproto.goprotoUnkeyed\")) object[\".gogoproto.goprotoUnkeyed\"] = message[\".gogoproto.goprotoUnkeyed\"];\n          if (message[\".gogoproto.stringer\"] != null && message.hasOwnProperty(\".gogoproto.stringer\")) object[\".gogoproto.stringer\"] = message[\".gogoproto.stringer\"];\n          return object;\n        };\n        /**\n         * Converts this MessageOptions to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.MessageOptions\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        MessageOptions.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return MessageOptions;\n      }();\n\n      protobuf.FieldOptions = function () {\n        /**\n         * Properties of a FieldOptions.\n         * @memberof google.protobuf\n         * @interface IFieldOptions\n         * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype\n         * @property {boolean|null} [packed] FieldOptions packed\n         * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype\n         * @property {boolean|null} [lazy] FieldOptions lazy\n         * @property {boolean|null} [deprecated] FieldOptions deprecated\n         * @property {boolean|null} [weak] FieldOptions weak\n         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption\n         * @property {boolean|null} [\".gogoproto.nullable\"] FieldOptions .gogoproto.nullable\n         * @property {boolean|null} [\".gogoproto.embed\"] FieldOptions .gogoproto.embed\n         * @property {string|null} [\".gogoproto.customtype\"] FieldOptions .gogoproto.customtype\n         * @property {string|null} [\".gogoproto.customname\"] FieldOptions .gogoproto.customname\n         * @property {string|null} [\".gogoproto.jsontag\"] FieldOptions .gogoproto.jsontag\n         * @property {string|null} [\".gogoproto.moretags\"] FieldOptions .gogoproto.moretags\n         * @property {string|null} [\".gogoproto.casttype\"] FieldOptions .gogoproto.casttype\n         * @property {string|null} [\".gogoproto.castkey\"] FieldOptions .gogoproto.castkey\n         * @property {string|null} [\".gogoproto.castvalue\"] FieldOptions .gogoproto.castvalue\n         * @property {boolean|null} [\".gogoproto.stdtime\"] FieldOptions .gogoproto.stdtime\n         * @property {boolean|null} [\".gogoproto.stdduration\"] FieldOptions .gogoproto.stdduration\n         * @property {boolean|null} [\".gogoproto.wktpointer\"] FieldOptions .gogoproto.wktpointer\n         * @property {string|null} [\".gogoproto.castrepeated\"] FieldOptions .gogoproto.castrepeated\n         */\n\n        /**\n         * Constructs a new FieldOptions.\n         * @memberof google.protobuf\n         * @classdesc Represents a FieldOptions.\n         * @implements IFieldOptions\n         * @constructor\n         * @param {google.protobuf.IFieldOptions=} [properties] Properties to set\n         */\n        function FieldOptions(properties) {\n          this.uninterpretedOption = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * FieldOptions ctype.\n         * @member {google.protobuf.FieldOptions.CType} ctype\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n\n        FieldOptions.prototype.ctype = 0;\n        /**\n         * FieldOptions packed.\n         * @member {boolean} packed\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype.packed = false;\n        /**\n         * FieldOptions jstype.\n         * @member {google.protobuf.FieldOptions.JSType} jstype\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype.jstype = 0;\n        /**\n         * FieldOptions lazy.\n         * @member {boolean} lazy\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype.lazy = false;\n        /**\n         * FieldOptions deprecated.\n         * @member {boolean} deprecated\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype.deprecated = false;\n        /**\n         * FieldOptions weak.\n         * @member {boolean} weak\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype.weak = false;\n        /**\n         * FieldOptions uninterpretedOption.\n         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype.uninterpretedOption = $util.emptyArray;\n        /**\n         * FieldOptions .gogoproto.nullable.\n         * @member {boolean} .gogoproto.nullable\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.nullable\"] = false;\n        /**\n         * FieldOptions .gogoproto.embed.\n         * @member {boolean} .gogoproto.embed\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.embed\"] = false;\n        /**\n         * FieldOptions .gogoproto.customtype.\n         * @member {string} .gogoproto.customtype\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.customtype\"] = \"\";\n        /**\n         * FieldOptions .gogoproto.customname.\n         * @member {string} .gogoproto.customname\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.customname\"] = \"\";\n        /**\n         * FieldOptions .gogoproto.jsontag.\n         * @member {string} .gogoproto.jsontag\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.jsontag\"] = \"\";\n        /**\n         * FieldOptions .gogoproto.moretags.\n         * @member {string} .gogoproto.moretags\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.moretags\"] = \"\";\n        /**\n         * FieldOptions .gogoproto.casttype.\n         * @member {string} .gogoproto.casttype\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.casttype\"] = \"\";\n        /**\n         * FieldOptions .gogoproto.castkey.\n         * @member {string} .gogoproto.castkey\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.castkey\"] = \"\";\n        /**\n         * FieldOptions .gogoproto.castvalue.\n         * @member {string} .gogoproto.castvalue\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.castvalue\"] = \"\";\n        /**\n         * FieldOptions .gogoproto.stdtime.\n         * @member {boolean} .gogoproto.stdtime\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.stdtime\"] = false;\n        /**\n         * FieldOptions .gogoproto.stdduration.\n         * @member {boolean} .gogoproto.stdduration\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.stdduration\"] = false;\n        /**\n         * FieldOptions .gogoproto.wktpointer.\n         * @member {boolean} .gogoproto.wktpointer\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.wktpointer\"] = false;\n        /**\n         * FieldOptions .gogoproto.castrepeated.\n         * @member {string} .gogoproto.castrepeated\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         */\n\n        FieldOptions.prototype[\".gogoproto.castrepeated\"] = \"\";\n        /**\n         * Creates a new FieldOptions instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.FieldOptions\n         * @static\n         * @param {google.protobuf.IFieldOptions=} [properties] Properties to set\n         * @returns {google.protobuf.FieldOptions} FieldOptions instance\n         */\n\n        FieldOptions.create = function create(properties) {\n          return new FieldOptions(properties);\n        };\n        /**\n         * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.FieldOptions\n         * @static\n         * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        FieldOptions.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.ctype != null && Object.hasOwnProperty.call(message, \"ctype\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int32(message.ctype);\n          if (message.packed != null && Object.hasOwnProperty.call(message, \"packed\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).bool(message.packed);\n          if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).bool(message.deprecated);\n          if (message.lazy != null && Object.hasOwnProperty.call(message, \"lazy\")) writer.uint32(\n          /* id 5, wireType 0 =*/\n          40).bool(message.lazy);\n          if (message.jstype != null && Object.hasOwnProperty.call(message, \"jstype\")) writer.uint32(\n          /* id 6, wireType 0 =*/\n          48).int32(message.jstype);\n          if (message.weak != null && Object.hasOwnProperty.call(message, \"weak\")) writer.uint32(\n          /* id 10, wireType 0 =*/\n          80).bool(message.weak);\n          if (message.uninterpretedOption != null && message.uninterpretedOption.length) for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(\n            /* id 999, wireType 2 =*/\n            7994).fork()).ldelim();\n          }\n          if (message[\".gogoproto.nullable\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.nullable\")) writer.uint32(\n          /* id 65001, wireType 0 =*/\n          520008).bool(message[\".gogoproto.nullable\"]);\n          if (message[\".gogoproto.embed\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.embed\")) writer.uint32(\n          /* id 65002, wireType 0 =*/\n          520016).bool(message[\".gogoproto.embed\"]);\n          if (message[\".gogoproto.customtype\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.customtype\")) writer.uint32(\n          /* id 65003, wireType 2 =*/\n          520026).string(message[\".gogoproto.customtype\"]);\n          if (message[\".gogoproto.customname\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.customname\")) writer.uint32(\n          /* id 65004, wireType 2 =*/\n          520034).string(message[\".gogoproto.customname\"]);\n          if (message[\".gogoproto.jsontag\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.jsontag\")) writer.uint32(\n          /* id 65005, wireType 2 =*/\n          520042).string(message[\".gogoproto.jsontag\"]);\n          if (message[\".gogoproto.moretags\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.moretags\")) writer.uint32(\n          /* id 65006, wireType 2 =*/\n          520050).string(message[\".gogoproto.moretags\"]);\n          if (message[\".gogoproto.casttype\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.casttype\")) writer.uint32(\n          /* id 65007, wireType 2 =*/\n          520058).string(message[\".gogoproto.casttype\"]);\n          if (message[\".gogoproto.castkey\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.castkey\")) writer.uint32(\n          /* id 65008, wireType 2 =*/\n          520066).string(message[\".gogoproto.castkey\"]);\n          if (message[\".gogoproto.castvalue\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.castvalue\")) writer.uint32(\n          /* id 65009, wireType 2 =*/\n          520074).string(message[\".gogoproto.castvalue\"]);\n          if (message[\".gogoproto.stdtime\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.stdtime\")) writer.uint32(\n          /* id 65010, wireType 0 =*/\n          520080).bool(message[\".gogoproto.stdtime\"]);\n          if (message[\".gogoproto.stdduration\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.stdduration\")) writer.uint32(\n          /* id 65011, wireType 0 =*/\n          520088).bool(message[\".gogoproto.stdduration\"]);\n          if (message[\".gogoproto.wktpointer\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.wktpointer\")) writer.uint32(\n          /* id 65012, wireType 0 =*/\n          520096).bool(message[\".gogoproto.wktpointer\"]);\n          if (message[\".gogoproto.castrepeated\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.castrepeated\")) writer.uint32(\n          /* id 65013, wireType 2 =*/\n          520106).string(message[\".gogoproto.castrepeated\"]);\n          return writer;\n        };\n        /**\n         * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.FieldOptions\n         * @static\n         * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a FieldOptions message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.FieldOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.FieldOptions} FieldOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        FieldOptions.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.FieldOptions();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.ctype = reader.int32();\n                break;\n\n              case 2:\n                message.packed = reader.bool();\n                break;\n\n              case 6:\n                message.jstype = reader.int32();\n                break;\n\n              case 5:\n                message.lazy = reader.bool();\n                break;\n\n              case 3:\n                message.deprecated = reader.bool();\n                break;\n\n              case 10:\n                message.weak = reader.bool();\n                break;\n\n              case 999:\n                if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                break;\n\n              case 65001:\n                message[\".gogoproto.nullable\"] = reader.bool();\n                break;\n\n              case 65002:\n                message[\".gogoproto.embed\"] = reader.bool();\n                break;\n\n              case 65003:\n                message[\".gogoproto.customtype\"] = reader.string();\n                break;\n\n              case 65004:\n                message[\".gogoproto.customname\"] = reader.string();\n                break;\n\n              case 65005:\n                message[\".gogoproto.jsontag\"] = reader.string();\n                break;\n\n              case 65006:\n                message[\".gogoproto.moretags\"] = reader.string();\n                break;\n\n              case 65007:\n                message[\".gogoproto.casttype\"] = reader.string();\n                break;\n\n              case 65008:\n                message[\".gogoproto.castkey\"] = reader.string();\n                break;\n\n              case 65009:\n                message[\".gogoproto.castvalue\"] = reader.string();\n                break;\n\n              case 65010:\n                message[\".gogoproto.stdtime\"] = reader.bool();\n                break;\n\n              case 65011:\n                message[\".gogoproto.stdduration\"] = reader.bool();\n                break;\n\n              case 65012:\n                message[\".gogoproto.wktpointer\"] = reader.bool();\n                break;\n\n              case 65013:\n                message[\".gogoproto.castrepeated\"] = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a FieldOptions message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.FieldOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.FieldOptions} FieldOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        FieldOptions.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a FieldOptions message.\n         * @function verify\n         * @memberof google.protobuf.FieldOptions\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        FieldOptions.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.ctype != null && message.hasOwnProperty(\"ctype\")) switch (message.ctype) {\n            default:\n              return \"ctype: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n              break;\n          }\n          if (message.packed != null && message.hasOwnProperty(\"packed\")) if (typeof message.packed !== \"boolean\") return \"packed: boolean expected\";\n          if (message.jstype != null && message.hasOwnProperty(\"jstype\")) switch (message.jstype) {\n            default:\n              return \"jstype: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n              break;\n          }\n          if (message.lazy != null && message.hasOwnProperty(\"lazy\")) if (typeof message.lazy !== \"boolean\") return \"lazy: boolean expected\";\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) if (typeof message.deprecated !== \"boolean\") return \"deprecated: boolean expected\";\n          if (message.weak != null && message.hasOwnProperty(\"weak\")) if (typeof message.weak !== \"boolean\") return \"weak: boolean expected\";\n\n          if (message.uninterpretedOption != null && message.hasOwnProperty(\"uninterpretedOption\")) {\n            if (!Array.isArray(message.uninterpretedOption)) return \"uninterpretedOption: array expected\";\n\n            for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);\n              if (error) return \"uninterpretedOption.\" + error;\n            }\n          }\n\n          if (message[\".gogoproto.nullable\"] != null && message.hasOwnProperty(\".gogoproto.nullable\")) if (typeof message[\".gogoproto.nullable\"] !== \"boolean\") return \".gogoproto.nullable: boolean expected\";\n          if (message[\".gogoproto.embed\"] != null && message.hasOwnProperty(\".gogoproto.embed\")) if (typeof message[\".gogoproto.embed\"] !== \"boolean\") return \".gogoproto.embed: boolean expected\";\n          if (message[\".gogoproto.customtype\"] != null && message.hasOwnProperty(\".gogoproto.customtype\")) if (!$util.isString(message[\".gogoproto.customtype\"])) return \".gogoproto.customtype: string expected\";\n          if (message[\".gogoproto.customname\"] != null && message.hasOwnProperty(\".gogoproto.customname\")) if (!$util.isString(message[\".gogoproto.customname\"])) return \".gogoproto.customname: string expected\";\n          if (message[\".gogoproto.jsontag\"] != null && message.hasOwnProperty(\".gogoproto.jsontag\")) if (!$util.isString(message[\".gogoproto.jsontag\"])) return \".gogoproto.jsontag: string expected\";\n          if (message[\".gogoproto.moretags\"] != null && message.hasOwnProperty(\".gogoproto.moretags\")) if (!$util.isString(message[\".gogoproto.moretags\"])) return \".gogoproto.moretags: string expected\";\n          if (message[\".gogoproto.casttype\"] != null && message.hasOwnProperty(\".gogoproto.casttype\")) if (!$util.isString(message[\".gogoproto.casttype\"])) return \".gogoproto.casttype: string expected\";\n          if (message[\".gogoproto.castkey\"] != null && message.hasOwnProperty(\".gogoproto.castkey\")) if (!$util.isString(message[\".gogoproto.castkey\"])) return \".gogoproto.castkey: string expected\";\n          if (message[\".gogoproto.castvalue\"] != null && message.hasOwnProperty(\".gogoproto.castvalue\")) if (!$util.isString(message[\".gogoproto.castvalue\"])) return \".gogoproto.castvalue: string expected\";\n          if (message[\".gogoproto.stdtime\"] != null && message.hasOwnProperty(\".gogoproto.stdtime\")) if (typeof message[\".gogoproto.stdtime\"] !== \"boolean\") return \".gogoproto.stdtime: boolean expected\";\n          if (message[\".gogoproto.stdduration\"] != null && message.hasOwnProperty(\".gogoproto.stdduration\")) if (typeof message[\".gogoproto.stdduration\"] !== \"boolean\") return \".gogoproto.stdduration: boolean expected\";\n          if (message[\".gogoproto.wktpointer\"] != null && message.hasOwnProperty(\".gogoproto.wktpointer\")) if (typeof message[\".gogoproto.wktpointer\"] !== \"boolean\") return \".gogoproto.wktpointer: boolean expected\";\n          if (message[\".gogoproto.castrepeated\"] != null && message.hasOwnProperty(\".gogoproto.castrepeated\")) if (!$util.isString(message[\".gogoproto.castrepeated\"])) return \".gogoproto.castrepeated: string expected\";\n          return null;\n        };\n        /**\n         * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.FieldOptions\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.FieldOptions} FieldOptions\n         */\n\n\n        FieldOptions.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.FieldOptions) return object;\n          var message = new $root.google.protobuf.FieldOptions();\n\n          switch (object.ctype) {\n            case \"STRING\":\n            case 0:\n              message.ctype = 0;\n              break;\n\n            case \"CORD\":\n            case 1:\n              message.ctype = 1;\n              break;\n\n            case \"STRING_PIECE\":\n            case 2:\n              message.ctype = 2;\n              break;\n          }\n\n          if (object.packed != null) message.packed = Boolean(object.packed);\n\n          switch (object.jstype) {\n            case \"JS_NORMAL\":\n            case 0:\n              message.jstype = 0;\n              break;\n\n            case \"JS_STRING\":\n            case 1:\n              message.jstype = 1;\n              break;\n\n            case \"JS_NUMBER\":\n            case 2:\n              message.jstype = 2;\n              break;\n          }\n\n          if (object.lazy != null) message.lazy = Boolean(object.lazy);\n          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);\n          if (object.weak != null) message.weak = Boolean(object.weak);\n\n          if (object.uninterpretedOption) {\n            if (!Array.isArray(object.uninterpretedOption)) throw TypeError(\".google.protobuf.FieldOptions.uninterpretedOption: array expected\");\n            message.uninterpretedOption = [];\n\n            for (var i = 0; i < object.uninterpretedOption.length; ++i) {\n              if (typeof object.uninterpretedOption[i] !== \"object\") throw TypeError(\".google.protobuf.FieldOptions.uninterpretedOption: object expected\");\n              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);\n            }\n          }\n\n          if (object[\".gogoproto.nullable\"] != null) message[\".gogoproto.nullable\"] = Boolean(object[\".gogoproto.nullable\"]);\n          if (object[\".gogoproto.embed\"] != null) message[\".gogoproto.embed\"] = Boolean(object[\".gogoproto.embed\"]);\n          if (object[\".gogoproto.customtype\"] != null) message[\".gogoproto.customtype\"] = String(object[\".gogoproto.customtype\"]);\n          if (object[\".gogoproto.customname\"] != null) message[\".gogoproto.customname\"] = String(object[\".gogoproto.customname\"]);\n          if (object[\".gogoproto.jsontag\"] != null) message[\".gogoproto.jsontag\"] = String(object[\".gogoproto.jsontag\"]);\n          if (object[\".gogoproto.moretags\"] != null) message[\".gogoproto.moretags\"] = String(object[\".gogoproto.moretags\"]);\n          if (object[\".gogoproto.casttype\"] != null) message[\".gogoproto.casttype\"] = String(object[\".gogoproto.casttype\"]);\n          if (object[\".gogoproto.castkey\"] != null) message[\".gogoproto.castkey\"] = String(object[\".gogoproto.castkey\"]);\n          if (object[\".gogoproto.castvalue\"] != null) message[\".gogoproto.castvalue\"] = String(object[\".gogoproto.castvalue\"]);\n          if (object[\".gogoproto.stdtime\"] != null) message[\".gogoproto.stdtime\"] = Boolean(object[\".gogoproto.stdtime\"]);\n          if (object[\".gogoproto.stdduration\"] != null) message[\".gogoproto.stdduration\"] = Boolean(object[\".gogoproto.stdduration\"]);\n          if (object[\".gogoproto.wktpointer\"] != null) message[\".gogoproto.wktpointer\"] = Boolean(object[\".gogoproto.wktpointer\"]);\n          if (object[\".gogoproto.castrepeated\"] != null) message[\".gogoproto.castrepeated\"] = String(object[\".gogoproto.castrepeated\"]);\n          return message;\n        };\n        /**\n         * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.FieldOptions\n         * @static\n         * @param {google.protobuf.FieldOptions} message FieldOptions\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        FieldOptions.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.uninterpretedOption = [];\n\n          if (options.defaults) {\n            object.ctype = options.enums === String ? \"STRING\" : 0;\n            object.packed = false;\n            object.deprecated = false;\n            object.lazy = false;\n            object.jstype = options.enums === String ? \"JS_NORMAL\" : 0;\n            object.weak = false;\n            object[\".gogoproto.nullable\"] = false;\n            object[\".gogoproto.embed\"] = false;\n            object[\".gogoproto.customtype\"] = \"\";\n            object[\".gogoproto.customname\"] = \"\";\n            object[\".gogoproto.jsontag\"] = \"\";\n            object[\".gogoproto.moretags\"] = \"\";\n            object[\".gogoproto.casttype\"] = \"\";\n            object[\".gogoproto.castkey\"] = \"\";\n            object[\".gogoproto.castvalue\"] = \"\";\n            object[\".gogoproto.stdtime\"] = false;\n            object[\".gogoproto.stdduration\"] = false;\n            object[\".gogoproto.wktpointer\"] = false;\n            object[\".gogoproto.castrepeated\"] = \"\";\n          }\n\n          if (message.ctype != null && message.hasOwnProperty(\"ctype\")) object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;\n          if (message.packed != null && message.hasOwnProperty(\"packed\")) object.packed = message.packed;\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) object.deprecated = message.deprecated;\n          if (message.lazy != null && message.hasOwnProperty(\"lazy\")) object.lazy = message.lazy;\n          if (message.jstype != null && message.hasOwnProperty(\"jstype\")) object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;\n          if (message.weak != null && message.hasOwnProperty(\"weak\")) object.weak = message.weak;\n\n          if (message.uninterpretedOption && message.uninterpretedOption.length) {\n            object.uninterpretedOption = [];\n\n            for (var j = 0; j < message.uninterpretedOption.length; ++j) {\n              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);\n            }\n          }\n\n          if (message[\".gogoproto.nullable\"] != null && message.hasOwnProperty(\".gogoproto.nullable\")) object[\".gogoproto.nullable\"] = message[\".gogoproto.nullable\"];\n          if (message[\".gogoproto.embed\"] != null && message.hasOwnProperty(\".gogoproto.embed\")) object[\".gogoproto.embed\"] = message[\".gogoproto.embed\"];\n          if (message[\".gogoproto.customtype\"] != null && message.hasOwnProperty(\".gogoproto.customtype\")) object[\".gogoproto.customtype\"] = message[\".gogoproto.customtype\"];\n          if (message[\".gogoproto.customname\"] != null && message.hasOwnProperty(\".gogoproto.customname\")) object[\".gogoproto.customname\"] = message[\".gogoproto.customname\"];\n          if (message[\".gogoproto.jsontag\"] != null && message.hasOwnProperty(\".gogoproto.jsontag\")) object[\".gogoproto.jsontag\"] = message[\".gogoproto.jsontag\"];\n          if (message[\".gogoproto.moretags\"] != null && message.hasOwnProperty(\".gogoproto.moretags\")) object[\".gogoproto.moretags\"] = message[\".gogoproto.moretags\"];\n          if (message[\".gogoproto.casttype\"] != null && message.hasOwnProperty(\".gogoproto.casttype\")) object[\".gogoproto.casttype\"] = message[\".gogoproto.casttype\"];\n          if (message[\".gogoproto.castkey\"] != null && message.hasOwnProperty(\".gogoproto.castkey\")) object[\".gogoproto.castkey\"] = message[\".gogoproto.castkey\"];\n          if (message[\".gogoproto.castvalue\"] != null && message.hasOwnProperty(\".gogoproto.castvalue\")) object[\".gogoproto.castvalue\"] = message[\".gogoproto.castvalue\"];\n          if (message[\".gogoproto.stdtime\"] != null && message.hasOwnProperty(\".gogoproto.stdtime\")) object[\".gogoproto.stdtime\"] = message[\".gogoproto.stdtime\"];\n          if (message[\".gogoproto.stdduration\"] != null && message.hasOwnProperty(\".gogoproto.stdduration\")) object[\".gogoproto.stdduration\"] = message[\".gogoproto.stdduration\"];\n          if (message[\".gogoproto.wktpointer\"] != null && message.hasOwnProperty(\".gogoproto.wktpointer\")) object[\".gogoproto.wktpointer\"] = message[\".gogoproto.wktpointer\"];\n          if (message[\".gogoproto.castrepeated\"] != null && message.hasOwnProperty(\".gogoproto.castrepeated\")) object[\".gogoproto.castrepeated\"] = message[\".gogoproto.castrepeated\"];\n          return object;\n        };\n        /**\n         * Converts this FieldOptions to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.FieldOptions\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        FieldOptions.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        /**\n         * CType enum.\n         * @name google.protobuf.FieldOptions.CType\n         * @enum {number}\n         * @property {number} STRING=0 STRING value\n         * @property {number} CORD=1 CORD value\n         * @property {number} STRING_PIECE=2 STRING_PIECE value\n         */\n\n\n        FieldOptions.CType = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[0] = \"STRING\"] = 0;\n          values[valuesById[1] = \"CORD\"] = 1;\n          values[valuesById[2] = \"STRING_PIECE\"] = 2;\n          return values;\n        }();\n        /**\n         * JSType enum.\n         * @name google.protobuf.FieldOptions.JSType\n         * @enum {number}\n         * @property {number} JS_NORMAL=0 JS_NORMAL value\n         * @property {number} JS_STRING=1 JS_STRING value\n         * @property {number} JS_NUMBER=2 JS_NUMBER value\n         */\n\n\n        FieldOptions.JSType = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[0] = \"JS_NORMAL\"] = 0;\n          values[valuesById[1] = \"JS_STRING\"] = 1;\n          values[valuesById[2] = \"JS_NUMBER\"] = 2;\n          return values;\n        }();\n\n        return FieldOptions;\n      }();\n\n      protobuf.OneofOptions = function () {\n        /**\n         * Properties of an OneofOptions.\n         * @memberof google.protobuf\n         * @interface IOneofOptions\n         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption\n         */\n\n        /**\n         * Constructs a new OneofOptions.\n         * @memberof google.protobuf\n         * @classdesc Represents an OneofOptions.\n         * @implements IOneofOptions\n         * @constructor\n         * @param {google.protobuf.IOneofOptions=} [properties] Properties to set\n         */\n        function OneofOptions(properties) {\n          this.uninterpretedOption = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * OneofOptions uninterpretedOption.\n         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n         * @memberof google.protobuf.OneofOptions\n         * @instance\n         */\n\n\n        OneofOptions.prototype.uninterpretedOption = $util.emptyArray;\n        /**\n         * Creates a new OneofOptions instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.OneofOptions\n         * @static\n         * @param {google.protobuf.IOneofOptions=} [properties] Properties to set\n         * @returns {google.protobuf.OneofOptions} OneofOptions instance\n         */\n\n        OneofOptions.create = function create(properties) {\n          return new OneofOptions(properties);\n        };\n        /**\n         * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.OneofOptions\n         * @static\n         * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        OneofOptions.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.uninterpretedOption != null && message.uninterpretedOption.length) for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(\n            /* id 999, wireType 2 =*/\n            7994).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.OneofOptions\n         * @static\n         * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an OneofOptions message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.OneofOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.OneofOptions} OneofOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        OneofOptions.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.OneofOptions();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 999:\n                if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an OneofOptions message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.OneofOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.OneofOptions} OneofOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        OneofOptions.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an OneofOptions message.\n         * @function verify\n         * @memberof google.protobuf.OneofOptions\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        OneofOptions.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.uninterpretedOption != null && message.hasOwnProperty(\"uninterpretedOption\")) {\n            if (!Array.isArray(message.uninterpretedOption)) return \"uninterpretedOption: array expected\";\n\n            for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);\n              if (error) return \"uninterpretedOption.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.OneofOptions\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.OneofOptions} OneofOptions\n         */\n\n\n        OneofOptions.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.OneofOptions) return object;\n          var message = new $root.google.protobuf.OneofOptions();\n\n          if (object.uninterpretedOption) {\n            if (!Array.isArray(object.uninterpretedOption)) throw TypeError(\".google.protobuf.OneofOptions.uninterpretedOption: array expected\");\n            message.uninterpretedOption = [];\n\n            for (var i = 0; i < object.uninterpretedOption.length; ++i) {\n              if (typeof object.uninterpretedOption[i] !== \"object\") throw TypeError(\".google.protobuf.OneofOptions.uninterpretedOption: object expected\");\n              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.OneofOptions\n         * @static\n         * @param {google.protobuf.OneofOptions} message OneofOptions\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        OneofOptions.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.uninterpretedOption = [];\n\n          if (message.uninterpretedOption && message.uninterpretedOption.length) {\n            object.uninterpretedOption = [];\n\n            for (var j = 0; j < message.uninterpretedOption.length; ++j) {\n              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this OneofOptions to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.OneofOptions\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        OneofOptions.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return OneofOptions;\n      }();\n\n      protobuf.EnumOptions = function () {\n        /**\n         * Properties of an EnumOptions.\n         * @memberof google.protobuf\n         * @interface IEnumOptions\n         * @property {boolean|null} [allowAlias] EnumOptions allowAlias\n         * @property {boolean|null} [deprecated] EnumOptions deprecated\n         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption\n         * @property {boolean|null} [\".gogoproto.goprotoEnumPrefix\"] EnumOptions .gogoproto.goprotoEnumPrefix\n         * @property {boolean|null} [\".gogoproto.goprotoEnumStringer\"] EnumOptions .gogoproto.goprotoEnumStringer\n         * @property {boolean|null} [\".gogoproto.enumStringer\"] EnumOptions .gogoproto.enumStringer\n         * @property {string|null} [\".gogoproto.enumCustomname\"] EnumOptions .gogoproto.enumCustomname\n         * @property {boolean|null} [\".gogoproto.enumdecl\"] EnumOptions .gogoproto.enumdecl\n         */\n\n        /**\n         * Constructs a new EnumOptions.\n         * @memberof google.protobuf\n         * @classdesc Represents an EnumOptions.\n         * @implements IEnumOptions\n         * @constructor\n         * @param {google.protobuf.IEnumOptions=} [properties] Properties to set\n         */\n        function EnumOptions(properties) {\n          this.uninterpretedOption = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * EnumOptions allowAlias.\n         * @member {boolean} allowAlias\n         * @memberof google.protobuf.EnumOptions\n         * @instance\n         */\n\n\n        EnumOptions.prototype.allowAlias = false;\n        /**\n         * EnumOptions deprecated.\n         * @member {boolean} deprecated\n         * @memberof google.protobuf.EnumOptions\n         * @instance\n         */\n\n        EnumOptions.prototype.deprecated = false;\n        /**\n         * EnumOptions uninterpretedOption.\n         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n         * @memberof google.protobuf.EnumOptions\n         * @instance\n         */\n\n        EnumOptions.prototype.uninterpretedOption = $util.emptyArray;\n        /**\n         * EnumOptions .gogoproto.goprotoEnumPrefix.\n         * @member {boolean} .gogoproto.goprotoEnumPrefix\n         * @memberof google.protobuf.EnumOptions\n         * @instance\n         */\n\n        EnumOptions.prototype[\".gogoproto.goprotoEnumPrefix\"] = false;\n        /**\n         * EnumOptions .gogoproto.goprotoEnumStringer.\n         * @member {boolean} .gogoproto.goprotoEnumStringer\n         * @memberof google.protobuf.EnumOptions\n         * @instance\n         */\n\n        EnumOptions.prototype[\".gogoproto.goprotoEnumStringer\"] = false;\n        /**\n         * EnumOptions .gogoproto.enumStringer.\n         * @member {boolean} .gogoproto.enumStringer\n         * @memberof google.protobuf.EnumOptions\n         * @instance\n         */\n\n        EnumOptions.prototype[\".gogoproto.enumStringer\"] = false;\n        /**\n         * EnumOptions .gogoproto.enumCustomname.\n         * @member {string} .gogoproto.enumCustomname\n         * @memberof google.protobuf.EnumOptions\n         * @instance\n         */\n\n        EnumOptions.prototype[\".gogoproto.enumCustomname\"] = \"\";\n        /**\n         * EnumOptions .gogoproto.enumdecl.\n         * @member {boolean} .gogoproto.enumdecl\n         * @memberof google.protobuf.EnumOptions\n         * @instance\n         */\n\n        EnumOptions.prototype[\".gogoproto.enumdecl\"] = false;\n        /**\n         * Creates a new EnumOptions instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.EnumOptions\n         * @static\n         * @param {google.protobuf.IEnumOptions=} [properties] Properties to set\n         * @returns {google.protobuf.EnumOptions} EnumOptions instance\n         */\n\n        EnumOptions.create = function create(properties) {\n          return new EnumOptions(properties);\n        };\n        /**\n         * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.EnumOptions\n         * @static\n         * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EnumOptions.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.allowAlias != null && Object.hasOwnProperty.call(message, \"allowAlias\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).bool(message.allowAlias);\n          if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\")) writer.uint32(\n          /* id 3, wireType 0 =*/\n          24).bool(message.deprecated);\n          if (message.uninterpretedOption != null && message.uninterpretedOption.length) for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(\n            /* id 999, wireType 2 =*/\n            7994).fork()).ldelim();\n          }\n          if (message[\".gogoproto.goprotoEnumPrefix\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoEnumPrefix\")) writer.uint32(\n          /* id 62001, wireType 0 =*/\n          496008).bool(message[\".gogoproto.goprotoEnumPrefix\"]);\n          if (message[\".gogoproto.goprotoEnumStringer\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.goprotoEnumStringer\")) writer.uint32(\n          /* id 62021, wireType 0 =*/\n          496168).bool(message[\".gogoproto.goprotoEnumStringer\"]);\n          if (message[\".gogoproto.enumStringer\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.enumStringer\")) writer.uint32(\n          /* id 62022, wireType 0 =*/\n          496176).bool(message[\".gogoproto.enumStringer\"]);\n          if (message[\".gogoproto.enumCustomname\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.enumCustomname\")) writer.uint32(\n          /* id 62023, wireType 2 =*/\n          496186).string(message[\".gogoproto.enumCustomname\"]);\n          if (message[\".gogoproto.enumdecl\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.enumdecl\")) writer.uint32(\n          /* id 62024, wireType 0 =*/\n          496192).bool(message[\".gogoproto.enumdecl\"]);\n          return writer;\n        };\n        /**\n         * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.EnumOptions\n         * @static\n         * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an EnumOptions message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.EnumOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.EnumOptions} EnumOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EnumOptions.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.EnumOptions();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 2:\n                message.allowAlias = reader.bool();\n                break;\n\n              case 3:\n                message.deprecated = reader.bool();\n                break;\n\n              case 999:\n                if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                break;\n\n              case 62001:\n                message[\".gogoproto.goprotoEnumPrefix\"] = reader.bool();\n                break;\n\n              case 62021:\n                message[\".gogoproto.goprotoEnumStringer\"] = reader.bool();\n                break;\n\n              case 62022:\n                message[\".gogoproto.enumStringer\"] = reader.bool();\n                break;\n\n              case 62023:\n                message[\".gogoproto.enumCustomname\"] = reader.string();\n                break;\n\n              case 62024:\n                message[\".gogoproto.enumdecl\"] = reader.bool();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an EnumOptions message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.EnumOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.EnumOptions} EnumOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EnumOptions.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an EnumOptions message.\n         * @function verify\n         * @memberof google.protobuf.EnumOptions\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        EnumOptions.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.allowAlias != null && message.hasOwnProperty(\"allowAlias\")) if (typeof message.allowAlias !== \"boolean\") return \"allowAlias: boolean expected\";\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) if (typeof message.deprecated !== \"boolean\") return \"deprecated: boolean expected\";\n\n          if (message.uninterpretedOption != null && message.hasOwnProperty(\"uninterpretedOption\")) {\n            if (!Array.isArray(message.uninterpretedOption)) return \"uninterpretedOption: array expected\";\n\n            for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);\n              if (error) return \"uninterpretedOption.\" + error;\n            }\n          }\n\n          if (message[\".gogoproto.goprotoEnumPrefix\"] != null && message.hasOwnProperty(\".gogoproto.goprotoEnumPrefix\")) if (typeof message[\".gogoproto.goprotoEnumPrefix\"] !== \"boolean\") return \".gogoproto.goprotoEnumPrefix: boolean expected\";\n          if (message[\".gogoproto.goprotoEnumStringer\"] != null && message.hasOwnProperty(\".gogoproto.goprotoEnumStringer\")) if (typeof message[\".gogoproto.goprotoEnumStringer\"] !== \"boolean\") return \".gogoproto.goprotoEnumStringer: boolean expected\";\n          if (message[\".gogoproto.enumStringer\"] != null && message.hasOwnProperty(\".gogoproto.enumStringer\")) if (typeof message[\".gogoproto.enumStringer\"] !== \"boolean\") return \".gogoproto.enumStringer: boolean expected\";\n          if (message[\".gogoproto.enumCustomname\"] != null && message.hasOwnProperty(\".gogoproto.enumCustomname\")) if (!$util.isString(message[\".gogoproto.enumCustomname\"])) return \".gogoproto.enumCustomname: string expected\";\n          if (message[\".gogoproto.enumdecl\"] != null && message.hasOwnProperty(\".gogoproto.enumdecl\")) if (typeof message[\".gogoproto.enumdecl\"] !== \"boolean\") return \".gogoproto.enumdecl: boolean expected\";\n          return null;\n        };\n        /**\n         * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.EnumOptions\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.EnumOptions} EnumOptions\n         */\n\n\n        EnumOptions.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.EnumOptions) return object;\n          var message = new $root.google.protobuf.EnumOptions();\n          if (object.allowAlias != null) message.allowAlias = Boolean(object.allowAlias);\n          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);\n\n          if (object.uninterpretedOption) {\n            if (!Array.isArray(object.uninterpretedOption)) throw TypeError(\".google.protobuf.EnumOptions.uninterpretedOption: array expected\");\n            message.uninterpretedOption = [];\n\n            for (var i = 0; i < object.uninterpretedOption.length; ++i) {\n              if (typeof object.uninterpretedOption[i] !== \"object\") throw TypeError(\".google.protobuf.EnumOptions.uninterpretedOption: object expected\");\n              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);\n            }\n          }\n\n          if (object[\".gogoproto.goprotoEnumPrefix\"] != null) message[\".gogoproto.goprotoEnumPrefix\"] = Boolean(object[\".gogoproto.goprotoEnumPrefix\"]);\n          if (object[\".gogoproto.goprotoEnumStringer\"] != null) message[\".gogoproto.goprotoEnumStringer\"] = Boolean(object[\".gogoproto.goprotoEnumStringer\"]);\n          if (object[\".gogoproto.enumStringer\"] != null) message[\".gogoproto.enumStringer\"] = Boolean(object[\".gogoproto.enumStringer\"]);\n          if (object[\".gogoproto.enumCustomname\"] != null) message[\".gogoproto.enumCustomname\"] = String(object[\".gogoproto.enumCustomname\"]);\n          if (object[\".gogoproto.enumdecl\"] != null) message[\".gogoproto.enumdecl\"] = Boolean(object[\".gogoproto.enumdecl\"]);\n          return message;\n        };\n        /**\n         * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.EnumOptions\n         * @static\n         * @param {google.protobuf.EnumOptions} message EnumOptions\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        EnumOptions.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.uninterpretedOption = [];\n\n          if (options.defaults) {\n            object.allowAlias = false;\n            object.deprecated = false;\n            object[\".gogoproto.goprotoEnumPrefix\"] = false;\n            object[\".gogoproto.goprotoEnumStringer\"] = false;\n            object[\".gogoproto.enumStringer\"] = false;\n            object[\".gogoproto.enumCustomname\"] = \"\";\n            object[\".gogoproto.enumdecl\"] = false;\n          }\n\n          if (message.allowAlias != null && message.hasOwnProperty(\"allowAlias\")) object.allowAlias = message.allowAlias;\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) object.deprecated = message.deprecated;\n\n          if (message.uninterpretedOption && message.uninterpretedOption.length) {\n            object.uninterpretedOption = [];\n\n            for (var j = 0; j < message.uninterpretedOption.length; ++j) {\n              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);\n            }\n          }\n\n          if (message[\".gogoproto.goprotoEnumPrefix\"] != null && message.hasOwnProperty(\".gogoproto.goprotoEnumPrefix\")) object[\".gogoproto.goprotoEnumPrefix\"] = message[\".gogoproto.goprotoEnumPrefix\"];\n          if (message[\".gogoproto.goprotoEnumStringer\"] != null && message.hasOwnProperty(\".gogoproto.goprotoEnumStringer\")) object[\".gogoproto.goprotoEnumStringer\"] = message[\".gogoproto.goprotoEnumStringer\"];\n          if (message[\".gogoproto.enumStringer\"] != null && message.hasOwnProperty(\".gogoproto.enumStringer\")) object[\".gogoproto.enumStringer\"] = message[\".gogoproto.enumStringer\"];\n          if (message[\".gogoproto.enumCustomname\"] != null && message.hasOwnProperty(\".gogoproto.enumCustomname\")) object[\".gogoproto.enumCustomname\"] = message[\".gogoproto.enumCustomname\"];\n          if (message[\".gogoproto.enumdecl\"] != null && message.hasOwnProperty(\".gogoproto.enumdecl\")) object[\".gogoproto.enumdecl\"] = message[\".gogoproto.enumdecl\"];\n          return object;\n        };\n        /**\n         * Converts this EnumOptions to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.EnumOptions\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        EnumOptions.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return EnumOptions;\n      }();\n\n      protobuf.EnumValueOptions = function () {\n        /**\n         * Properties of an EnumValueOptions.\n         * @memberof google.protobuf\n         * @interface IEnumValueOptions\n         * @property {boolean|null} [deprecated] EnumValueOptions deprecated\n         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption\n         * @property {string|null} [\".gogoproto.enumvalueCustomname\"] EnumValueOptions .gogoproto.enumvalueCustomname\n         */\n\n        /**\n         * Constructs a new EnumValueOptions.\n         * @memberof google.protobuf\n         * @classdesc Represents an EnumValueOptions.\n         * @implements IEnumValueOptions\n         * @constructor\n         * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set\n         */\n        function EnumValueOptions(properties) {\n          this.uninterpretedOption = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * EnumValueOptions deprecated.\n         * @member {boolean} deprecated\n         * @memberof google.protobuf.EnumValueOptions\n         * @instance\n         */\n\n\n        EnumValueOptions.prototype.deprecated = false;\n        /**\n         * EnumValueOptions uninterpretedOption.\n         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n         * @memberof google.protobuf.EnumValueOptions\n         * @instance\n         */\n\n        EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;\n        /**\n         * EnumValueOptions .gogoproto.enumvalueCustomname.\n         * @member {string} .gogoproto.enumvalueCustomname\n         * @memberof google.protobuf.EnumValueOptions\n         * @instance\n         */\n\n        EnumValueOptions.prototype[\".gogoproto.enumvalueCustomname\"] = \"\";\n        /**\n         * Creates a new EnumValueOptions instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.EnumValueOptions\n         * @static\n         * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set\n         * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance\n         */\n\n        EnumValueOptions.create = function create(properties) {\n          return new EnumValueOptions(properties);\n        };\n        /**\n         * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.EnumValueOptions\n         * @static\n         * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EnumValueOptions.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).bool(message.deprecated);\n          if (message.uninterpretedOption != null && message.uninterpretedOption.length) for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(\n            /* id 999, wireType 2 =*/\n            7994).fork()).ldelim();\n          }\n          if (message[\".gogoproto.enumvalueCustomname\"] != null && Object.hasOwnProperty.call(message, \".gogoproto.enumvalueCustomname\")) writer.uint32(\n          /* id 66001, wireType 2 =*/\n          528010).string(message[\".gogoproto.enumvalueCustomname\"]);\n          return writer;\n        };\n        /**\n         * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.EnumValueOptions\n         * @static\n         * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an EnumValueOptions message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.EnumValueOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.EnumValueOptions} EnumValueOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EnumValueOptions.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.EnumValueOptions();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.deprecated = reader.bool();\n                break;\n\n              case 999:\n                if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                break;\n\n              case 66001:\n                message[\".gogoproto.enumvalueCustomname\"] = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.EnumValueOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.EnumValueOptions} EnumValueOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an EnumValueOptions message.\n         * @function verify\n         * @memberof google.protobuf.EnumValueOptions\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        EnumValueOptions.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) if (typeof message.deprecated !== \"boolean\") return \"deprecated: boolean expected\";\n\n          if (message.uninterpretedOption != null && message.hasOwnProperty(\"uninterpretedOption\")) {\n            if (!Array.isArray(message.uninterpretedOption)) return \"uninterpretedOption: array expected\";\n\n            for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);\n              if (error) return \"uninterpretedOption.\" + error;\n            }\n          }\n\n          if (message[\".gogoproto.enumvalueCustomname\"] != null && message.hasOwnProperty(\".gogoproto.enumvalueCustomname\")) if (!$util.isString(message[\".gogoproto.enumvalueCustomname\"])) return \".gogoproto.enumvalueCustomname: string expected\";\n          return null;\n        };\n        /**\n         * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.EnumValueOptions\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.EnumValueOptions} EnumValueOptions\n         */\n\n\n        EnumValueOptions.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.EnumValueOptions) return object;\n          var message = new $root.google.protobuf.EnumValueOptions();\n          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);\n\n          if (object.uninterpretedOption) {\n            if (!Array.isArray(object.uninterpretedOption)) throw TypeError(\".google.protobuf.EnumValueOptions.uninterpretedOption: array expected\");\n            message.uninterpretedOption = [];\n\n            for (var i = 0; i < object.uninterpretedOption.length; ++i) {\n              if (typeof object.uninterpretedOption[i] !== \"object\") throw TypeError(\".google.protobuf.EnumValueOptions.uninterpretedOption: object expected\");\n              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);\n            }\n          }\n\n          if (object[\".gogoproto.enumvalueCustomname\"] != null) message[\".gogoproto.enumvalueCustomname\"] = String(object[\".gogoproto.enumvalueCustomname\"]);\n          return message;\n        };\n        /**\n         * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.EnumValueOptions\n         * @static\n         * @param {google.protobuf.EnumValueOptions} message EnumValueOptions\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        EnumValueOptions.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.uninterpretedOption = [];\n\n          if (options.defaults) {\n            object.deprecated = false;\n            object[\".gogoproto.enumvalueCustomname\"] = \"\";\n          }\n\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) object.deprecated = message.deprecated;\n\n          if (message.uninterpretedOption && message.uninterpretedOption.length) {\n            object.uninterpretedOption = [];\n\n            for (var j = 0; j < message.uninterpretedOption.length; ++j) {\n              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);\n            }\n          }\n\n          if (message[\".gogoproto.enumvalueCustomname\"] != null && message.hasOwnProperty(\".gogoproto.enumvalueCustomname\")) object[\".gogoproto.enumvalueCustomname\"] = message[\".gogoproto.enumvalueCustomname\"];\n          return object;\n        };\n        /**\n         * Converts this EnumValueOptions to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.EnumValueOptions\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        EnumValueOptions.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return EnumValueOptions;\n      }();\n\n      protobuf.ServiceOptions = function () {\n        /**\n         * Properties of a ServiceOptions.\n         * @memberof google.protobuf\n         * @interface IServiceOptions\n         * @property {boolean|null} [deprecated] ServiceOptions deprecated\n         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption\n         */\n\n        /**\n         * Constructs a new ServiceOptions.\n         * @memberof google.protobuf\n         * @classdesc Represents a ServiceOptions.\n         * @implements IServiceOptions\n         * @constructor\n         * @param {google.protobuf.IServiceOptions=} [properties] Properties to set\n         */\n        function ServiceOptions(properties) {\n          this.uninterpretedOption = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * ServiceOptions deprecated.\n         * @member {boolean} deprecated\n         * @memberof google.protobuf.ServiceOptions\n         * @instance\n         */\n\n\n        ServiceOptions.prototype.deprecated = false;\n        /**\n         * ServiceOptions uninterpretedOption.\n         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n         * @memberof google.protobuf.ServiceOptions\n         * @instance\n         */\n\n        ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;\n        /**\n         * Creates a new ServiceOptions instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.ServiceOptions\n         * @static\n         * @param {google.protobuf.IServiceOptions=} [properties] Properties to set\n         * @returns {google.protobuf.ServiceOptions} ServiceOptions instance\n         */\n\n        ServiceOptions.create = function create(properties) {\n          return new ServiceOptions(properties);\n        };\n        /**\n         * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.ServiceOptions\n         * @static\n         * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ServiceOptions.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\")) writer.uint32(\n          /* id 33, wireType 0 =*/\n          264).bool(message.deprecated);\n          if (message.uninterpretedOption != null && message.uninterpretedOption.length) for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(\n            /* id 999, wireType 2 =*/\n            7994).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.ServiceOptions\n         * @static\n         * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ServiceOptions message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.ServiceOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.ServiceOptions} ServiceOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ServiceOptions.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.ServiceOptions();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 33:\n                message.deprecated = reader.bool();\n                break;\n\n              case 999:\n                if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.ServiceOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.ServiceOptions} ServiceOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ServiceOptions.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ServiceOptions message.\n         * @function verify\n         * @memberof google.protobuf.ServiceOptions\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ServiceOptions.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) if (typeof message.deprecated !== \"boolean\") return \"deprecated: boolean expected\";\n\n          if (message.uninterpretedOption != null && message.hasOwnProperty(\"uninterpretedOption\")) {\n            if (!Array.isArray(message.uninterpretedOption)) return \"uninterpretedOption: array expected\";\n\n            for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);\n              if (error) return \"uninterpretedOption.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.ServiceOptions\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.ServiceOptions} ServiceOptions\n         */\n\n\n        ServiceOptions.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.ServiceOptions) return object;\n          var message = new $root.google.protobuf.ServiceOptions();\n          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);\n\n          if (object.uninterpretedOption) {\n            if (!Array.isArray(object.uninterpretedOption)) throw TypeError(\".google.protobuf.ServiceOptions.uninterpretedOption: array expected\");\n            message.uninterpretedOption = [];\n\n            for (var i = 0; i < object.uninterpretedOption.length; ++i) {\n              if (typeof object.uninterpretedOption[i] !== \"object\") throw TypeError(\".google.protobuf.ServiceOptions.uninterpretedOption: object expected\");\n              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.ServiceOptions\n         * @static\n         * @param {google.protobuf.ServiceOptions} message ServiceOptions\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ServiceOptions.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.uninterpretedOption = [];\n          if (options.defaults) object.deprecated = false;\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) object.deprecated = message.deprecated;\n\n          if (message.uninterpretedOption && message.uninterpretedOption.length) {\n            object.uninterpretedOption = [];\n\n            for (var j = 0; j < message.uninterpretedOption.length; ++j) {\n              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this ServiceOptions to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.ServiceOptions\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ServiceOptions.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ServiceOptions;\n      }();\n\n      protobuf.MethodOptions = function () {\n        /**\n         * Properties of a MethodOptions.\n         * @memberof google.protobuf\n         * @interface IMethodOptions\n         * @property {boolean|null} [deprecated] MethodOptions deprecated\n         * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption\n         */\n\n        /**\n         * Constructs a new MethodOptions.\n         * @memberof google.protobuf\n         * @classdesc Represents a MethodOptions.\n         * @implements IMethodOptions\n         * @constructor\n         * @param {google.protobuf.IMethodOptions=} [properties] Properties to set\n         */\n        function MethodOptions(properties) {\n          this.uninterpretedOption = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * MethodOptions deprecated.\n         * @member {boolean} deprecated\n         * @memberof google.protobuf.MethodOptions\n         * @instance\n         */\n\n\n        MethodOptions.prototype.deprecated = false;\n        /**\n         * MethodOptions uninterpretedOption.\n         * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n         * @memberof google.protobuf.MethodOptions\n         * @instance\n         */\n\n        MethodOptions.prototype.uninterpretedOption = $util.emptyArray;\n        /**\n         * Creates a new MethodOptions instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.MethodOptions\n         * @static\n         * @param {google.protobuf.IMethodOptions=} [properties] Properties to set\n         * @returns {google.protobuf.MethodOptions} MethodOptions instance\n         */\n\n        MethodOptions.create = function create(properties) {\n          return new MethodOptions(properties);\n        };\n        /**\n         * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.MethodOptions\n         * @static\n         * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        MethodOptions.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\")) writer.uint32(\n          /* id 33, wireType 0 =*/\n          264).bool(message.deprecated);\n          if (message.uninterpretedOption != null && message.uninterpretedOption.length) for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(\n            /* id 999, wireType 2 =*/\n            7994).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.MethodOptions\n         * @static\n         * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a MethodOptions message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.MethodOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.MethodOptions} MethodOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        MethodOptions.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.MethodOptions();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 33:\n                message.deprecated = reader.bool();\n                break;\n\n              case 999:\n                if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n                message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a MethodOptions message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.MethodOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.MethodOptions} MethodOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        MethodOptions.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a MethodOptions message.\n         * @function verify\n         * @memberof google.protobuf.MethodOptions\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        MethodOptions.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) if (typeof message.deprecated !== \"boolean\") return \"deprecated: boolean expected\";\n\n          if (message.uninterpretedOption != null && message.hasOwnProperty(\"uninterpretedOption\")) {\n            if (!Array.isArray(message.uninterpretedOption)) return \"uninterpretedOption: array expected\";\n\n            for (var i = 0; i < message.uninterpretedOption.length; ++i) {\n              var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);\n              if (error) return \"uninterpretedOption.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.MethodOptions\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.MethodOptions} MethodOptions\n         */\n\n\n        MethodOptions.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.MethodOptions) return object;\n          var message = new $root.google.protobuf.MethodOptions();\n          if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);\n\n          if (object.uninterpretedOption) {\n            if (!Array.isArray(object.uninterpretedOption)) throw TypeError(\".google.protobuf.MethodOptions.uninterpretedOption: array expected\");\n            message.uninterpretedOption = [];\n\n            for (var i = 0; i < object.uninterpretedOption.length; ++i) {\n              if (typeof object.uninterpretedOption[i] !== \"object\") throw TypeError(\".google.protobuf.MethodOptions.uninterpretedOption: object expected\");\n              message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.MethodOptions\n         * @static\n         * @param {google.protobuf.MethodOptions} message MethodOptions\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        MethodOptions.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.uninterpretedOption = [];\n          if (options.defaults) object.deprecated = false;\n          if (message.deprecated != null && message.hasOwnProperty(\"deprecated\")) object.deprecated = message.deprecated;\n\n          if (message.uninterpretedOption && message.uninterpretedOption.length) {\n            object.uninterpretedOption = [];\n\n            for (var j = 0; j < message.uninterpretedOption.length; ++j) {\n              object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this MethodOptions to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.MethodOptions\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        MethodOptions.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return MethodOptions;\n      }();\n\n      protobuf.UninterpretedOption = function () {\n        /**\n         * Properties of an UninterpretedOption.\n         * @memberof google.protobuf\n         * @interface IUninterpretedOption\n         * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name\n         * @property {string|null} [identifierValue] UninterpretedOption identifierValue\n         * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue\n         * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue\n         * @property {number|null} [doubleValue] UninterpretedOption doubleValue\n         * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue\n         * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue\n         */\n\n        /**\n         * Constructs a new UninterpretedOption.\n         * @memberof google.protobuf\n         * @classdesc Represents an UninterpretedOption.\n         * @implements IUninterpretedOption\n         * @constructor\n         * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set\n         */\n        function UninterpretedOption(properties) {\n          this.name = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * UninterpretedOption name.\n         * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name\n         * @memberof google.protobuf.UninterpretedOption\n         * @instance\n         */\n\n\n        UninterpretedOption.prototype.name = $util.emptyArray;\n        /**\n         * UninterpretedOption identifierValue.\n         * @member {string} identifierValue\n         * @memberof google.protobuf.UninterpretedOption\n         * @instance\n         */\n\n        UninterpretedOption.prototype.identifierValue = \"\";\n        /**\n         * UninterpretedOption positiveIntValue.\n         * @member {number|Long} positiveIntValue\n         * @memberof google.protobuf.UninterpretedOption\n         * @instance\n         */\n\n        UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        /**\n         * UninterpretedOption negativeIntValue.\n         * @member {number|Long} negativeIntValue\n         * @memberof google.protobuf.UninterpretedOption\n         * @instance\n         */\n\n        UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * UninterpretedOption doubleValue.\n         * @member {number} doubleValue\n         * @memberof google.protobuf.UninterpretedOption\n         * @instance\n         */\n\n        UninterpretedOption.prototype.doubleValue = 0;\n        /**\n         * UninterpretedOption stringValue.\n         * @member {Uint8Array} stringValue\n         * @memberof google.protobuf.UninterpretedOption\n         * @instance\n         */\n\n        UninterpretedOption.prototype.stringValue = $util.newBuffer([]);\n        /**\n         * UninterpretedOption aggregateValue.\n         * @member {string} aggregateValue\n         * @memberof google.protobuf.UninterpretedOption\n         * @instance\n         */\n\n        UninterpretedOption.prototype.aggregateValue = \"\";\n        /**\n         * Creates a new UninterpretedOption instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.UninterpretedOption\n         * @static\n         * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set\n         * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance\n         */\n\n        UninterpretedOption.create = function create(properties) {\n          return new UninterpretedOption(properties);\n        };\n        /**\n         * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.UninterpretedOption\n         * @static\n         * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        UninterpretedOption.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.name != null && message.name.length) for (var i = 0; i < message.name.length; ++i) {\n            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(\n            /* id 2, wireType 2 =*/\n            18).fork()).ldelim();\n          }\n          if (message.identifierValue != null && Object.hasOwnProperty.call(message, \"identifierValue\")) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).string(message.identifierValue);\n          if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, \"positiveIntValue\")) writer.uint32(\n          /* id 4, wireType 0 =*/\n          32).uint64(message.positiveIntValue);\n          if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, \"negativeIntValue\")) writer.uint32(\n          /* id 5, wireType 0 =*/\n          40).int64(message.negativeIntValue);\n          if (message.doubleValue != null && Object.hasOwnProperty.call(message, \"doubleValue\")) writer.uint32(\n          /* id 6, wireType 1 =*/\n          49).double(message.doubleValue);\n          if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\")) writer.uint32(\n          /* id 7, wireType 2 =*/\n          58).bytes(message.stringValue);\n          if (message.aggregateValue != null && Object.hasOwnProperty.call(message, \"aggregateValue\")) writer.uint32(\n          /* id 8, wireType 2 =*/\n          66).string(message.aggregateValue);\n          return writer;\n        };\n        /**\n         * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.UninterpretedOption\n         * @static\n         * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an UninterpretedOption message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.UninterpretedOption\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.UninterpretedOption} UninterpretedOption\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        UninterpretedOption.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.UninterpretedOption();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 2:\n                if (!(message.name && message.name.length)) message.name = [];\n                message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));\n                break;\n\n              case 3:\n                message.identifierValue = reader.string();\n                break;\n\n              case 4:\n                message.positiveIntValue = reader.uint64();\n                break;\n\n              case 5:\n                message.negativeIntValue = reader.int64();\n                break;\n\n              case 6:\n                message.doubleValue = reader.double();\n                break;\n\n              case 7:\n                message.stringValue = reader.bytes();\n                break;\n\n              case 8:\n                message.aggregateValue = reader.string();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.UninterpretedOption\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.UninterpretedOption} UninterpretedOption\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an UninterpretedOption message.\n         * @function verify\n         * @memberof google.protobuf.UninterpretedOption\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        UninterpretedOption.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.name != null && message.hasOwnProperty(\"name\")) {\n            if (!Array.isArray(message.name)) return \"name: array expected\";\n\n            for (var i = 0; i < message.name.length; ++i) {\n              var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);\n              if (error) return \"name.\" + error;\n            }\n          }\n\n          if (message.identifierValue != null && message.hasOwnProperty(\"identifierValue\")) if (!$util.isString(message.identifierValue)) return \"identifierValue: string expected\";\n          if (message.positiveIntValue != null && message.hasOwnProperty(\"positiveIntValue\")) if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high))) return \"positiveIntValue: integer|Long expected\";\n          if (message.negativeIntValue != null && message.hasOwnProperty(\"negativeIntValue\")) if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high))) return \"negativeIntValue: integer|Long expected\";\n          if (message.doubleValue != null && message.hasOwnProperty(\"doubleValue\")) if (typeof message.doubleValue !== \"number\") return \"doubleValue: number expected\";\n          if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) if (!(message.stringValue && typeof message.stringValue.length === \"number\" || $util.isString(message.stringValue))) return \"stringValue: buffer expected\";\n          if (message.aggregateValue != null && message.hasOwnProperty(\"aggregateValue\")) if (!$util.isString(message.aggregateValue)) return \"aggregateValue: string expected\";\n          return null;\n        };\n        /**\n         * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.UninterpretedOption\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.UninterpretedOption} UninterpretedOption\n         */\n\n\n        UninterpretedOption.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.UninterpretedOption) return object;\n          var message = new $root.google.protobuf.UninterpretedOption();\n\n          if (object.name) {\n            if (!Array.isArray(object.name)) throw TypeError(\".google.protobuf.UninterpretedOption.name: array expected\");\n            message.name = [];\n\n            for (var i = 0; i < object.name.length; ++i) {\n              if (typeof object.name[i] !== \"object\") throw TypeError(\".google.protobuf.UninterpretedOption.name: object expected\");\n              message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);\n            }\n          }\n\n          if (object.identifierValue != null) message.identifierValue = String(object.identifierValue);\n          if (object.positiveIntValue != null) if ($util.Long) (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;else if (typeof object.positiveIntValue === \"string\") message.positiveIntValue = parseInt(object.positiveIntValue, 10);else if (typeof object.positiveIntValue === \"number\") message.positiveIntValue = object.positiveIntValue;else if (typeof object.positiveIntValue === \"object\") message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);\n          if (object.negativeIntValue != null) if ($util.Long) (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;else if (typeof object.negativeIntValue === \"string\") message.negativeIntValue = parseInt(object.negativeIntValue, 10);else if (typeof object.negativeIntValue === \"number\") message.negativeIntValue = object.negativeIntValue;else if (typeof object.negativeIntValue === \"object\") message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();\n          if (object.doubleValue != null) message.doubleValue = Number(object.doubleValue);\n          if (object.stringValue != null) if (typeof object.stringValue === \"string\") $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);else if (object.stringValue.length) message.stringValue = object.stringValue;\n          if (object.aggregateValue != null) message.aggregateValue = String(object.aggregateValue);\n          return message;\n        };\n        /**\n         * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.UninterpretedOption\n         * @static\n         * @param {google.protobuf.UninterpretedOption} message UninterpretedOption\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        UninterpretedOption.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.name = [];\n\n          if (options.defaults) {\n            object.identifierValue = \"\";\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.positiveIntValue = options.longs === String ? \"0\" : 0;\n\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.negativeIntValue = options.longs === String ? \"0\" : 0;\n\n            object.doubleValue = 0;\n            if (options.bytes === String) object.stringValue = \"\";else {\n              object.stringValue = [];\n              if (options.bytes !== Array) object.stringValue = $util.newBuffer(object.stringValue);\n            }\n            object.aggregateValue = \"\";\n          }\n\n          if (message.name && message.name.length) {\n            object.name = [];\n\n            for (var j = 0; j < message.name.length; ++j) {\n              object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);\n            }\n          }\n\n          if (message.identifierValue != null && message.hasOwnProperty(\"identifierValue\")) object.identifierValue = message.identifierValue;\n          if (message.positiveIntValue != null && message.hasOwnProperty(\"positiveIntValue\")) if (typeof message.positiveIntValue === \"number\") object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;else object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;\n          if (message.negativeIntValue != null && message.hasOwnProperty(\"negativeIntValue\")) if (typeof message.negativeIntValue === \"number\") object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;else object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;\n          if (message.doubleValue != null && message.hasOwnProperty(\"doubleValue\")) object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;\n          if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;\n          if (message.aggregateValue != null && message.hasOwnProperty(\"aggregateValue\")) object.aggregateValue = message.aggregateValue;\n          return object;\n        };\n        /**\n         * Converts this UninterpretedOption to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.UninterpretedOption\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        UninterpretedOption.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        UninterpretedOption.NamePart = function () {\n          /**\n           * Properties of a NamePart.\n           * @memberof google.protobuf.UninterpretedOption\n           * @interface INamePart\n           * @property {string} namePart NamePart namePart\n           * @property {boolean} isExtension NamePart isExtension\n           */\n\n          /**\n           * Constructs a new NamePart.\n           * @memberof google.protobuf.UninterpretedOption\n           * @classdesc Represents a NamePart.\n           * @implements INamePart\n           * @constructor\n           * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set\n           */\n          function NamePart(properties) {\n            if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n            }\n          }\n          /**\n           * NamePart namePart.\n           * @member {string} namePart\n           * @memberof google.protobuf.UninterpretedOption.NamePart\n           * @instance\n           */\n\n\n          NamePart.prototype.namePart = \"\";\n          /**\n           * NamePart isExtension.\n           * @member {boolean} isExtension\n           * @memberof google.protobuf.UninterpretedOption.NamePart\n           * @instance\n           */\n\n          NamePart.prototype.isExtension = false;\n          /**\n           * Creates a new NamePart instance using the specified properties.\n           * @function create\n           * @memberof google.protobuf.UninterpretedOption.NamePart\n           * @static\n           * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set\n           * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance\n           */\n\n          NamePart.create = function create(properties) {\n            return new NamePart(properties);\n          };\n          /**\n           * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.\n           * @function encode\n           * @memberof google.protobuf.UninterpretedOption.NamePart\n           * @static\n           * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode\n           * @param {$protobuf.Writer} [writer] Writer to encode to\n           * @returns {$protobuf.Writer} Writer\n           */\n\n\n          NamePart.encode = function encode(message, writer) {\n            if (!writer) writer = $Writer.create();\n            writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).string(message.namePart);\n            writer.uint32(\n            /* id 2, wireType 0 =*/\n            16).bool(message.isExtension);\n            return writer;\n          };\n          /**\n           * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.\n           * @function encodeDelimited\n           * @memberof google.protobuf.UninterpretedOption.NamePart\n           * @static\n           * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode\n           * @param {$protobuf.Writer} [writer] Writer to encode to\n           * @returns {$protobuf.Writer} Writer\n           */\n\n\n          NamePart.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          /**\n           * Decodes a NamePart message from the specified reader or buffer.\n           * @function decode\n           * @memberof google.protobuf.UninterpretedOption.NamePart\n           * @static\n           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n           * @param {number} [length] Message length if known beforehand\n           * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart\n           * @throws {Error} If the payload is not a reader or valid buffer\n           * @throws {$protobuf.util.ProtocolError} If required fields are missing\n           */\n\n\n          NamePart.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length,\n                message = new $root.google.protobuf.UninterpretedOption.NamePart();\n\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n\n              switch (tag >>> 3) {\n                case 1:\n                  message.namePart = reader.string();\n                  break;\n\n                case 2:\n                  message.isExtension = reader.bool();\n                  break;\n\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n\n            if (!message.hasOwnProperty(\"namePart\")) throw $util.ProtocolError(\"missing required 'namePart'\", {\n              instance: message\n            });\n            if (!message.hasOwnProperty(\"isExtension\")) throw $util.ProtocolError(\"missing required 'isExtension'\", {\n              instance: message\n            });\n            return message;\n          };\n          /**\n           * Decodes a NamePart message from the specified reader or buffer, length delimited.\n           * @function decodeDelimited\n           * @memberof google.protobuf.UninterpretedOption.NamePart\n           * @static\n           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n           * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart\n           * @throws {Error} If the payload is not a reader or valid buffer\n           * @throws {$protobuf.util.ProtocolError} If required fields are missing\n           */\n\n\n          NamePart.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          /**\n           * Verifies a NamePart message.\n           * @function verify\n           * @memberof google.protobuf.UninterpretedOption.NamePart\n           * @static\n           * @param {Object.<string,*>} message Plain object to verify\n           * @returns {string|null} `null` if valid, otherwise the reason why it is not\n           */\n\n\n          NamePart.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null) return \"object expected\";\n            if (!$util.isString(message.namePart)) return \"namePart: string expected\";\n            if (typeof message.isExtension !== \"boolean\") return \"isExtension: boolean expected\";\n            return null;\n          };\n          /**\n           * Creates a NamePart message from a plain object. Also converts values to their respective internal types.\n           * @function fromObject\n           * @memberof google.protobuf.UninterpretedOption.NamePart\n           * @static\n           * @param {Object.<string,*>} object Plain object\n           * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart\n           */\n\n\n          NamePart.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart) return object;\n            var message = new $root.google.protobuf.UninterpretedOption.NamePart();\n            if (object.namePart != null) message.namePart = String(object.namePart);\n            if (object.isExtension != null) message.isExtension = Boolean(object.isExtension);\n            return message;\n          };\n          /**\n           * Creates a plain object from a NamePart message. Also converts values to other types if specified.\n           * @function toObject\n           * @memberof google.protobuf.UninterpretedOption.NamePart\n           * @static\n           * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart\n           * @param {$protobuf.IConversionOptions} [options] Conversion options\n           * @returns {Object.<string,*>} Plain object\n           */\n\n\n          NamePart.toObject = function toObject(message, options) {\n            if (!options) options = {};\n            var object = {};\n\n            if (options.defaults) {\n              object.namePart = \"\";\n              object.isExtension = false;\n            }\n\n            if (message.namePart != null && message.hasOwnProperty(\"namePart\")) object.namePart = message.namePart;\n            if (message.isExtension != null && message.hasOwnProperty(\"isExtension\")) object.isExtension = message.isExtension;\n            return object;\n          };\n          /**\n           * Converts this NamePart to JSON.\n           * @function toJSON\n           * @memberof google.protobuf.UninterpretedOption.NamePart\n           * @instance\n           * @returns {Object.<string,*>} JSON object\n           */\n\n\n          NamePart.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n\n          return NamePart;\n        }();\n\n        return UninterpretedOption;\n      }();\n\n      protobuf.SourceCodeInfo = function () {\n        /**\n         * Properties of a SourceCodeInfo.\n         * @memberof google.protobuf\n         * @interface ISourceCodeInfo\n         * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location\n         */\n\n        /**\n         * Constructs a new SourceCodeInfo.\n         * @memberof google.protobuf\n         * @classdesc Represents a SourceCodeInfo.\n         * @implements ISourceCodeInfo\n         * @constructor\n         * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set\n         */\n        function SourceCodeInfo(properties) {\n          this.location = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * SourceCodeInfo location.\n         * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location\n         * @memberof google.protobuf.SourceCodeInfo\n         * @instance\n         */\n\n\n        SourceCodeInfo.prototype.location = $util.emptyArray;\n        /**\n         * Creates a new SourceCodeInfo instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.SourceCodeInfo\n         * @static\n         * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set\n         * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance\n         */\n\n        SourceCodeInfo.create = function create(properties) {\n          return new SourceCodeInfo(properties);\n        };\n        /**\n         * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.SourceCodeInfo\n         * @static\n         * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SourceCodeInfo.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.location != null && message.location.length) for (var i = 0; i < message.location.length; ++i) {\n            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.SourceCodeInfo\n         * @static\n         * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a SourceCodeInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.SourceCodeInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SourceCodeInfo.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.SourceCodeInfo();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.location && message.location.length)) message.location = [];\n                message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.SourceCodeInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a SourceCodeInfo message.\n         * @function verify\n         * @memberof google.protobuf.SourceCodeInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        SourceCodeInfo.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.location != null && message.hasOwnProperty(\"location\")) {\n            if (!Array.isArray(message.location)) return \"location: array expected\";\n\n            for (var i = 0; i < message.location.length; ++i) {\n              var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);\n              if (error) return \"location.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.SourceCodeInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo\n         */\n\n\n        SourceCodeInfo.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.SourceCodeInfo) return object;\n          var message = new $root.google.protobuf.SourceCodeInfo();\n\n          if (object.location) {\n            if (!Array.isArray(object.location)) throw TypeError(\".google.protobuf.SourceCodeInfo.location: array expected\");\n            message.location = [];\n\n            for (var i = 0; i < object.location.length; ++i) {\n              if (typeof object.location[i] !== \"object\") throw TypeError(\".google.protobuf.SourceCodeInfo.location: object expected\");\n              message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.SourceCodeInfo\n         * @static\n         * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        SourceCodeInfo.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.location = [];\n\n          if (message.location && message.location.length) {\n            object.location = [];\n\n            for (var j = 0; j < message.location.length; ++j) {\n              object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this SourceCodeInfo to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.SourceCodeInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        SourceCodeInfo.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        SourceCodeInfo.Location = function () {\n          /**\n           * Properties of a Location.\n           * @memberof google.protobuf.SourceCodeInfo\n           * @interface ILocation\n           * @property {Array.<number>|null} [path] Location path\n           * @property {Array.<number>|null} [span] Location span\n           * @property {string|null} [leadingComments] Location leadingComments\n           * @property {string|null} [trailingComments] Location trailingComments\n           * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments\n           */\n\n          /**\n           * Constructs a new Location.\n           * @memberof google.protobuf.SourceCodeInfo\n           * @classdesc Represents a Location.\n           * @implements ILocation\n           * @constructor\n           * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set\n           */\n          function Location(properties) {\n            this.path = [];\n            this.span = [];\n            this.leadingDetachedComments = [];\n            if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n            }\n          }\n          /**\n           * Location path.\n           * @member {Array.<number>} path\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @instance\n           */\n\n\n          Location.prototype.path = $util.emptyArray;\n          /**\n           * Location span.\n           * @member {Array.<number>} span\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @instance\n           */\n\n          Location.prototype.span = $util.emptyArray;\n          /**\n           * Location leadingComments.\n           * @member {string} leadingComments\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @instance\n           */\n\n          Location.prototype.leadingComments = \"\";\n          /**\n           * Location trailingComments.\n           * @member {string} trailingComments\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @instance\n           */\n\n          Location.prototype.trailingComments = \"\";\n          /**\n           * Location leadingDetachedComments.\n           * @member {Array.<string>} leadingDetachedComments\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @instance\n           */\n\n          Location.prototype.leadingDetachedComments = $util.emptyArray;\n          /**\n           * Creates a new Location instance using the specified properties.\n           * @function create\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @static\n           * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set\n           * @returns {google.protobuf.SourceCodeInfo.Location} Location instance\n           */\n\n          Location.create = function create(properties) {\n            return new Location(properties);\n          };\n          /**\n           * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.\n           * @function encode\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @static\n           * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode\n           * @param {$protobuf.Writer} [writer] Writer to encode to\n           * @returns {$protobuf.Writer} Writer\n           */\n\n\n          Location.encode = function encode(message, writer) {\n            if (!writer) writer = $Writer.create();\n\n            if (message.path != null && message.path.length) {\n              writer.uint32(\n              /* id 1, wireType 2 =*/\n              10).fork();\n\n              for (var i = 0; i < message.path.length; ++i) {\n                writer.int32(message.path[i]);\n              }\n\n              writer.ldelim();\n            }\n\n            if (message.span != null && message.span.length) {\n              writer.uint32(\n              /* id 2, wireType 2 =*/\n              18).fork();\n\n              for (var i = 0; i < message.span.length; ++i) {\n                writer.int32(message.span[i]);\n              }\n\n              writer.ldelim();\n            }\n\n            if (message.leadingComments != null && Object.hasOwnProperty.call(message, \"leadingComments\")) writer.uint32(\n            /* id 3, wireType 2 =*/\n            26).string(message.leadingComments);\n            if (message.trailingComments != null && Object.hasOwnProperty.call(message, \"trailingComments\")) writer.uint32(\n            /* id 4, wireType 2 =*/\n            34).string(message.trailingComments);\n            if (message.leadingDetachedComments != null && message.leadingDetachedComments.length) for (var i = 0; i < message.leadingDetachedComments.length; ++i) {\n              writer.uint32(\n              /* id 6, wireType 2 =*/\n              50).string(message.leadingDetachedComments[i]);\n            }\n            return writer;\n          };\n          /**\n           * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.\n           * @function encodeDelimited\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @static\n           * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode\n           * @param {$protobuf.Writer} [writer] Writer to encode to\n           * @returns {$protobuf.Writer} Writer\n           */\n\n\n          Location.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          /**\n           * Decodes a Location message from the specified reader or buffer.\n           * @function decode\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @static\n           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n           * @param {number} [length] Message length if known beforehand\n           * @returns {google.protobuf.SourceCodeInfo.Location} Location\n           * @throws {Error} If the payload is not a reader or valid buffer\n           * @throws {$protobuf.util.ProtocolError} If required fields are missing\n           */\n\n\n          Location.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length,\n                message = new $root.google.protobuf.SourceCodeInfo.Location();\n\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n\n              switch (tag >>> 3) {\n                case 1:\n                  if (!(message.path && message.path.length)) message.path = [];\n\n                  if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n\n                    while (reader.pos < end2) {\n                      message.path.push(reader.int32());\n                    }\n                  } else message.path.push(reader.int32());\n\n                  break;\n\n                case 2:\n                  if (!(message.span && message.span.length)) message.span = [];\n\n                  if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n\n                    while (reader.pos < end2) {\n                      message.span.push(reader.int32());\n                    }\n                  } else message.span.push(reader.int32());\n\n                  break;\n\n                case 3:\n                  message.leadingComments = reader.string();\n                  break;\n\n                case 4:\n                  message.trailingComments = reader.string();\n                  break;\n\n                case 6:\n                  if (!(message.leadingDetachedComments && message.leadingDetachedComments.length)) message.leadingDetachedComments = [];\n                  message.leadingDetachedComments.push(reader.string());\n                  break;\n\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n\n            return message;\n          };\n          /**\n           * Decodes a Location message from the specified reader or buffer, length delimited.\n           * @function decodeDelimited\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @static\n           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n           * @returns {google.protobuf.SourceCodeInfo.Location} Location\n           * @throws {Error} If the payload is not a reader or valid buffer\n           * @throws {$protobuf.util.ProtocolError} If required fields are missing\n           */\n\n\n          Location.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          /**\n           * Verifies a Location message.\n           * @function verify\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @static\n           * @param {Object.<string,*>} message Plain object to verify\n           * @returns {string|null} `null` if valid, otherwise the reason why it is not\n           */\n\n\n          Location.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n              if (!Array.isArray(message.path)) return \"path: array expected\";\n\n              for (var i = 0; i < message.path.length; ++i) {\n                if (!$util.isInteger(message.path[i])) return \"path: integer[] expected\";\n              }\n            }\n\n            if (message.span != null && message.hasOwnProperty(\"span\")) {\n              if (!Array.isArray(message.span)) return \"span: array expected\";\n\n              for (var i = 0; i < message.span.length; ++i) {\n                if (!$util.isInteger(message.span[i])) return \"span: integer[] expected\";\n              }\n            }\n\n            if (message.leadingComments != null && message.hasOwnProperty(\"leadingComments\")) if (!$util.isString(message.leadingComments)) return \"leadingComments: string expected\";\n            if (message.trailingComments != null && message.hasOwnProperty(\"trailingComments\")) if (!$util.isString(message.trailingComments)) return \"trailingComments: string expected\";\n\n            if (message.leadingDetachedComments != null && message.hasOwnProperty(\"leadingDetachedComments\")) {\n              if (!Array.isArray(message.leadingDetachedComments)) return \"leadingDetachedComments: array expected\";\n\n              for (var i = 0; i < message.leadingDetachedComments.length; ++i) {\n                if (!$util.isString(message.leadingDetachedComments[i])) return \"leadingDetachedComments: string[] expected\";\n              }\n            }\n\n            return null;\n          };\n          /**\n           * Creates a Location message from a plain object. Also converts values to their respective internal types.\n           * @function fromObject\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @static\n           * @param {Object.<string,*>} object Plain object\n           * @returns {google.protobuf.SourceCodeInfo.Location} Location\n           */\n\n\n          Location.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.SourceCodeInfo.Location) return object;\n            var message = new $root.google.protobuf.SourceCodeInfo.Location();\n\n            if (object.path) {\n              if (!Array.isArray(object.path)) throw TypeError(\".google.protobuf.SourceCodeInfo.Location.path: array expected\");\n              message.path = [];\n\n              for (var i = 0; i < object.path.length; ++i) {\n                message.path[i] = object.path[i] | 0;\n              }\n            }\n\n            if (object.span) {\n              if (!Array.isArray(object.span)) throw TypeError(\".google.protobuf.SourceCodeInfo.Location.span: array expected\");\n              message.span = [];\n\n              for (var i = 0; i < object.span.length; ++i) {\n                message.span[i] = object.span[i] | 0;\n              }\n            }\n\n            if (object.leadingComments != null) message.leadingComments = String(object.leadingComments);\n            if (object.trailingComments != null) message.trailingComments = String(object.trailingComments);\n\n            if (object.leadingDetachedComments) {\n              if (!Array.isArray(object.leadingDetachedComments)) throw TypeError(\".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected\");\n              message.leadingDetachedComments = [];\n\n              for (var i = 0; i < object.leadingDetachedComments.length; ++i) {\n                message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);\n              }\n            }\n\n            return message;\n          };\n          /**\n           * Creates a plain object from a Location message. Also converts values to other types if specified.\n           * @function toObject\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @static\n           * @param {google.protobuf.SourceCodeInfo.Location} message Location\n           * @param {$protobuf.IConversionOptions} [options] Conversion options\n           * @returns {Object.<string,*>} Plain object\n           */\n\n\n          Location.toObject = function toObject(message, options) {\n            if (!options) options = {};\n            var object = {};\n\n            if (options.arrays || options.defaults) {\n              object.path = [];\n              object.span = [];\n              object.leadingDetachedComments = [];\n            }\n\n            if (options.defaults) {\n              object.leadingComments = \"\";\n              object.trailingComments = \"\";\n            }\n\n            if (message.path && message.path.length) {\n              object.path = [];\n\n              for (var j = 0; j < message.path.length; ++j) {\n                object.path[j] = message.path[j];\n              }\n            }\n\n            if (message.span && message.span.length) {\n              object.span = [];\n\n              for (var j = 0; j < message.span.length; ++j) {\n                object.span[j] = message.span[j];\n              }\n            }\n\n            if (message.leadingComments != null && message.hasOwnProperty(\"leadingComments\")) object.leadingComments = message.leadingComments;\n            if (message.trailingComments != null && message.hasOwnProperty(\"trailingComments\")) object.trailingComments = message.trailingComments;\n\n            if (message.leadingDetachedComments && message.leadingDetachedComments.length) {\n              object.leadingDetachedComments = [];\n\n              for (var j = 0; j < message.leadingDetachedComments.length; ++j) {\n                object.leadingDetachedComments[j] = message.leadingDetachedComments[j];\n              }\n            }\n\n            return object;\n          };\n          /**\n           * Converts this Location to JSON.\n           * @function toJSON\n           * @memberof google.protobuf.SourceCodeInfo.Location\n           * @instance\n           * @returns {Object.<string,*>} JSON object\n           */\n\n\n          Location.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n\n          return Location;\n        }();\n\n        return SourceCodeInfo;\n      }();\n\n      protobuf.GeneratedCodeInfo = function () {\n        /**\n         * Properties of a GeneratedCodeInfo.\n         * @memberof google.protobuf\n         * @interface IGeneratedCodeInfo\n         * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation\n         */\n\n        /**\n         * Constructs a new GeneratedCodeInfo.\n         * @memberof google.protobuf\n         * @classdesc Represents a GeneratedCodeInfo.\n         * @implements IGeneratedCodeInfo\n         * @constructor\n         * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set\n         */\n        function GeneratedCodeInfo(properties) {\n          this.annotation = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * GeneratedCodeInfo annotation.\n         * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation\n         * @memberof google.protobuf.GeneratedCodeInfo\n         * @instance\n         */\n\n\n        GeneratedCodeInfo.prototype.annotation = $util.emptyArray;\n        /**\n         * Creates a new GeneratedCodeInfo instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.GeneratedCodeInfo\n         * @static\n         * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set\n         * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance\n         */\n\n        GeneratedCodeInfo.create = function create(properties) {\n          return new GeneratedCodeInfo(properties);\n        };\n        /**\n         * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.GeneratedCodeInfo\n         * @static\n         * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        GeneratedCodeInfo.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.annotation != null && message.annotation.length) for (var i = 0; i < message.annotation.length; ++i) {\n            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(\n            /* id 1, wireType 2 =*/\n            10).fork()).ldelim();\n          }\n          return writer;\n        };\n        /**\n         * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.GeneratedCodeInfo\n         * @static\n         * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a GeneratedCodeInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.GeneratedCodeInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        GeneratedCodeInfo.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.GeneratedCodeInfo();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.annotation && message.annotation.length)) message.annotation = [];\n                message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.GeneratedCodeInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a GeneratedCodeInfo message.\n         * @function verify\n         * @memberof google.protobuf.GeneratedCodeInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        GeneratedCodeInfo.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n          if (message.annotation != null && message.hasOwnProperty(\"annotation\")) {\n            if (!Array.isArray(message.annotation)) return \"annotation: array expected\";\n\n            for (var i = 0; i < message.annotation.length; ++i) {\n              var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);\n              if (error) return \"annotation.\" + error;\n            }\n          }\n\n          return null;\n        };\n        /**\n         * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.GeneratedCodeInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo\n         */\n\n\n        GeneratedCodeInfo.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.GeneratedCodeInfo) return object;\n          var message = new $root.google.protobuf.GeneratedCodeInfo();\n\n          if (object.annotation) {\n            if (!Array.isArray(object.annotation)) throw TypeError(\".google.protobuf.GeneratedCodeInfo.annotation: array expected\");\n            message.annotation = [];\n\n            for (var i = 0; i < object.annotation.length; ++i) {\n              if (typeof object.annotation[i] !== \"object\") throw TypeError(\".google.protobuf.GeneratedCodeInfo.annotation: object expected\");\n              message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.GeneratedCodeInfo\n         * @static\n         * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        GeneratedCodeInfo.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n          if (options.arrays || options.defaults) object.annotation = [];\n\n          if (message.annotation && message.annotation.length) {\n            object.annotation = [];\n\n            for (var j = 0; j < message.annotation.length; ++j) {\n              object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);\n            }\n          }\n\n          return object;\n        };\n        /**\n         * Converts this GeneratedCodeInfo to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.GeneratedCodeInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        GeneratedCodeInfo.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        GeneratedCodeInfo.Annotation = function () {\n          /**\n           * Properties of an Annotation.\n           * @memberof google.protobuf.GeneratedCodeInfo\n           * @interface IAnnotation\n           * @property {Array.<number>|null} [path] Annotation path\n           * @property {string|null} [sourceFile] Annotation sourceFile\n           * @property {number|null} [begin] Annotation begin\n           * @property {number|null} [end] Annotation end\n           */\n\n          /**\n           * Constructs a new Annotation.\n           * @memberof google.protobuf.GeneratedCodeInfo\n           * @classdesc Represents an Annotation.\n           * @implements IAnnotation\n           * @constructor\n           * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set\n           */\n          function Annotation(properties) {\n            this.path = [];\n            if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n            }\n          }\n          /**\n           * Annotation path.\n           * @member {Array.<number>} path\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @instance\n           */\n\n\n          Annotation.prototype.path = $util.emptyArray;\n          /**\n           * Annotation sourceFile.\n           * @member {string} sourceFile\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @instance\n           */\n\n          Annotation.prototype.sourceFile = \"\";\n          /**\n           * Annotation begin.\n           * @member {number} begin\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @instance\n           */\n\n          Annotation.prototype.begin = 0;\n          /**\n           * Annotation end.\n           * @member {number} end\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @instance\n           */\n\n          Annotation.prototype.end = 0;\n          /**\n           * Creates a new Annotation instance using the specified properties.\n           * @function create\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @static\n           * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set\n           * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance\n           */\n\n          Annotation.create = function create(properties) {\n            return new Annotation(properties);\n          };\n          /**\n           * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.\n           * @function encode\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @static\n           * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode\n           * @param {$protobuf.Writer} [writer] Writer to encode to\n           * @returns {$protobuf.Writer} Writer\n           */\n\n\n          Annotation.encode = function encode(message, writer) {\n            if (!writer) writer = $Writer.create();\n\n            if (message.path != null && message.path.length) {\n              writer.uint32(\n              /* id 1, wireType 2 =*/\n              10).fork();\n\n              for (var i = 0; i < message.path.length; ++i) {\n                writer.int32(message.path[i]);\n              }\n\n              writer.ldelim();\n            }\n\n            if (message.sourceFile != null && Object.hasOwnProperty.call(message, \"sourceFile\")) writer.uint32(\n            /* id 2, wireType 2 =*/\n            18).string(message.sourceFile);\n            if (message.begin != null && Object.hasOwnProperty.call(message, \"begin\")) writer.uint32(\n            /* id 3, wireType 0 =*/\n            24).int32(message.begin);\n            if (message.end != null && Object.hasOwnProperty.call(message, \"end\")) writer.uint32(\n            /* id 4, wireType 0 =*/\n            32).int32(message.end);\n            return writer;\n          };\n          /**\n           * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.\n           * @function encodeDelimited\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @static\n           * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode\n           * @param {$protobuf.Writer} [writer] Writer to encode to\n           * @returns {$protobuf.Writer} Writer\n           */\n\n\n          Annotation.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          /**\n           * Decodes an Annotation message from the specified reader or buffer.\n           * @function decode\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @static\n           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n           * @param {number} [length] Message length if known beforehand\n           * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation\n           * @throws {Error} If the payload is not a reader or valid buffer\n           * @throws {$protobuf.util.ProtocolError} If required fields are missing\n           */\n\n\n          Annotation.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length,\n                message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();\n\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n\n              switch (tag >>> 3) {\n                case 1:\n                  if (!(message.path && message.path.length)) message.path = [];\n\n                  if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n\n                    while (reader.pos < end2) {\n                      message.path.push(reader.int32());\n                    }\n                  } else message.path.push(reader.int32());\n\n                  break;\n\n                case 2:\n                  message.sourceFile = reader.string();\n                  break;\n\n                case 3:\n                  message.begin = reader.int32();\n                  break;\n\n                case 4:\n                  message.end = reader.int32();\n                  break;\n\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n\n            return message;\n          };\n          /**\n           * Decodes an Annotation message from the specified reader or buffer, length delimited.\n           * @function decodeDelimited\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @static\n           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n           * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation\n           * @throws {Error} If the payload is not a reader or valid buffer\n           * @throws {$protobuf.util.ProtocolError} If required fields are missing\n           */\n\n\n          Annotation.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          /**\n           * Verifies an Annotation message.\n           * @function verify\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @static\n           * @param {Object.<string,*>} message Plain object to verify\n           * @returns {string|null} `null` if valid, otherwise the reason why it is not\n           */\n\n\n          Annotation.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n              if (!Array.isArray(message.path)) return \"path: array expected\";\n\n              for (var i = 0; i < message.path.length; ++i) {\n                if (!$util.isInteger(message.path[i])) return \"path: integer[] expected\";\n              }\n            }\n\n            if (message.sourceFile != null && message.hasOwnProperty(\"sourceFile\")) if (!$util.isString(message.sourceFile)) return \"sourceFile: string expected\";\n            if (message.begin != null && message.hasOwnProperty(\"begin\")) if (!$util.isInteger(message.begin)) return \"begin: integer expected\";\n            if (message.end != null && message.hasOwnProperty(\"end\")) if (!$util.isInteger(message.end)) return \"end: integer expected\";\n            return null;\n          };\n          /**\n           * Creates an Annotation message from a plain object. Also converts values to their respective internal types.\n           * @function fromObject\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @static\n           * @param {Object.<string,*>} object Plain object\n           * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation\n           */\n\n\n          Annotation.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation) return object;\n            var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();\n\n            if (object.path) {\n              if (!Array.isArray(object.path)) throw TypeError(\".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected\");\n              message.path = [];\n\n              for (var i = 0; i < object.path.length; ++i) {\n                message.path[i] = object.path[i] | 0;\n              }\n            }\n\n            if (object.sourceFile != null) message.sourceFile = String(object.sourceFile);\n            if (object.begin != null) message.begin = object.begin | 0;\n            if (object.end != null) message.end = object.end | 0;\n            return message;\n          };\n          /**\n           * Creates a plain object from an Annotation message. Also converts values to other types if specified.\n           * @function toObject\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @static\n           * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation\n           * @param {$protobuf.IConversionOptions} [options] Conversion options\n           * @returns {Object.<string,*>} Plain object\n           */\n\n\n          Annotation.toObject = function toObject(message, options) {\n            if (!options) options = {};\n            var object = {};\n            if (options.arrays || options.defaults) object.path = [];\n\n            if (options.defaults) {\n              object.sourceFile = \"\";\n              object.begin = 0;\n              object.end = 0;\n            }\n\n            if (message.path && message.path.length) {\n              object.path = [];\n\n              for (var j = 0; j < message.path.length; ++j) {\n                object.path[j] = message.path[j];\n              }\n            }\n\n            if (message.sourceFile != null && message.hasOwnProperty(\"sourceFile\")) object.sourceFile = message.sourceFile;\n            if (message.begin != null && message.hasOwnProperty(\"begin\")) object.begin = message.begin;\n            if (message.end != null && message.hasOwnProperty(\"end\")) object.end = message.end;\n            return object;\n          };\n          /**\n           * Converts this Annotation to JSON.\n           * @function toJSON\n           * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n           * @instance\n           * @returns {Object.<string,*>} JSON object\n           */\n\n\n          Annotation.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n\n          return Annotation;\n        }();\n\n        return GeneratedCodeInfo;\n      }();\n\n      protobuf.Timestamp = function () {\n        /**\n         * Properties of a Timestamp.\n         * @memberof google.protobuf\n         * @interface ITimestamp\n         * @property {number|Long|null} [seconds] Timestamp seconds\n         * @property {number|null} [nanos] Timestamp nanos\n         */\n\n        /**\n         * Constructs a new Timestamp.\n         * @memberof google.protobuf\n         * @classdesc Represents a Timestamp.\n         * @implements ITimestamp\n         * @constructor\n         * @param {google.protobuf.ITimestamp=} [properties] Properties to set\n         */\n        function Timestamp(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Timestamp seconds.\n         * @member {number|Long} seconds\n         * @memberof google.protobuf.Timestamp\n         * @instance\n         */\n\n\n        Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Timestamp nanos.\n         * @member {number} nanos\n         * @memberof google.protobuf.Timestamp\n         * @instance\n         */\n\n        Timestamp.prototype.nanos = 0;\n        /**\n         * Creates a new Timestamp instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.Timestamp\n         * @static\n         * @param {google.protobuf.ITimestamp=} [properties] Properties to set\n         * @returns {google.protobuf.Timestamp} Timestamp instance\n         */\n\n        Timestamp.create = function create(properties) {\n          return new Timestamp(properties);\n        };\n        /**\n         * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.Timestamp\n         * @static\n         * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Timestamp.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int64(message.seconds);\n          if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.nanos);\n          return writer;\n        };\n        /**\n         * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.Timestamp\n         * @static\n         * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Timestamp.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Timestamp message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.Timestamp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.Timestamp} Timestamp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Timestamp.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.Timestamp();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.seconds = reader.int64();\n                break;\n\n              case 2:\n                message.nanos = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Timestamp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.Timestamp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.Timestamp} Timestamp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Timestamp.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Timestamp message.\n         * @function verify\n         * @memberof google.protobuf.Timestamp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Timestamp.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.seconds != null && message.hasOwnProperty(\"seconds\")) if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))) return \"seconds: integer|Long expected\";\n          if (message.nanos != null && message.hasOwnProperty(\"nanos\")) if (!$util.isInteger(message.nanos)) return \"nanos: integer expected\";\n          return null;\n        };\n        /**\n         * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.Timestamp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.Timestamp} Timestamp\n         */\n\n\n        Timestamp.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.Timestamp) return object;\n          var message = new $root.google.protobuf.Timestamp();\n          if (object.seconds != null) if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;else if (typeof object.seconds === \"string\") message.seconds = parseInt(object.seconds, 10);else if (typeof object.seconds === \"number\") message.seconds = object.seconds;else if (typeof object.seconds === \"object\") message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();\n          if (object.nanos != null) message.nanos = object.nanos | 0;\n          return message;\n        };\n        /**\n         * Creates a plain object from a Timestamp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.Timestamp\n         * @static\n         * @param {google.protobuf.Timestamp} message Timestamp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Timestamp.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.seconds = options.longs === String ? \"0\" : 0;\n\n            object.nanos = 0;\n          }\n\n          if (message.seconds != null && message.hasOwnProperty(\"seconds\")) if (typeof message.seconds === \"number\") object.seconds = options.longs === String ? String(message.seconds) : message.seconds;else object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;\n          if (message.nanos != null && message.hasOwnProperty(\"nanos\")) object.nanos = message.nanos;\n          return object;\n        };\n        /**\n         * Converts this Timestamp to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.Timestamp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Timestamp.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Timestamp;\n      }();\n\n      protobuf.Duration = function () {\n        /**\n         * Properties of a Duration.\n         * @memberof google.protobuf\n         * @interface IDuration\n         * @property {number|Long|null} [seconds] Duration seconds\n         * @property {number|null} [nanos] Duration nanos\n         */\n\n        /**\n         * Constructs a new Duration.\n         * @memberof google.protobuf\n         * @classdesc Represents a Duration.\n         * @implements IDuration\n         * @constructor\n         * @param {google.protobuf.IDuration=} [properties] Properties to set\n         */\n        function Duration(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n        }\n        /**\n         * Duration seconds.\n         * @member {number|Long} seconds\n         * @memberof google.protobuf.Duration\n         * @instance\n         */\n\n\n        Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        /**\n         * Duration nanos.\n         * @member {number} nanos\n         * @memberof google.protobuf.Duration\n         * @instance\n         */\n\n        Duration.prototype.nanos = 0;\n        /**\n         * Creates a new Duration instance using the specified properties.\n         * @function create\n         * @memberof google.protobuf.Duration\n         * @static\n         * @param {google.protobuf.IDuration=} [properties] Properties to set\n         * @returns {google.protobuf.Duration} Duration instance\n         */\n\n        Duration.create = function create(properties) {\n          return new Duration(properties);\n        };\n        /**\n         * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.\n         * @function encode\n         * @memberof google.protobuf.Duration\n         * @static\n         * @param {google.protobuf.IDuration} message Duration message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Duration.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\")) writer.uint32(\n          /* id 1, wireType 0 =*/\n          8).int64(message.seconds);\n          if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\")) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.nanos);\n          return writer;\n        };\n        /**\n         * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof google.protobuf.Duration\n         * @static\n         * @param {google.protobuf.IDuration} message Duration message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Duration.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Duration message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.Duration\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.Duration} Duration\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Duration.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.Duration();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.seconds = reader.int64();\n                break;\n\n              case 2:\n                message.nanos = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Duration message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof google.protobuf.Duration\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {google.protobuf.Duration} Duration\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Duration.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Duration message.\n         * @function verify\n         * @memberof google.protobuf.Duration\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Duration.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.seconds != null && message.hasOwnProperty(\"seconds\")) if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))) return \"seconds: integer|Long expected\";\n          if (message.nanos != null && message.hasOwnProperty(\"nanos\")) if (!$util.isInteger(message.nanos)) return \"nanos: integer expected\";\n          return null;\n        };\n        /**\n         * Creates a Duration message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof google.protobuf.Duration\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {google.protobuf.Duration} Duration\n         */\n\n\n        Duration.fromObject = function fromObject(object) {\n          if (object instanceof $root.google.protobuf.Duration) return object;\n          var message = new $root.google.protobuf.Duration();\n          if (object.seconds != null) if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;else if (typeof object.seconds === \"string\") message.seconds = parseInt(object.seconds, 10);else if (typeof object.seconds === \"number\") message.seconds = object.seconds;else if (typeof object.seconds === \"object\") message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();\n          if (object.nanos != null) message.nanos = object.nanos | 0;\n          return message;\n        };\n        /**\n         * Creates a plain object from a Duration message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof google.protobuf.Duration\n         * @static\n         * @param {google.protobuf.Duration} message Duration\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Duration.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else object.seconds = options.longs === String ? \"0\" : 0;\n\n            object.nanos = 0;\n          }\n\n          if (message.seconds != null && message.hasOwnProperty(\"seconds\")) if (typeof message.seconds === \"number\") object.seconds = options.longs === String ? String(message.seconds) : message.seconds;else object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;\n          if (message.nanos != null && message.hasOwnProperty(\"nanos\")) object.nanos = message.nanos;\n          return object;\n        };\n        /**\n         * Converts this Duration to JSON.\n         * @function toJSON\n         * @memberof google.protobuf.Duration\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Duration.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Duration;\n      }();\n\n      return protobuf;\n    }();\n\n    return google;\n  }();\n\n  return $root;\n});","map":null,"metadata":{},"sourceType":"script"}