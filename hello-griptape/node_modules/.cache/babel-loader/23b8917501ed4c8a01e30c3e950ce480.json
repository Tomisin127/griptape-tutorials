{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto_1 = require(\"@iov/crypto\");\n\nvar encoding_1 = require(\"@iov/encoding\");\n\nvar logs_1 = require(\"./logs\");\n\nvar restclient_1 = require(\"./restclient\");\n\nfunction isSearchByIdQuery(query) {\n  return query.id !== undefined;\n}\n\nfunction isSearchByHeightQuery(query) {\n  return query.height !== undefined;\n}\n\nfunction isSearchBySentFromOrToQuery(query) {\n  return query.sentFromOrTo !== undefined;\n}\n\nfunction isSearchByTagsQuery(query) {\n  return query.tags !== undefined;\n}\n\nvar CosmWasmClient = /*#__PURE__*/function () {\n  /**\n   * Creates a new client to interact with a CosmWasm blockchain.\n   *\n   * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n   * for the lifetime of your application. When switching backends, a new instance must be created.\n   *\n   * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n   * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n   */\n  function CosmWasmClient(apiUrl, seed) {\n    var broadcastMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : restclient_1.BroadcastMode.Block;\n\n    _classCallCheck(this, CosmWasmClient);\n\n    this.codesCache = new Map();\n    this.restClient = new restclient_1.RestClient(apiUrl, broadcastMode, seed);\n  }\n\n  _createClass(CosmWasmClient, [{\n    key: \"getChainId\",\n    value: function () {\n      var _getChainId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var response, chainId;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.chainId) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.restClient.nodeInfo();\n\n              case 3:\n                response = _context.sent;\n                chainId = response.node_info.network;\n\n                if (chainId) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Chain ID must not be empty\");\n\n              case 7:\n                this.chainId = chainId;\n\n              case 8:\n                return _context.abrupt(\"return\", this.chainId);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getChainId() {\n        return _getChainId.apply(this, arguments);\n      }\n\n      return getChainId;\n    }()\n  }, {\n    key: \"getHeight\",\n    value: function () {\n      var _getHeight = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _yield$this$restClien, height, latest;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.anyValidAddress) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.restClient.authAccounts(this.anyValidAddress);\n\n              case 3:\n                _yield$this$restClien = _context2.sent;\n                height = _yield$this$restClien.height;\n                return _context2.abrupt(\"return\", parseInt(height, 10));\n\n              case 8:\n                _context2.next = 10;\n                return this.restClient.blocksLatest();\n\n              case 10:\n                latest = _context2.sent;\n                return _context2.abrupt(\"return\", parseInt(latest.block.header.height, 10));\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getHeight() {\n        return _getHeight.apply(this, arguments);\n      }\n\n      return getHeight;\n    }()\n    /**\n     * Returns a 32 byte upper-case hex transaction hash (typically used as the transaction ID)\n     */\n\n  }, {\n    key: \"getIdentifier\",\n    value: function () {\n      var _getIdentifier = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(tx) {\n        var bytes, hash;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.restClient.encodeTx(tx);\n\n              case 2:\n                bytes = _context3.sent;\n                hash = new crypto_1.Sha256(bytes).digest();\n                return _context3.abrupt(\"return\", encoding_1.Encoding.toHex(hash).toUpperCase());\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getIdentifier(_x) {\n        return _getIdentifier.apply(this, arguments);\n      }\n\n      return getIdentifier;\n    }()\n    /**\n     * Returns account number and sequence.\n     *\n     * Throws if the account does not exist on chain.\n     *\n     * @param address returns data for this address. When unset, the client's sender adddress is used.\n     */\n\n  }, {\n    key: \"getNonce\",\n    value: function () {\n      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(address) {\n        var account;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.getAccount(address);\n\n              case 2:\n                account = _context4.sent;\n\n                if (!(!account || !account.address)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query nonces.\");\n\n              case 5:\n                return _context4.abrupt(\"return\", {\n                  accountNumber: account.accountNumber,\n                  sequence: account.sequence\n                });\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getNonce(_x2) {\n        return _getNonce.apply(this, arguments);\n      }\n\n      return getNonce;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function () {\n      var _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(address) {\n        var _a, account, value;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.restClient.authAccounts(address);\n\n              case 2:\n                account = _context5.sent;\n                value = account.result.value;\n\n                if (!(value.address === undefined || value.address === \"\")) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", undefined);\n\n              case 8:\n                this.anyValidAddress = value.address;\n                return _context5.abrupt(\"return\", {\n                  address: value.address,\n                  balance: value.coins,\n                  pubkey: !!((_a = value) === null || _a === void 0 ? void 0 : _a.public_key) ? JSON.parse(value.public_key) : undefined,\n                  accountNumber: value.account_number,\n                  sequence: value.sequence\n                });\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getAccount(_x3) {\n        return _getAccount.apply(this, arguments);\n      }\n\n      return getAccount;\n    }()\n    /**\n     * Gets block header and meta\n     *\n     * @param height The height of the block. If undefined, the latest height is used.\n     */\n\n  }, {\n    key: \"getBlock\",\n    value: function () {\n      var _getBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(height) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(height !== undefined)) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                _context6.next = 3;\n                return this.restClient.blocks(height);\n\n              case 3:\n                _context6.t0 = _context6.sent;\n                _context6.next = 9;\n                break;\n\n              case 6:\n                _context6.next = 8;\n                return this.restClient.blocksLatest();\n\n              case 8:\n                _context6.t0 = _context6.sent;\n\n              case 9:\n                response = _context6.t0;\n                return _context6.abrupt(\"return\", {\n                  id: response.block_id.hash,\n                  header: {\n                    version: response.block.header.version,\n                    time: response.block.header.time,\n                    height: parseInt(response.block.header.height, 10),\n                    chainId: response.block.header.chain_id\n                  },\n                  txs: (response.block.data.txs || []).map(function (encoded) {\n                    return encoding_1.Encoding.fromBase64(encoded);\n                  })\n                });\n\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getBlock(_x4) {\n        return _getBlock.apply(this, arguments);\n      }\n\n      return getBlock;\n    }()\n  }, {\n    key: \"searchTx\",\n    value: function () {\n      var _searchTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(query) {\n        var filter,\n            minHeight,\n            maxHeight,\n            withFilters,\n            txs,\n            sentQuery,\n            receivedQuery,\n            sent,\n            received,\n            sentHashes,\n            rawQuery,\n            filtered,\n            _args7 = arguments;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                withFilters = function _withFilters(originalQuery) {\n                  return \"\".concat(originalQuery, \"&tx.minheight=\").concat(minHeight, \"&tx.maxheight=\").concat(maxHeight);\n                };\n\n                filter = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n                minHeight = filter.minHeight || 0;\n                maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n\n                if (!(maxHeight < minHeight)) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", []);\n\n              case 6:\n                if (!isSearchByIdQuery(query)) {\n                  _context7.next = 12;\n                  break;\n                }\n\n                _context7.next = 9;\n                return this.txsQuery(\"tx.hash=\".concat(query.id));\n\n              case 9:\n                txs = _context7.sent;\n                _context7.next = 43;\n                break;\n\n              case 12:\n                if (!isSearchByHeightQuery(query)) {\n                  _context7.next = 22;\n                  break;\n                }\n\n                if (!(query.height < minHeight || query.height > maxHeight)) {\n                  _context7.next = 17;\n                  break;\n                }\n\n                txs = [];\n                _context7.next = 20;\n                break;\n\n              case 17:\n                _context7.next = 19;\n                return this.txsQuery(\"tx.height=\".concat(query.height));\n\n              case 19:\n                txs = _context7.sent;\n\n              case 20:\n                _context7.next = 43;\n                break;\n\n              case 22:\n                if (!isSearchBySentFromOrToQuery(query)) {\n                  _context7.next = 35;\n                  break;\n                }\n\n                // We cannot get both in one request (see https://github.com/cosmos/gaia/issues/75)\n                sentQuery = withFilters(\"message.module=bank&message.sender=\".concat(query.sentFromOrTo));\n                receivedQuery = withFilters(\"message.module=bank&transfer.recipient=\".concat(query.sentFromOrTo));\n                _context7.next = 27;\n                return this.txsQuery(sentQuery);\n\n              case 27:\n                sent = _context7.sent;\n                _context7.next = 30;\n                return this.txsQuery(receivedQuery);\n\n              case 30:\n                received = _context7.sent;\n                sentHashes = sent.map(function (t) {\n                  return t.hash;\n                });\n                txs = [].concat(_toConsumableArray(sent), _toConsumableArray(received.filter(function (t) {\n                  return !sentHashes.includes(t.hash);\n                })));\n                _context7.next = 43;\n                break;\n\n              case 35:\n                if (!isSearchByTagsQuery(query)) {\n                  _context7.next = 42;\n                  break;\n                }\n\n                rawQuery = withFilters(query.tags.map(function (t) {\n                  return \"\".concat(t.key, \"=\").concat(t.value);\n                }).join(\"&\"));\n                _context7.next = 39;\n                return this.txsQuery(rawQuery);\n\n              case 39:\n                txs = _context7.sent;\n                _context7.next = 43;\n                break;\n\n              case 42:\n                throw new Error(\"Unknown query type\");\n\n              case 43:\n                // backend sometimes messes up with min/max height filtering\n                filtered = txs.filter(function (tx) {\n                  return tx.height >= minHeight && tx.height <= maxHeight;\n                });\n                return _context7.abrupt(\"return\", filtered);\n\n              case 45:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function searchTx(_x5) {\n        return _searchTx.apply(this, arguments);\n      }\n\n      return searchTx;\n    }()\n  }, {\n    key: \"postTx\",\n    value: function () {\n      var _postTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(tx) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.restClient.postTx(tx);\n\n              case 2:\n                result = _context8.sent;\n\n                if (result.txhash.match(/^([0-9A-F][0-9A-F])+$/)) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Received ill-formatted txhash. Must be non-empty upper-case hex\");\n\n              case 5:\n                if (!result.code) {\n                  _context8.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Error when posting tx \".concat(result.txhash, \". Code: \").concat(result.code, \"; Raw log: \").concat(result.raw_log));\n\n              case 7:\n                return _context8.abrupt(\"return\", {\n                  logs: result.logs ? logs_1.parseLogs(result.logs) : [],\n                  rawLog: result.raw_log || \"\",\n                  transactionHash: result.txhash,\n                  data: result.data || \"\"\n                });\n\n              case 8:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function postTx(_x6) {\n        return _postTx.apply(this, arguments);\n      }\n\n      return postTx;\n    }()\n  }, {\n    key: \"getCodes\",\n    value: function () {\n      var _getCodes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _this = this;\n\n        var result;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.restClient.listCodeInfo();\n\n              case 2:\n                result = _context9.sent;\n                return _context9.abrupt(\"return\", result.map(function (entry) {\n                  _this.anyValidAddress = entry.creator;\n                  return {\n                    id: entry.id,\n                    creator: entry.creator,\n                    checksum: encoding_1.Encoding.toHex(encoding_1.Encoding.fromHex(entry.data_hash)),\n                    source: entry.source || undefined,\n                    builder: entry.builder || undefined\n                  };\n                }));\n\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getCodes() {\n        return _getCodes.apply(this, arguments);\n      }\n\n      return getCodes;\n    }()\n  }, {\n    key: \"getCodeDetails\",\n    value: function () {\n      var _getCodeDetails = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(codeId) {\n        var cached, getCodeResult, codeDetails;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                cached = this.codesCache.get(codeId);\n\n                if (!cached) {\n                  _context10.next = 3;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", cached);\n\n              case 3:\n                _context10.next = 5;\n                return this.restClient.getCode(codeId);\n\n              case 5:\n                getCodeResult = _context10.sent;\n                codeDetails = {\n                  id: getCodeResult.id,\n                  creator: getCodeResult.creator,\n                  checksum: encoding_1.Encoding.toHex(encoding_1.Encoding.fromHex(getCodeResult.data_hash)),\n                  source: getCodeResult.source || undefined,\n                  builder: getCodeResult.builder || undefined,\n                  data: encoding_1.Encoding.fromBase64(getCodeResult.data)\n                };\n                this.codesCache.set(codeId, codeDetails);\n                return _context10.abrupt(\"return\", codeDetails);\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getCodeDetails(_x7) {\n        return _getCodeDetails.apply(this, arguments);\n      }\n\n      return getCodeDetails;\n    }()\n  }, {\n    key: \"getContracts\",\n    value: function () {\n      var _getContracts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(codeId) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.restClient.listContractsByCodeId(codeId);\n\n              case 2:\n                result = _context11.sent;\n                return _context11.abrupt(\"return\", result.map(function (entry) {\n                  return {\n                    address: entry.address,\n                    codeId: entry.code_id,\n                    creator: entry.creator,\n                    label: entry.label\n                  };\n                }));\n\n              case 4:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getContracts(_x8) {\n        return _getContracts.apply(this, arguments);\n      }\n\n      return getContracts;\n    }()\n    /**\n     * Throws an error if no contract was found at the address\n     */\n\n  }, {\n    key: \"getContract\",\n    value: function () {\n      var _getContract = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(address) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.restClient.getContractInfo(address);\n\n              case 2:\n                result = _context12.sent;\n\n                if (result) {\n                  _context12.next = 5;\n                  break;\n                }\n\n                throw new Error(\"No contract found at address \\\"\".concat(address, \"\\\"\"));\n\n              case 5:\n                return _context12.abrupt(\"return\", {\n                  address: result.address,\n                  codeId: result.code_id,\n                  creator: result.creator,\n                  label: result.label,\n                  initMsg: result.init_msg\n                });\n\n              case 6:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getContract(_x9) {\n        return _getContract.apply(this, arguments);\n      }\n\n      return getContract;\n    }()\n    /**\n     * Makes a smart query on the contract, returns the parsed JSON document.\n     *\n     * Promise is rejected when contract does not exist.\n     * Promise is rejected for invalid query format.\n     * Promise is rejected for invalid response format.\n     *\n     * Note: addedParams allows for query string additions such as \"&height=1234567\"\n     */\n\n  }, {\n    key: \"queryContractSmart\",\n    value: function () {\n      var _queryContractSmart = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(contractAddress, queryMsg, addedParams, contractCodeHash) {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n                _context13.next = 3;\n                return this.restClient.queryContractSmart(contractAddress, queryMsg, addedParams, contractCodeHash);\n\n              case 3:\n                return _context13.abrupt(\"return\", _context13.sent);\n\n              case 6:\n                _context13.prev = 6;\n                _context13.t0 = _context13[\"catch\"](0);\n\n                if (!(_context13.t0 instanceof Error)) {\n                  _context13.next = 16;\n                  break;\n                }\n\n                if (!_context13.t0.message.startsWith(\"not found: contract\")) {\n                  _context13.next = 13;\n                  break;\n                }\n\n                throw new Error(\"No contract found at address \\\"\".concat(contractAddress, \"\\\"\"));\n\n              case 13:\n                throw _context13.t0;\n\n              case 14:\n                _context13.next = 17;\n                break;\n\n              case 16:\n                throw _context13.t0;\n\n              case 17:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[0, 6]]);\n      }));\n\n      function queryContractSmart(_x10, _x11, _x12, _x13) {\n        return _queryContractSmart.apply(this, arguments);\n      }\n\n      return queryContractSmart;\n    }()\n  }, {\n    key: \"txsQuery\",\n    value: function () {\n      var _txsQuery = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(query) {\n        var limit, result, pages;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                // TODO: we need proper pagination support\n                limit = 100;\n                _context14.next = 3;\n                return this.restClient.txsQuery(\"\".concat(query, \"&limit=\").concat(limit));\n\n              case 3:\n                result = _context14.sent;\n                pages = parseInt(result.page_total, 10);\n\n                if (!(pages > 1)) {\n                  _context14.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Found more results on the backend than we can process currently. Results: \".concat(result.total_count, \", supported: \").concat(limit));\n\n              case 7:\n                return _context14.abrupt(\"return\", result.txs.map(function (restItem) {\n                  return {\n                    height: parseInt(restItem.height, 10),\n                    hash: restItem.txhash,\n                    code: restItem.code || 0,\n                    rawLog: restItem.raw_log,\n                    logs: logs_1.parseLogs(restItem.logs || []),\n                    tx: restItem.tx,\n                    timestamp: restItem.timestamp\n                  };\n                }));\n\n              case 8:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function txsQuery(_x14) {\n        return _txsQuery.apply(this, arguments);\n      }\n\n      return txsQuery;\n    }()\n  }, {\n    key: \"getCodeHashByCodeId\",\n    value: function getCodeHashByCodeId(id) {\n      return this.restClient.getCodeHashByCodeId(id);\n    }\n  }, {\n    key: \"getCodeHashByContractAddr\",\n    value: function getCodeHashByContractAddr(addr) {\n      return this.restClient.getCodeHashByContractAddr(addr);\n    }\n  }, {\n    key: \"getNonceByTxId\",\n    value: function () {\n      var _getNonceByTxId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(txhash) {\n        var txResponse, msgs, result, _iterator, _step, msg, nonce;\n\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.restClient.txById(txhash, false);\n\n              case 2:\n                txResponse = _context15.sent;\n                msgs = txResponse.tx.value.msg;\n                result = [];\n                _iterator = _createForOfIteratorHelper(msgs);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    msg = _step.value;\n                    nonce = void 0;\n\n                    if (msg.type === \"wasm/MsgExecuteContract\") {\n                      nonce = encoding_1.Encoding.fromBase64(msg.value.msg).slice(0, 32);\n                    } else if (msg.type === \"wasm/MsgInstantiateContract\") {\n                      nonce = encoding_1.Encoding.fromBase64(msg.value.init_msg).slice(0, 32);\n                    } else {\n                      nonce = null;\n                    }\n\n                    result.push(nonce);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                return _context15.abrupt(\"return\", result);\n\n              case 8:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getNonceByTxId(_x15) {\n        return _getNonceByTxId.apply(this, arguments);\n      }\n\n      return getNonceByTxId;\n    }()\n  }]);\n\n  return CosmWasmClient;\n}();\n\nexports.CosmWasmClient = CosmWasmClient;","map":null,"metadata":{},"sourceType":"script"}