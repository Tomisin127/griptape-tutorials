{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016-2017 Tony Arcieri, Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Propietario\\\\griptape-tutorials\\\\hello-griptape\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar block_1 = require(\"../internals/block\");\n\nvar constant_time_1 = require(\"../internals/constant-time\");\n\nvar ctz_1 = require(\"../internals/ctz\");\n\nvar xor_1 = require(\"../internals/xor\"); // Number of L blocks to precompute (i.e. µ in the PMAC paper)\n// TODO: dynamically compute these as needed\n\n\nvar PRECOMPUTED_BLOCKS = 31;\n/**\n * Polyfill for the AES-PMAC message authentication code\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n */\n\nvar PMAC = /*#__PURE__*/function () {\n  function PMAC(cipher, l, lInv) {\n    _classCallCheck(this, PMAC);\n\n    /**\n     * finished is set true when we are done processing a message, and forbids\n     * any subsequent writes until we reset the internal state\n     */\n    this._finished = false;\n    this._cipher = cipher;\n    this._L = l;\n    this._LInv = lInv;\n    this._buffer = new block_1.default();\n    this._bufferPos = 0;\n    this._counter = 0;\n    this._offset = new block_1.default();\n    this._tag = new block_1.default();\n  }\n  /** Create a new CMAC instance from the given key */\n\n\n  _createClass(PMAC, [{\n    key: \"reset\",\n    value: function reset() {\n      this._buffer.clear();\n\n      this._bufferPos = 0;\n      this._counter = 0;\n\n      this._offset.clear();\n\n      this._tag.clear();\n\n      this._finished = false;\n      return this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.reset();\n\n      this._cipher.clear();\n    }\n  }, {\n    key: \"update\",\n    value: function update(data) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var left, dataPos, dataLength;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._finished) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(\"pmac: already finished\");\n\n              case 2:\n                left = block_1.default.SIZE - this._bufferPos;\n                dataPos = 0;\n                dataLength = data.length; // Finish filling the internal buf with the message\n\n                if (!(dataLength > left)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                this._buffer.data.set(data.slice(0, left), this._bufferPos);\n\n                dataPos += left;\n                dataLength -= left;\n                _context.next = 11;\n                return this._processBuffer();\n\n              case 11:\n                if (!(dataLength > block_1.default.SIZE)) {\n                  _context.next = 19;\n                  break;\n                }\n\n                this._buffer.data.set(data.slice(dataPos, dataPos + block_1.default.SIZE));\n\n                dataPos += block_1.default.SIZE;\n                dataLength -= block_1.default.SIZE;\n                _context.next = 17;\n                return this._processBuffer();\n\n              case 17:\n                _context.next = 11;\n                break;\n\n              case 19:\n                if (dataLength > 0) {\n                  this._buffer.data.set(data.slice(dataPos, dataPos + dataLength), this._bufferPos);\n\n                  this._bufferPos += dataLength;\n                }\n\n                return _context.abrupt(\"return\", this);\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._finished) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error(\"pmac: already finished\");\n\n              case 2:\n                if (this._bufferPos === block_1.default.SIZE) {\n                  xor_1.xor(this._tag.data, this._buffer.data);\n                  xor_1.xor(this._tag.data, this._LInv.data);\n                } else {\n                  xor_1.xor(this._tag.data, this._buffer.data.slice(0, this._bufferPos));\n                  this._tag.data[this._bufferPos] ^= 0x80;\n                }\n\n                _context2.next = 5;\n                return this._cipher.encryptBlock(this._tag);\n\n              case 5:\n                this._finished = true;\n                return _context2.abrupt(\"return\", this._tag.clone().data);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    } // Update the internal tag state based on the buffer contents\n\n  }, {\n    key: \"_processBuffer\",\n    value: function _processBuffer() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                xor_1.xor(this._offset.data, this._L[ctz_1.ctz(this._counter + 1)].data);\n                xor_1.xor(this._buffer.data, this._offset.data);\n                this._counter++;\n                _context3.next = 5;\n                return this._cipher.encryptBlock(this._buffer);\n\n              case 5:\n                xor_1.xor(this._tag.data, this._buffer.data);\n                this._bufferPos = 0;\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }], [{\n    key: \"importKey\",\n    value: function importKey(provider, keyData) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var cipher, tmp, l, i, lInv, lastBit, _i, carry;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return provider.importBlockCipherKey(keyData);\n\n              case 2:\n                cipher = _context4.sent;\n\n                /**\n                 * L is defined as follows (quoted from the PMAC paper):\n                 *\n                 * Equation 1:\n                 *\n                 *     a · x =\n                 *         a<<1 if firstbit(a)=0\n                 *         (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n                 *\n                 * Equation 2:\n                 *\n                 *     a · x⁻¹ =\n                 *         a>>1 if lastbit(a)=0\n                 *         (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n                 *\n                 * Let L(0) ← L. For i ∈ [1..µ], compute L(i) ← L(i − 1) · x by\n                 * Equation (1) using a shift and a conditional xor.\n                 *\n                 * Compute L(−1) ← L · x⁻¹ by Equation (2), using a shift and a\n                 * conditional xor.\n                 *\n                 * Save the values L(−1), L(0), L(1), L(2), ..., L(µ) in a table.\n                 * (Alternatively, [ed: as we have done in this codebase] defer computing\n                 * some or  all of these L(i) values until the value is actually needed.)\n                 */\n                tmp = new block_1.default();\n                _context4.next = 6;\n                return cipher.encryptBlock(tmp);\n\n              case 6:\n                l = new Array(PRECOMPUTED_BLOCKS);\n\n                for (i = 0; i < PRECOMPUTED_BLOCKS; i++) {\n                  l[i] = tmp.clone();\n                  tmp.dbl();\n                }\n                /**\n                 * Compute L(−1) ← L · x⁻¹:\n                 *\n                 *     a>>1 if lastbit(a)=0\n                 *     (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n                 */\n\n\n                lInv = l[0].clone();\n                lastBit = lInv.data[block_1.default.SIZE - 1] & 0x01;\n\n                for (_i = block_1.default.SIZE - 1; _i > 0; _i--) {\n                  carry = constant_time_1.select(lInv.data[_i - 1] & 1, 0x80, 0);\n                  lInv.data[_i] = lInv.data[_i] >>> 1 | carry;\n                }\n\n                lInv.data[0] >>>= 1;\n                lInv.data[0] ^= constant_time_1.select(lastBit, 0x80, 0);\n                lInv.data[block_1.default.SIZE - 1] ^= constant_time_1.select(lastBit, block_1.default.R >>> 1, 0);\n                return _context4.abrupt(\"return\", new PMAC(cipher, l, lInv));\n\n              case 15:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n    }\n  }]);\n\n  return PMAC;\n}();\n\nexports.PMAC = PMAC;","map":null,"metadata":{},"sourceType":"script"}