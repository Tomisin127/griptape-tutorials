import { ContractDefinition, BaseContract, ContractMessageResponse } from '../types';
export declare const snip721Def: ContractDefinition;
export declare type Expiration = {
    at_height: number;
} | {
    at_time: number;
} | 'never';
export declare type AccessLevel = 'approve_token' | 'all' | 'revoke_token' | 'none';
export declare type Approval = {
    spender: string;
    expires: Expiration;
};
export declare type Extension = {
    image?: string;
    image_data?: string;
    external_uri?: string;
    description?: string;
    name?: string;
    attributes?: Trait[];
    background_color?: string;
    animation_url?: string;
    youtube_url?: string;
    media?: Media[];
    protected_attributes?: string[];
};
export declare type Media = {
    file_type?: string;
    extension?: string;
    authentication?: {
        key?: string;
        user?: string;
    };
    url?: string;
};
export declare type Trait = {
    displa_type?: string;
    trait_type?: string;
    value?: string;
    max_value?: string;
};
export interface Snip721Contract extends BaseContract {
    getContractInfo(): Promise<{
        contract_info: {
            name: string;
            symbol: string;
        };
    }>;
    getNumTokens(): Promise<{
        num_tokens: {
            count: number;
        };
    }>;
    getOwnerOf(token_id: string, include_expired?: boolean): Promise<{
        owner_of: {
            owner: string;
            approvals: Approval[];
        };
    }>;
    getNftInfo(token_id: string): Promise<{
        nft_info: {
            name: string;
            description: string;
            image: string;
        };
    }>;
    getAllNftInfo(token_id: string, include_expired?: boolean): Promise<{
        all_nft_info: {
            access: {
                owner: string;
                approvals: Approval[];
            };
            info: {
                name: string;
                description: string;
                image: string;
            };
        };
    }>;
    getPrivateMetadata(token_id: string): Promise<{
        private_metadata: {
            token_uri?: string;
            extension?: Extension;
        };
    }>;
    getNftDossier(token_id: string, include_expired?: boolean): Promise<{
        nft_dossier: {
            owner: string;
            public_metadata: {
                token_uri?: string;
                extension?: Extension;
            };
            private_metadata: {
                token_uri?: string;
                extension?: Extension;
            };
            display_private_metadata_error: string;
            royalty_info: {
                decimal_places_in_rates: number;
                royalties: {
                    recipient: string;
                    rate: number;
                }[];
            };
            mint_run_info: {
                collection_creator: string;
                token_creator: string;
                time_of_minting: number;
                mint_run: number;
                serial_number: number;
                quantity_minted_this_run: number;
            };
            owner_is_public: boolean;
            public_ownership_expiration: Expiration;
            private_metadata_is_public: boolean;
            private_metadata_is_public_expiration: Expiration;
            token_approvals: {
                address: string;
                view_owner_expiration: Expiration;
                view_private_metadata_expiration: Expiration;
                transfer_expiration: Expiration;
            }[];
            inventory_approvals: {
                address: string;
                view_owner_expiration: Expiration;
                view_private_metadata_expiration: Expiration;
                transfer_expiration: Expiration;
            }[];
        };
    }>;
    getTokenApprovals(token_id: string, include_expired?: boolean): Promise<{
        token_approvals: {
            token_id: string;
            viewing_key: string;
            include_expired: boolean;
        };
    }>;
    getApprovedForAll(include_expired?: boolean): {
        approved_for_all: {
            operators: {
                spender: string;
                expires: string;
            }[];
        };
    };
    getInventoryApprovals(include_expired?: boolean): Promise<{
        inventory_approvals: {
            owner_is_public: boolean;
            public_ownership_expiration: string;
            private_metadata_is_public: boolean;
            private_metadata_is_public_expiration: string;
            inventory_approvals: {
                address: string;
                view_owner_expiration: string;
                view_private_metadata_expiration: string;
                transfer_expiration: string;
            }[];
        };
    }>;
    getTokens(owner: string, start_after?: string, limit?: number): Promise<{
        token_list: {
            tokens: string[];
        };
    }>;
    getTransactionHistory(page?: number, page_size?: number): Promise<{
        transaction_history: {
            total: number;
            txs: {
                tx_id: number;
                block_height: number;
                block_time: number;
                token_id: string;
                action: {
                    transfer?: {
                        from: string;
                        sender: string;
                        recipient: string;
                    };
                    mint?: {
                        minter: string;
                        recipient: string;
                    };
                    burn?: {
                        owner: string;
                        burner: string;
                    };
                };
                memo: string;
            }[];
        };
    }>;
    transfer(recipient: string, token_id: string, memo?: string): Promise<ContractMessageResponse<{
        transfer_nft: {
            status: string;
        };
    }>>;
    send(contract: string, token_id: string, msg?: string, memo?: string): Promise<ContractMessageResponse<{
        send_nft: {
            status: string;
        };
    }>>;
    approve(spender: string, token_id: string, expires: Expiration): Promise<ContractMessageResponse<{
        approve: {
            status: string;
        };
    }>>;
    approveAll(operator: string, expires: Expiration): Promise<ContractMessageResponse<{
        approve_all: {
            status: string;
        };
    }>>;
    revoke(spender: string, token_id: string): Promise<ContractMessageResponse<{
        revoke: {
            status: string;
        };
    }>>;
    revokeAll(operator: string): Promise<ContractMessageResponse<{
        revoke_all: {
            status: string;
        };
    }>>;
    setWhiteListedApproval(address: string, token_id?: string, view_owner?: AccessLevel, view_private_metadata?: AccessLevel, transfer?: AccessLevel, expires?: Expiration): Promise<ContractMessageResponse<{
        set_whitelisted_approval: {
            status: string;
        };
    }>>;
    registerReceive(code_hash: string, also_implements_batch_receive_nft?: boolean): Promise<ContractMessageResponse<{
        register_receive_nft: {
            status: string;
        };
    }>>;
    createViewingKey(): Promise<ContractMessageResponse<{
        viewing_key: {
            key: string;
        };
    }>>;
    setViewingKey(key: string): Promise<ContractMessageResponse<{
        viewing_key: {
            key: string;
        };
    }>>;
}
